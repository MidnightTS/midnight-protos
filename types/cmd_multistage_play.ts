// @generated by protobuf-ts 2.8.1 with parameter output_typescript
// @generated from protobuf file "cmd_multistage_play.proto" (package "com.midnights.game", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { BuildingInfo } from "./define";
import { ExhibitionDisplayInfo } from "./define";
import { ProfilePicture } from "./define";
/**
 * @generated from protobuf message com.midnights.game.InBattleMechanicusBuildingInfo
 */
export interface InBattleMechanicusBuildingInfo {
    /**
     * @generated from protobuf field: optional uint32 building_id = 8;
     */
    buildingId?: number;
    /**
     * @generated from protobuf field: optional uint32 level = 7;
     */
    level?: number;
    /**
     * @generated from protobuf field: optional uint32 cost_points = 2;
     */
    costPoints?: number;
    /**
     * @generated from protobuf field: optional uint32 refund_points = 11;
     */
    refundPoints?: number;
}
/**
 * @generated from protobuf message com.midnights.game.InBattleMechanicusPlayerInfo
 */
export interface InBattleMechanicusPlayerInfo {
    /**
     * @generated from protobuf field: optional uint32 pick_card_id = 5;
     */
    pickCardId?: number;
    /**
     * @generated from protobuf field: optional uint32 uid = 14;
     */
    uid?: number;
    /**
     * @generated from protobuf field: repeated com.midnights.game.InBattleMechanicusBuildingInfo building_list = 4;
     */
    buildingList: InBattleMechanicusBuildingInfo[];
    /**
     * @generated from protobuf field: optional bool is_card_confirmed = 13;
     */
    isCardConfirmed?: boolean;
    /**
     * @generated from protobuf field: optional uint32 building_points = 3;
     */
    buildingPoints?: number;
}
/**
 * @generated from protobuf message com.midnights.game.InBattleMechanicusMonsterInfo
 */
export interface InBattleMechanicusMonsterInfo {
    /**
     * @generated from protobuf field: optional uint32 monster_id = 1;
     */
    monsterId?: number;
    /**
     * @generated from protobuf field: optional uint32 level = 14;
     */
    level?: number;
    /**
     * @generated from protobuf field: optional uint32 count = 13;
     */
    count?: number;
}
/**
 * @generated from protobuf message com.midnights.game.InBattleMechanicusCardInfo
 */
export interface InBattleMechanicusCardInfo {
    /**
     * @generated from protobuf field: optional uint32 rand_effect_id = 12;
     */
    randEffectId?: number;
    /**
     * @generated from protobuf field: optional uint32 end_round = 3;
     */
    endRound?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.InBattleMechanicusCardChallengeState challenge_state = 5;
     */
    challengeState?: InBattleMechanicusCardChallengeState;
    /**
     * @generated from protobuf field: optional uint32 cost_points = 1;
     */
    costPoints?: number;
    /**
     * @generated from protobuf field: optional uint32 card_id = 11;
     */
    cardId?: number;
    /**
     * @generated from protobuf field: optional uint32 begin_round = 8;
     */
    beginRound?: number;
}
/**
 * @generated from protobuf message com.midnights.game.InBattleMechanicusInfo
 */
export interface InBattleMechanicusInfo {
    /**
     * @generated from protobuf field: optional uint32 left_monster = 5;
     */
    leftMonster?: number;
    /**
     * @generated from protobuf field: optional uint32 wait_seconds = 13;
     */
    waitSeconds?: number;
    /**
     * @generated from protobuf field: repeated uint32 entrance_list = 410;
     */
    entranceList: number[];
    /**
     * @generated from protobuf field: repeated uint32 exit_list = 115;
     */
    exitList: number[];
    /**
     * @generated from protobuf field: repeated com.midnights.game.InBattleMechanicusCardInfo history_card_list = 11;
     */
    historyCardList: InBattleMechanicusCardInfo[];
    /**
     * @generated from protobuf field: optional uint32 max_excape_monster_num = 10;
     */
    maxExcapeMonsterNum?: number;
    /**
     * @generated from protobuf field: optional uint32 building_stage_duration = 4;
     */
    buildingStageDuration?: number;
    /**
     * @generated from protobuf field: optional uint64 duration_ms = 8;
     */
    durationMs?: bigint;
    /**
     * @generated from protobuf field: optional com.midnights.game.InBattleMechanicusStageType stage = 9;
     */
    stage?: InBattleMechanicusStageType;
    /**
     * @generated from protobuf field: optional uint32 total_round = 12;
     */
    totalRound?: number;
    /**
     * @generated from protobuf field: repeated com.midnights.game.InBattleMechanicusMonsterInfo monster_list = 14;
     */
    monsterList: InBattleMechanicusMonsterInfo[];
    /**
     * @generated from protobuf field: optional uint32 excaped_monster_num = 6;
     */
    excapedMonsterNum?: number;
    /**
     * @generated from protobuf field: optional uint32 round = 3;
     */
    round?: number;
    /**
     * @generated from protobuf field: repeated com.midnights.game.InBattleMechanicusCardInfo pick_card_list = 15;
     */
    pickCardList: InBattleMechanicusCardInfo[];
    /**
     * @generated from protobuf field: repeated com.midnights.game.InBattleMechanicusPlayerInfo player_list = 7;
     */
    playerList: InBattleMechanicusPlayerInfo[];
    /**
     * @generated from protobuf field: optional uint64 wait_begin_time_us = 1;
     */
    waitBeginTimeUs?: bigint;
    /**
     * @generated from protobuf field: optional uint64 begin_time_ms = 2;
     */
    beginTimeMs?: bigint;
}
/**
 * @generated from protobuf message com.midnights.game.InBattleFleurFairInfo
 */
export interface InBattleFleurFairInfo {
    /**
     * @generated from protobuf field: repeated uint32 gallery_id_list = 5;
     */
    galleryIdList: number[];
    /**
     * @generated from protobuf field: optional uint32 gallery_stage_index = 6;
     */
    galleryStageIndex?: number;
    /**
     * @generated from protobuf field: optional uint32 preview_stage_index = 8;
     */
    previewStageIndex?: number;
    /**
     * @generated from protobuf field: repeated uint32 ability_group_id_list = 2;
     */
    abilityGroupIdList: number[];
    /**
     * @generated from protobuf field: optional uint32 preview_display_duration = 12;
     */
    previewDisplayDuration?: number;
}
/**
 * @generated from protobuf message com.midnights.game.CharAmusementAvatarInfo
 */
export interface CharAmusementAvatarInfo {
    /**
     * @generated from protobuf field: optional uint32 uid = 11;
     */
    uid?: number;
    /**
     * @generated from protobuf field: optional uint32 punish_time = 7;
     */
    punishTime?: number;
    /**
     * @generated from protobuf field: repeated uint32 avatar_id_list = 10;
     */
    avatarIdList: number[];
}
/**
 * @generated from protobuf message com.midnights.game.CharAmusementInfo
 */
export interface CharAmusementInfo {
    /**
     * @generated from protobuf field: optional uint32 total_cost_time = 11;
     */
    totalCostTime?: number;
    /**
     * @generated from protobuf field: optional uint32 stage_id = 2;
     */
    stageId?: number;
    /**
     * @generated from protobuf field: optional uint32 level_id = 10;
     */
    levelId?: number;
    /**
     * @generated from protobuf field: optional uint32 preview_stage_index = 4;
     */
    previewStageIndex?: number;
    /**
     * @generated from protobuf field: repeated com.midnights.game.CharAmusementAvatarInfo avatar_info_list = 5;
     */
    avatarInfoList: CharAmusementAvatarInfo[];
}
/**
 * @generated from protobuf message com.midnights.game.MultistagePlayInfo
 */
export interface MultistagePlayInfo {
    /**
     * @generated from protobuf field: optional uint32 play_index = 13;
     */
    playIndex?: number;
    /**
     * @generated from protobuf field: optional uint32 play_type = 11;
     */
    playType?: number;
    /**
     * @generated from protobuf field: optional uint32 stage_type = 10;
     */
    stageType?: number;
    /**
     * @generated from protobuf field: optional uint32 duration = 8;
     */
    duration?: number;
    /**
     * @generated from protobuf field: optional uint32 group_id = 12;
     */
    groupId?: number;
    /**
     * @generated from protobuf field: optional uint32 begin_time = 9;
     */
    beginTime?: number;
    /**
     * @generated from protobuf field: optional uint32 stage_index = 1;
     */
    stageIndex?: number;
    /**
     * @generated from protobuf oneof: detail
     */
    detail: {
        oneofKind: "mechanicusInfo";
        /**
         * @generated from protobuf field: com.midnights.game.InBattleMechanicusInfo mechanicus_info = 1334;
         */
        mechanicusInfo: InBattleMechanicusInfo;
    } | {
        oneofKind: "fleurFairInfo";
        /**
         * @generated from protobuf field: com.midnights.game.InBattleFleurFairInfo fleur_fair_info = 1064;
         */
        fleurFairInfo: InBattleFleurFairInfo;
    } | {
        oneofKind: "hideAndSeekInfo";
        /**
         * @generated from protobuf field: com.midnights.game.HideAndSeekStageInfo hide_and_seek_info = 108;
         */
        hideAndSeekInfo: HideAndSeekStageInfo;
    } | {
        oneofKind: "chessInfo";
        /**
         * @generated from protobuf field: com.midnights.game.InBattleChessInfo chess_info = 1758;
         */
        chessInfo: InBattleChessInfo;
    } | {
        oneofKind: "irodoriChessInfo";
        /**
         * @generated from protobuf field: com.midnights.game.InBattleIrodoriChessInfo irodori_chess_info = 531;
         */
        irodoriChessInfo: InBattleIrodoriChessInfo;
    } | {
        oneofKind: "charAmusementInfo";
        /**
         * @generated from protobuf field: com.midnights.game.CharAmusementInfo char_amusement_info = 324;
         */
        charAmusementInfo: CharAmusementInfo;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message com.midnights.game.MultistagePlayInfoNotify
 */
export interface MultistagePlayInfoNotify {
    /**
     * @generated from protobuf field: optional com.midnights.game.MultistagePlayInfo info = 13;
     */
    info?: MultistagePlayInfo;
}
/**
 * @generated from protobuf enum com.midnights.game.MultistagePlayInfoNotify.CmdId
 */
export enum MultistagePlayInfoNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5372;
     */
    CMD_ID = 5372,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.MultistagePlayFinishStageReq
 */
export interface MultistagePlayFinishStageReq {
    /**
     * @generated from protobuf field: optional uint32 group_id = 12;
     */
    groupId?: number;
    /**
     * @generated from protobuf field: optional uint32 play_index = 15;
     */
    playIndex?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.MultistagePlayFinishStageReq.CmdId
 */
export enum MultistagePlayFinishStageReq_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5398;
     */
    CMD_ID = 5398,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.InBattleMechanicusExcapeMonsterNotify
 */
export interface InBattleMechanicusExcapeMonsterNotify {
    /**
     * @generated from protobuf field: optional uint32 excaped_monster_num = 4;
     */
    excapedMonsterNum?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.InBattleMechanicusExcapeMonsterNotify.CmdId
 */
export enum InBattleMechanicusExcapeMonsterNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5307;
     */
    CMD_ID = 5307,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.InBattleMechanicusLeftMonsterNotify
 */
export interface InBattleMechanicusLeftMonsterNotify {
    /**
     * @generated from protobuf field: optional uint32 left_monster = 14;
     */
    leftMonster?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.InBattleMechanicusLeftMonsterNotify.CmdId
 */
export enum InBattleMechanicusLeftMonsterNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5321;
     */
    CMD_ID = 5321,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.InBattleMechanicusBuildingPointsNotify
 */
export interface InBattleMechanicusBuildingPointsNotify {
    /**
     * @generated from protobuf field: map<uint32, uint32> player_building_points_map = 4;
     */
    playerBuildingPointsMap: {
        [key: number]: number;
    };
}
/**
 * @generated from protobuf enum com.midnights.game.InBattleMechanicusBuildingPointsNotify.CmdId
 */
export enum InBattleMechanicusBuildingPointsNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5303;
     */
    CMD_ID = 5303,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.InBattleMechanicusPickCardReq
 */
export interface InBattleMechanicusPickCardReq {
    /**
     * @generated from protobuf field: optional uint32 group_id = 11;
     */
    groupId?: number;
    /**
     * @generated from protobuf field: optional uint32 play_index = 7;
     */
    playIndex?: number;
    /**
     * @generated from protobuf field: optional uint32 card_id = 1;
     */
    cardId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.InBattleMechanicusPickCardReq.CmdId
 */
export enum InBattleMechanicusPickCardReq_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5390;
     */
    CMD_ID = 5390,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.InBattleMechanicusPickCardRsp
 */
export interface InBattleMechanicusPickCardRsp {
    /**
     * @generated from protobuf field: optional int32 retcode = 11;
     */
    retcode?: number;
    /**
     * @generated from protobuf field: optional uint32 card_id = 2;
     */
    cardId?: number;
    /**
     * @generated from protobuf field: optional uint32 play_index = 4;
     */
    playIndex?: number;
    /**
     * @generated from protobuf field: optional uint32 group_id = 9;
     */
    groupId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.InBattleMechanicusPickCardRsp.CmdId
 */
export enum InBattleMechanicusPickCardRsp_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5373;
     */
    CMD_ID = 5373,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.InBattleMechanicusPickCardNotify
 */
export interface InBattleMechanicusPickCardNotify {
    /**
     * @generated from protobuf field: optional uint32 player_uid = 6;
     */
    playerUid?: number;
    /**
     * @generated from protobuf field: optional uint32 group_id = 7;
     */
    groupId?: number;
    /**
     * @generated from protobuf field: optional uint32 play_index = 8;
     */
    playIndex?: number;
    /**
     * @generated from protobuf field: optional uint32 card_id = 10;
     */
    cardId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.InBattleMechanicusPickCardNotify.CmdId
 */
export enum InBattleMechanicusPickCardNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5399;
     */
    CMD_ID = 5399,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.InBattleMechanicusConfirmCardReq
 */
export interface InBattleMechanicusConfirmCardReq {
    /**
     * @generated from protobuf field: optional uint32 play_index = 6;
     */
    playIndex?: number;
    /**
     * @generated from protobuf field: optional uint32 card_id = 1;
     */
    cardId?: number;
    /**
     * @generated from protobuf field: optional uint32 group_id = 3;
     */
    groupId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.InBattleMechanicusConfirmCardReq.CmdId
 */
export enum InBattleMechanicusConfirmCardReq_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5331;
     */
    CMD_ID = 5331,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.InBattleMechanicusConfirmCardRsp
 */
export interface InBattleMechanicusConfirmCardRsp {
    /**
     * @generated from protobuf field: optional uint32 play_index = 2;
     */
    playIndex?: number;
    /**
     * @generated from protobuf field: optional uint32 card_id = 14;
     */
    cardId?: number;
    /**
     * @generated from protobuf field: optional int32 retcode = 11;
     */
    retcode?: number;
    /**
     * @generated from protobuf field: optional uint32 group_id = 6;
     */
    groupId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.InBattleMechanicusConfirmCardRsp.CmdId
 */
export enum InBattleMechanicusConfirmCardRsp_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5375;
     */
    CMD_ID = 5375,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.InBattleMechanicusConfirmCardNotify
 */
export interface InBattleMechanicusConfirmCardNotify {
    /**
     * @generated from protobuf field: optional uint32 play_index = 11;
     */
    playIndex?: number;
    /**
     * @generated from protobuf field: optional uint32 card_id = 13;
     */
    cardId?: number;
    /**
     * @generated from protobuf field: optional uint32 group_id = 10;
     */
    groupId?: number;
    /**
     * @generated from protobuf field: optional uint32 player_uid = 2;
     */
    playerUid?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.InBattleMechanicusConfirmCardNotify.CmdId
 */
export enum InBattleMechanicusConfirmCardNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5348;
     */
    CMD_ID = 5348,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.InBattleMechanicusCardResultNotify
 */
export interface InBattleMechanicusCardResultNotify {
    /**
     * @generated from protobuf field: optional uint32 wait_seconds = 6;
     */
    waitSeconds?: number;
    /**
     * @generated from protobuf field: optional uint32 group_id = 2;
     */
    groupId?: number;
    /**
     * @generated from protobuf field: repeated com.midnights.game.InBattleMechanicusCardInfo card_list = 9;
     */
    cardList: InBattleMechanicusCardInfo[];
    /**
     * @generated from protobuf field: optional uint64 wait_begin_time_us = 7;
     */
    waitBeginTimeUs?: bigint;
    /**
     * @generated from protobuf field: map<uint32, uint32> player_confirmed_card_map = 12;
     */
    playerConfirmedCardMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: optional uint32 play_index = 8;
     */
    playIndex?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.InBattleMechanicusCardResultNotify.CmdId
 */
export enum InBattleMechanicusCardResultNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5397;
     */
    CMD_ID = 5397,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.MultistagePlayFinishStageRsp
 */
export interface MultistagePlayFinishStageRsp {
    /**
     * @generated from protobuf field: optional int32 retcode = 11;
     */
    retcode?: number;
    /**
     * @generated from protobuf field: optional uint32 group_id = 12;
     */
    groupId?: number;
    /**
     * @generated from protobuf field: optional uint32 play_index = 6;
     */
    playIndex?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.MultistagePlayFinishStageRsp.CmdId
 */
export enum MultistagePlayFinishStageRsp_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5381;
     */
    CMD_ID = 5381,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.MultistageSettleWatcherInfo
 */
export interface MultistageSettleWatcherInfo {
    /**
     * @generated from protobuf field: optional uint32 total_progress = 13;
     */
    totalProgress?: number;
    /**
     * @generated from protobuf field: optional uint32 cur_progress = 5;
     */
    curProgress?: number;
    /**
     * @generated from protobuf field: optional uint32 watcher_id = 7;
     */
    watcherId?: number;
    /**
     * @generated from protobuf field: optional bool is_inverse = 12;
     */
    isInverse?: boolean;
}
/**
 * @generated from protobuf message com.midnights.game.InBattleMechanicusSettleNotify
 */
export interface InBattleMechanicusSettleNotify {
    /**
     * @generated from protobuf field: optional uint32 group_id = 15;
     */
    groupId?: number;
    /**
     * @generated from protobuf field: optional uint64 scene_time_ms = 11;
     */
    sceneTimeMs?: bigint;
    /**
     * @generated from protobuf field: optional uint32 difficulty_percentage = 6;
     */
    difficultyPercentage?: number;
    /**
     * @generated from protobuf field: optional uint32 total_token = 7;
     */
    totalToken?: number;
    /**
     * @generated from protobuf field: repeated com.midnights.game.MultistageSettleWatcherInfo watcher_list = 3;
     */
    watcherList: MultistageSettleWatcherInfo[];
    /**
     * @generated from protobuf field: optional uint32 real_token = 13;
     */
    realToken?: number;
    /**
     * @generated from protobuf field: optional bool is_success = 2;
     */
    isSuccess?: boolean;
    /**
     * @generated from protobuf field: optional uint32 play_index = 14;
     */
    playIndex?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.InBattleMechanicusSettleNotify.CmdId
 */
export enum InBattleMechanicusSettleNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5305;
     */
    CMD_ID = 5305,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.InBattleMechanicusSettleInfo
 */
export interface InBattleMechanicusSettleInfo {
    /**
     * @generated from protobuf field: optional uint64 scene_time_ms = 15;
     */
    sceneTimeMs?: bigint;
    /**
     * @generated from protobuf field: optional uint32 total_token = 4;
     */
    totalToken?: number;
    /**
     * @generated from protobuf field: optional uint32 real_token = 8;
     */
    realToken?: number;
    /**
     * @generated from protobuf field: repeated com.midnights.game.MultistageSettleWatcherInfo watcher_list = 7;
     */
    watcherList: MultistageSettleWatcherInfo[];
    /**
     * @generated from protobuf field: optional bool is_success = 6;
     */
    isSuccess?: boolean;
    /**
     * @generated from protobuf field: optional uint32 play_index = 3;
     */
    playIndex?: number;
    /**
     * @generated from protobuf field: optional uint32 difficulty_percentage = 10;
     */
    difficultyPercentage?: number;
    /**
     * @generated from protobuf field: optional uint32 group_id = 13;
     */
    groupId?: number;
}
/**
 * @generated from protobuf message com.midnights.game.MultistagePlaySettleNotify
 */
export interface MultistagePlaySettleNotify {
    /**
     * @generated from protobuf field: optional uint32 play_index = 14;
     */
    playIndex?: number;
    /**
     * @generated from protobuf field: optional uint32 group_id = 4;
     */
    groupId?: number;
    /**
     * @generated from protobuf oneof: detail
     */
    detail: {
        oneofKind: "mechanicusSettleInfo";
        /**
         * @generated from protobuf field: com.midnights.game.InBattleMechanicusSettleInfo mechanicus_settle_info = 1402;
         */
        mechanicusSettleInfo: InBattleMechanicusSettleInfo;
    } | {
        oneofKind: "chessSettleInfo";
        /**
         * @generated from protobuf field: com.midnights.game.InBattleChessSettleInfo chess_settle_info = 1283;
         */
        chessSettleInfo: InBattleChessSettleInfo;
    } | {
        oneofKind: "irodoriChessSettleInfo";
        /**
         * @generated from protobuf field: com.midnights.game.InBattleIrodoriChessSettleInfo irodori_chess_settle_info = 612;
         */
        irodoriChessSettleInfo: InBattleIrodoriChessSettleInfo;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf enum com.midnights.game.MultistagePlaySettleNotify.CmdId
 */
export enum MultistagePlaySettleNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5313;
     */
    CMD_ID = 5313,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.MultistagePlayStageEndNotify
 */
export interface MultistagePlayStageEndNotify {
    /**
     * @generated from protobuf field: optional uint32 group_id = 15;
     */
    groupId?: number;
    /**
     * @generated from protobuf field: optional uint32 play_index = 9;
     */
    playIndex?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.MultistagePlayStageEndNotify.CmdId
 */
export enum MultistagePlayStageEndNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5379;
     */
    CMD_ID = 5379,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.MultistagePlayEndNotify
 */
export interface MultistagePlayEndNotify {
    /**
     * @generated from protobuf field: optional uint32 group_id = 5;
     */
    groupId?: number;
    /**
     * @generated from protobuf field: optional uint32 play_index = 13;
     */
    playIndex?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.MultistagePlayEndNotify.CmdId
 */
export enum MultistagePlayEndNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5355;
     */
    CMD_ID = 5355,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.FleurFairBuffEnergyNotify
 */
export interface FleurFairBuffEnergyNotify {
    /**
     * @generated from protobuf field: optional uint32 energy = 4;
     */
    energy?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.FleurFairBuffEnergyNotify.CmdId
 */
export enum FleurFairBuffEnergyNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5324;
     */
    CMD_ID = 5324,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.FleurFairGallerySettleInfo
 */
export interface FleurFairGallerySettleInfo {
    /**
     * @generated from protobuf field: optional uint32 energy = 2;
     */
    energy?: number;
    /**
     * @generated from protobuf field: optional uint32 gallery_stage_index = 11;
     */
    galleryStageIndex?: number;
    /**
     * @generated from protobuf field: map<uint32, int32> energy_stat_map = 6;
     */
    energyStatMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: optional uint32 gallery_stage_count = 9;
     */
    galleryStageCount?: number;
    /**
     * @generated from protobuf field: optional bool is_success = 1;
     */
    isSuccess?: boolean;
}
/**
 * @generated from protobuf message com.midnights.game.FleurFairPlayerStatInfo
 */
export interface FleurFairPlayerStatInfo {
    /**
     * @generated from protobuf field: optional string online_id = 11;
     */
    onlineId?: string;
    /**
     * @generated from protobuf field: optional uint32 uid = 8;
     */
    uid?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.ProfilePicture profile_picture = 1;
     */
    profilePicture?: ProfilePicture;
    /**
     * @generated from protobuf field: optional uint32 stat_id = 3;
     */
    statId?: number;
    /**
     * @generated from protobuf field: optional uint32 head_image = 6;
     */
    headImage?: number;
    /**
     * @generated from protobuf field: optional string nick_name = 15;
     */
    nickName?: string;
    /**
     * @generated from protobuf field: optional int32 param = 5;
     */
    param?: number;
}
/**
 * @generated from protobuf message com.midnights.game.FleurFairBossSettleInfo
 */
export interface FleurFairBossSettleInfo {
    /**
     * @generated from protobuf field: optional uint32 reward_token_num = 15;
     */
    rewardTokenNum?: number;
    /**
     * @generated from protobuf field: repeated com.midnights.game.FleurFairPlayerStatInfo stat_info_list = 1;
     */
    statInfoList: FleurFairPlayerStatInfo[];
    /**
     * @generated from protobuf field: optional bool is_success = 10;
     */
    isSuccess?: boolean;
    /**
     * @generated from protobuf field: optional uint32 energy = 12;
     */
    energy?: number;
    /**
     * @generated from protobuf field: optional uint32 cost_time = 8;
     */
    costTime?: number;
}
/**
 * @generated from protobuf message com.midnights.game.FleurFairStageSettleNotify
 */
export interface FleurFairStageSettleNotify {
    /**
     * @generated from protobuf field: optional uint32 stage_type = 10;
     */
    stageType?: number;
    /**
     * @generated from protobuf oneof: detail
     */
    detail: {
        oneofKind: "gallerySettleInfo";
        /**
         * @generated from protobuf field: com.midnights.game.FleurFairGallerySettleInfo gallery_settle_info = 13;
         */
        gallerySettleInfo: FleurFairGallerySettleInfo;
    } | {
        oneofKind: "bossSettleInfo";
        /**
         * @generated from protobuf field: com.midnights.game.FleurFairBossSettleInfo boss_settle_info = 14;
         */
        bossSettleInfo: FleurFairBossSettleInfo;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf enum com.midnights.game.FleurFairStageSettleNotify.CmdId
 */
export enum FleurFairStageSettleNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5356;
     */
    CMD_ID = 5356,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.FleurFairFinishGalleryStageNotify
 */
export interface FleurFairFinishGalleryStageNotify {
}
/**
 * @generated from protobuf enum com.midnights.game.FleurFairFinishGalleryStageNotify.CmdId
 */
export enum FleurFairFinishGalleryStageNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5342;
     */
    CMD_ID = 5342,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.HideAndSeekPlayerBattleInfo
 */
export interface HideAndSeekPlayerBattleInfo {
    /**
     * @generated from protobuf field: optional uint32 costume_id = 3;
     */
    costumeId?: number;
    /**
     * @generated from protobuf field: repeated uint32 skill_list = 15;
     */
    skillList: number[];
    /**
     * @generated from protobuf field: optional bool is_ready = 12;
     */
    isReady?: boolean;
    /**
     * @generated from protobuf field: optional uint32 avatar_id = 6;
     */
    avatarId?: number;
}
/**
 * @generated from protobuf message com.midnights.game.HideAndSeekStageInfo
 */
export interface HideAndSeekStageInfo {
    /**
     * @generated from protobuf field: optional uint32 map_id = 8;
     */
    mapId?: number;
    /**
     * @generated from protobuf field: optional bool is_record_score = 3;
     */
    isRecordScore?: boolean;
    /**
     * @generated from protobuf field: optional com.midnights.game.HideAndSeekStageType stage_type = 7;
     */
    stageType?: HideAndSeekStageType;
    /**
     * @generated from protobuf field: map<uint32, com.midnights.game.HideAndSeekPlayerBattleInfo> battle_info_map = 2;
     */
    battleInfoMap: {
        [key: number]: HideAndSeekPlayerBattleInfo;
    };
    /**
     * @generated from protobuf field: repeated uint32 hider_uid_list = 1;
     */
    hiderUidList: number[];
    /**
     * @generated from protobuf field: optional uint32 hunter_uid = 10;
     */
    hunterUid?: number;
}
/**
 * @generated from protobuf message com.midnights.game.HideAndSeekSelectAvatarReq
 */
export interface HideAndSeekSelectAvatarReq {
    /**
     * @generated from protobuf field: optional uint32 avatar_id = 8;
     */
    avatarId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.HideAndSeekSelectAvatarReq.CmdId
 */
export enum HideAndSeekSelectAvatarReq_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5330;
     */
    CMD_ID = 5330,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.HideAndSeekSelectAvatarRsp
 */
export interface HideAndSeekSelectAvatarRsp {
    /**
     * @generated from protobuf field: optional int32 retcode = 2;
     */
    retcode?: number;
    /**
     * @generated from protobuf field: optional uint32 avatar_id = 3;
     */
    avatarId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.HideAndSeekSelectAvatarRsp.CmdId
 */
export enum HideAndSeekSelectAvatarRsp_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5367;
     */
    CMD_ID = 5367,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.HideAndSeekSetReadyReq
 */
export interface HideAndSeekSetReadyReq {
}
/**
 * @generated from protobuf enum com.midnights.game.HideAndSeekSetReadyReq.CmdId
 */
export enum HideAndSeekSetReadyReq_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5358;
     */
    CMD_ID = 5358,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.HideAndSeekSetReadyRsp
 */
export interface HideAndSeekSetReadyRsp {
    /**
     * @generated from protobuf field: optional int32 retcode = 11;
     */
    retcode?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.HideAndSeekSetReadyRsp.CmdId
 */
export enum HideAndSeekSetReadyRsp_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5370;
     */
    CMD_ID = 5370,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.HideAndSeekSettleInfo
 */
export interface HideAndSeekSettleInfo {
    /**
     * @generated from protobuf field: optional uint32 uid = 2;
     */
    uid?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.ProfilePicture profile_picture = 1;
     */
    profilePicture?: ProfilePicture;
    /**
     * @generated from protobuf field: repeated com.midnights.game.ExhibitionDisplayInfo card_list = 8;
     */
    cardList: ExhibitionDisplayInfo[];
    /**
     * @generated from protobuf field: optional string nickname = 3;
     */
    nickname?: string;
    /**
     * @generated from protobuf field: optional uint32 head_image = 4;
     */
    headImage?: number;
    /**
     * @generated from protobuf field: optional string online_id = 10;
     */
    onlineId?: string;
}
/**
 * @generated from protobuf message com.midnights.game.HideAndSeekSettleNotify
 */
export interface HideAndSeekSettleNotify {
    /**
     * @generated from protobuf field: optional uint32 cost_time = 2;
     */
    costTime?: number;
    /**
     * @generated from protobuf field: repeated com.midnights.game.HideAndSeekSettleInfo settle_info_list = 8;
     */
    settleInfoList: HideAndSeekSettleInfo[];
    /**
     * @generated from protobuf field: repeated uint32 winner_list = 15;
     */
    winnerList: number[];
    /**
     * @generated from protobuf field: optional com.midnights.game.HideAndSeekSettleNotify.SettleReason reason = 4;
     */
    reason?: HideAndSeekSettleNotify_SettleReason;
    /**
     * @generated from protobuf field: optional uint32 play_index = 13;
     */
    playIndex?: number;
    /**
     * @generated from protobuf field: optional bool is_record_score = 6;
     */
    isRecordScore?: boolean;
    /**
     * @generated from protobuf field: repeated com.midnights.game.ExhibitionDisplayInfo score_list = 9;
     */
    scoreList: ExhibitionDisplayInfo[];
    /**
     * @generated from protobuf field: optional uint32 stage_type = 14;
     */
    stageType?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.HideAndSeekSettleNotify.SettleReason
 */
export enum HideAndSeekSettleNotify_SettleReason {
    /**
     * @generated from protobuf enum value: SETTLE_REASON_TIME_OUT = 0;
     */
    SETTLE_REASON_TIME_OUT = 0,
    /**
     * @generated from protobuf enum value: SETTLE_PLAY_END = 1;
     */
    SETTLE_PLAY_END = 1,
    /**
     * @generated from protobuf enum value: SETTLE_PLAYER_QUIT = 2;
     */
    SETTLE_PLAYER_QUIT = 2
}
/**
 * @generated from protobuf enum com.midnights.game.HideAndSeekSettleNotify.CmdId
 */
export enum HideAndSeekSettleNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5317;
     */
    CMD_ID = 5317,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.HideAndSeekPlayerReadyNotify
 */
export interface HideAndSeekPlayerReadyNotify {
    /**
     * @generated from protobuf field: repeated uint32 uid_list = 5;
     */
    uidList: number[];
}
/**
 * @generated from protobuf enum com.midnights.game.HideAndSeekPlayerReadyNotify.CmdId
 */
export enum HideAndSeekPlayerReadyNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5302;
     */
    CMD_ID = 5302,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.HideAndSeekPlayerSetAvatarNotify
 */
export interface HideAndSeekPlayerSetAvatarNotify {
    /**
     * @generated from protobuf field: optional uint32 avatar_id = 2;
     */
    avatarId?: number;
    /**
     * @generated from protobuf field: optional uint32 costume_id = 13;
     */
    costumeId?: number;
    /**
     * @generated from protobuf field: optional uint32 uid = 5;
     */
    uid?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.HideAndSeekPlayerSetAvatarNotify.CmdId
 */
export enum HideAndSeekPlayerSetAvatarNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5319;
     */
    CMD_ID = 5319,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.ChessCardInfo
 */
export interface ChessCardInfo {
    /**
     * @generated from protobuf field: optional uint32 effect_stack = 12;
     */
    effectStack?: number;
    /**
     * @generated from protobuf field: optional uint32 card_id = 11;
     */
    cardId?: number;
}
/**
 * @generated from protobuf message com.midnights.game.InBattleChessInfo
 */
export interface InBattleChessInfo {
    /**
     * @generated from protobuf field: repeated uint32 ban_card_tag_list = 2;
     */
    banCardTagList: number[];
    /**
     * @generated from protobuf field: optional uint32 round = 4;
     */
    round?: number;
    /**
     * @generated from protobuf field: repeated com.midnights.game.ChessCardInfo selected_card_info_list = 9;
     */
    selectedCardInfoList: ChessCardInfo[];
    /**
     * @generated from protobuf field: optional com.midnights.game.ChessMysteryInfo mystery_info = 1;
     */
    mysteryInfo?: ChessMysteryInfo;
    /**
     * @generated from protobuf field: map<uint32, com.midnights.game.ChessPlayerInfo> player_info_map = 8;
     */
    playerInfoMap: {
        [key: number]: ChessPlayerInfo;
    };
    /**
     * @generated from protobuf field: optional uint32 max_escapable_monsters = 6;
     */
    maxEscapableMonsters?: number;
    /**
     * @generated from protobuf field: optional uint32 excaped_monsters = 12;
     */
    excapedMonsters?: number;
    /**
     * @generated from protobuf field: optional uint32 total_round = 14;
     */
    totalRound?: number;
    /**
     * @generated from protobuf field: optional uint32 left_monsters = 15;
     */
    leftMonsters?: number;
}
/**
 * @generated from protobuf message com.midnights.game.InBattleChessSettleInfo
 */
export interface InBattleChessSettleInfo {
    /**
     * @generated from protobuf field: optional bool is_success = 7;
     */
    isSuccess?: boolean;
    /**
     * @generated from protobuf field: optional uint32 chess_exp = 11;
     */
    chessExp?: number;
    /**
     * @generated from protobuf field: optional uint32 chess_level = 13;
     */
    chessLevel?: number;
    /**
     * @generated from protobuf field: optional uint32 old_chess_level = 10;
     */
    oldChessLevel?: number;
    /**
     * @generated from protobuf field: repeated com.midnights.game.ExhibitionDisplayInfo score_list = 1;
     */
    scoreList: ExhibitionDisplayInfo[];
    /**
     * @generated from protobuf field: optional uint64 scene_time_ms = 14;
     */
    sceneTimeMs?: bigint;
    /**
     * @generated from protobuf field: optional uint32 old_chess_exp = 2;
     */
    oldChessExp?: number;
}
/**
 * @generated from protobuf message com.midnights.game.ChessPlayerInfo
 */
export interface ChessPlayerInfo {
    /**
     * @generated from protobuf field: optional uint32 uid = 5;
     */
    uid?: number;
    /**
     * @generated from protobuf field: optional uint32 free_refresh_limit = 10;
     */
    freeRefreshLimit?: number;
    /**
     * @generated from protobuf field: repeated com.midnights.game.ChessNormalCardInfo candidate_card_info_list = 3;
     */
    candidateCardInfoList: ChessNormalCardInfo[];
    /**
     * @generated from protobuf field: optional uint32 building_points = 12;
     */
    buildingPoints?: number;
    /**
     * @generated from protobuf field: optional uint32 candidate_index = 6;
     */
    candidateIndex?: number;
    /**
     * @generated from protobuf field: optional uint32 free_refresh_count = 13;
     */
    freeRefreshCount?: number;
    /**
     * @generated from protobuf field: optional uint32 refresh_cost = 7;
     */
    refreshCost?: number;
}
/**
 * @generated from protobuf message com.midnights.game.ChessMonsterInfo
 */
export interface ChessMonsterInfo {
    /**
     * @generated from protobuf field: optional uint32 monster_id = 12;
     */
    monsterId?: number;
    /**
     * @generated from protobuf field: optional uint32 level = 2;
     */
    level?: number;
    /**
     * @generated from protobuf field: repeated uint32 affix_list = 13;
     */
    affixList: number[];
}
/**
 * @generated from protobuf message com.midnights.game.ChessEntranceInfo
 */
export interface ChessEntranceInfo {
    /**
     * @generated from protobuf field: repeated com.midnights.game.ChessMonsterInfo monster_info_list = 14;
     */
    monsterInfoList: ChessMonsterInfo[];
    /**
     * @generated from protobuf field: optional uint32 entrance_index = 15;
     */
    entranceIndex?: number;
    /**
     * @generated from protobuf field: optional uint32 entrance_point_id = 8;
     */
    entrancePointId?: number;
}
/**
 * @generated from protobuf message com.midnights.game.ChessEntranceDetailInfo
 */
export interface ChessEntranceDetailInfo {
    /**
     * @generated from protobuf field: repeated com.midnights.game.ChessEntranceInfo info_list = 4;
     */
    infoList: ChessEntranceInfo[];
}
/**
 * @generated from protobuf message com.midnights.game.ChessMysteryInfo
 */
export interface ChessMysteryInfo {
    /**
     * @generated from protobuf field: map<uint32, uint32> entrance_point_map = 13;
     */
    entrancePointMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: repeated uint32 exit_point_id_list = 3;
     */
    exitPointIdList: number[];
    /**
     * @generated from protobuf field: map<uint32, com.midnights.game.ChessEntranceDetailInfo> detail_info_map = 5;
     */
    detailInfoMap: {
        [key: number]: ChessEntranceDetailInfo;
    };
}
/**
 * @generated from protobuf message com.midnights.game.ChessNormalCardInfo
 */
export interface ChessNormalCardInfo {
    /**
     * @generated from protobuf field: optional uint32 card_id = 2;
     */
    cardId?: number;
    /**
     * @generated from protobuf field: optional uint32 cost_points = 15;
     */
    costPoints?: number;
    /**
     * @generated from protobuf field: optional bool is_attach_curse = 6;
     */
    isAttachCurse?: boolean;
}
/**
 * @generated from protobuf message com.midnights.game.ChessPickCardReq
 */
export interface ChessPickCardReq {
    /**
     * @generated from protobuf field: optional uint32 card_id = 1;
     */
    cardId?: number;
    /**
     * @generated from protobuf field: optional uint32 card_index = 4;
     */
    cardIndex?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.ChessPickCardReq.CmdId
 */
export enum ChessPickCardReq_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5333;
     */
    CMD_ID = 5333,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.ChessPickCardRsp
 */
export interface ChessPickCardRsp {
    /**
     * @generated from protobuf field: optional uint32 card_index = 11;
     */
    cardIndex?: number;
    /**
     * @generated from protobuf field: optional uint32 card_id = 1;
     */
    cardId?: number;
    /**
     * @generated from protobuf field: optional int32 retcode = 4;
     */
    retcode?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.ChessPickCardRsp.CmdId
 */
export enum ChessPickCardRsp_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5384;
     */
    CMD_ID = 5384,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.ChessPickCardNotify
 */
export interface ChessPickCardNotify {
    /**
     * @generated from protobuf field: optional uint32 curse_card_id = 13;
     */
    curseCardId?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.ChessNormalCardInfo normal_card_info = 1;
     */
    normalCardInfo?: ChessNormalCardInfo;
}
/**
 * @generated from protobuf enum com.midnights.game.ChessPickCardNotify.CmdId
 */
export enum ChessPickCardNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5380;
     */
    CMD_ID = 5380,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.ChessManualRefreshCardsReq
 */
export interface ChessManualRefreshCardsReq {
}
/**
 * @generated from protobuf enum com.midnights.game.ChessManualRefreshCardsReq.CmdId
 */
export enum ChessManualRefreshCardsReq_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5389;
     */
    CMD_ID = 5389,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.ChessManualRefreshCardsRsp
 */
export interface ChessManualRefreshCardsRsp {
    /**
     * @generated from protobuf field: optional int32 retcode = 12;
     */
    retcode?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.ChessManualRefreshCardsRsp.CmdId
 */
export enum ChessManualRefreshCardsRsp_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5359;
     */
    CMD_ID = 5359,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.ChessPlayerInfoNotify
 */
export interface ChessPlayerInfoNotify {
    /**
     * @generated from protobuf field: optional com.midnights.game.ChessPlayerInfo player_info = 10;
     */
    playerInfo?: ChessPlayerInfo;
}
/**
 * @generated from protobuf enum com.midnights.game.ChessPlayerInfoNotify.CmdId
 */
export enum ChessPlayerInfoNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5332;
     */
    CMD_ID = 5332,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.ChessLeftMonstersNotify
 */
export interface ChessLeftMonstersNotify {
    /**
     * @generated from protobuf field: optional uint32 left_monsters = 6;
     */
    leftMonsters?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.ChessLeftMonstersNotify.CmdId
 */
export enum ChessLeftMonstersNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5360;
     */
    CMD_ID = 5360,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.ChessEscapedMonstersNotify
 */
export interface ChessEscapedMonstersNotify {
    /**
     * @generated from protobuf field: optional uint32 excaped_monsters = 14;
     */
    excapedMonsters?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.ChessEscapedMonstersNotify.CmdId
 */
export enum ChessEscapedMonstersNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5314;
     */
    CMD_ID = 5314,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.ChessSelectedCardsNotify
 */
export interface ChessSelectedCardsNotify {
    /**
     * @generated from protobuf field: repeated com.midnights.game.ChessCardInfo selected_card_info_list = 4;
     */
    selectedCardInfoList: ChessCardInfo[];
}
/**
 * @generated from protobuf enum com.midnights.game.ChessSelectedCardsNotify.CmdId
 */
export enum ChessSelectedCardsNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5392;
     */
    CMD_ID = 5392,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GlobalBuildingInfoNotify
 */
export interface GlobalBuildingInfoNotify {
    /**
     * @generated from protobuf field: optional uint32 current_num = 5;
     */
    currentNum?: number;
    /**
     * @generated from protobuf field: repeated com.midnights.game.BuildingInfo building_list = 3;
     */
    buildingList: BuildingInfo[];
    /**
     * @generated from protobuf field: optional uint32 max_num = 13;
     */
    maxNum?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GlobalBuildingInfoNotify.CmdId
 */
export enum GlobalBuildingInfoNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5320;
     */
    CMD_ID = 5320,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.InBattleIrodoriChessInfo
 */
export interface InBattleIrodoriChessInfo {
    /**
     * @generated from protobuf field: optional com.midnights.game.IrodoriChessMysteryInfo mystery_info = 3;
     */
    mysteryInfo?: IrodoriChessMysteryInfo;
    /**
     * @generated from protobuf field: optional uint32 left_monsters = 12;
     */
    leftMonsters?: number;
    /**
     * @generated from protobuf field: repeated uint32 selected_card_id_list = 13;
     */
    selectedCardIdList: number[];
    /**
     * @generated from protobuf field: optional uint32 building_points = 7;
     */
    buildingPoints?: number;
    /**
     * @generated from protobuf field: optional uint32 settle_score = 4;
     */
    settleScore?: number;
}
/**
 * @generated from protobuf message com.midnights.game.IrodoriChessMonsterInfo
 */
export interface IrodoriChessMonsterInfo {
    /**
     * @generated from protobuf field: optional uint32 grant_points = 6;
     */
    grantPoints?: number;
    /**
     * @generated from protobuf field: optional uint32 level = 13;
     */
    level?: number;
    /**
     * @generated from protobuf field: optional uint32 monster_id = 14;
     */
    monsterId?: number;
    /**
     * @generated from protobuf field: repeated uint32 affix_list = 11;
     */
    affixList: number[];
}
/**
 * @generated from protobuf message com.midnights.game.IrodoriChessEntranceInfo
 */
export interface IrodoriChessEntranceInfo {
    /**
     * @generated from protobuf field: repeated com.midnights.game.IrodoriChessMonsterInfo monster_info_list = 6;
     */
    monsterInfoList: IrodoriChessMonsterInfo[];
    /**
     * @generated from protobuf field: optional uint32 entrance_point_id = 4;
     */
    entrancePointId?: number;
}
/**
 * @generated from protobuf message com.midnights.game.IrodoriChessEntranceDetailInfo
 */
export interface IrodoriChessEntranceDetailInfo {
    /**
     * @generated from protobuf field: repeated com.midnights.game.IrodoriChessEntranceInfo info_list = 15;
     */
    infoList: IrodoriChessEntranceInfo[];
}
/**
 * @generated from protobuf message com.midnights.game.IrodoriChessMysteryInfo
 */
export interface IrodoriChessMysteryInfo {
    /**
     * @generated from protobuf field: optional com.midnights.game.IrodoriChessEntranceDetailInfo entrance_detail_info = 5;
     */
    entranceDetailInfo?: IrodoriChessEntranceDetailInfo;
    /**
     * @generated from protobuf field: repeated uint32 entrance_point_id_list = 2;
     */
    entrancePointIdList: number[];
    /**
     * @generated from protobuf field: repeated uint32 exit_point_id_list = 13;
     */
    exitPointIdList: number[];
}
/**
 * @generated from protobuf message com.midnights.game.InBattleIrodoriChessSettleInfo
 */
export interface InBattleIrodoriChessSettleInfo {
    /**
     * @generated from protobuf field: optional bool is_new_record = 5;
     */
    isNewRecord?: boolean;
    /**
     * @generated from protobuf field: optional bool is_activity_end = 2;
     */
    isActivityEnd?: boolean;
    /**
     * @generated from protobuf field: optional uint64 scene_time_ms = 1;
     */
    sceneTimeMs?: bigint;
    /**
     * @generated from protobuf field: optional uint32 settle_score = 3;
     */
    settleScore?: number;
    /**
     * @generated from protobuf field: optional bool is_perfect = 12;
     */
    isPerfect?: boolean;
    /**
     * @generated from protobuf field: optional uint32 kill_monster_num = 7;
     */
    killMonsterNum?: number;
}
/**
 * @generated from protobuf message com.midnights.game.IrodoriChessPlayerInfo
 */
export interface IrodoriChessPlayerInfo {
    /**
     * @generated from protobuf field: optional uint32 uid = 4;
     */
    uid?: number;
    /**
     * @generated from protobuf field: optional uint32 building_points = 9;
     */
    buildingPoints?: number;
    /**
     * @generated from protobuf field: optional uint32 settle_score = 3;
     */
    settleScore?: number;
}
/**
 * @generated from protobuf message com.midnights.game.IrodoriChessPlayerInfoNotify
 */
export interface IrodoriChessPlayerInfoNotify {
    /**
     * @generated from protobuf field: optional com.midnights.game.IrodoriChessPlayerInfo player_info = 6;
     */
    playerInfo?: IrodoriChessPlayerInfo;
}
/**
 * @generated from protobuf enum com.midnights.game.IrodoriChessPlayerInfoNotify.CmdId
 */
export enum IrodoriChessPlayerInfoNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5364;
     */
    CMD_ID = 5364,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.IrodoriChessLeftMonsterNotify
 */
export interface IrodoriChessLeftMonsterNotify {
    /**
     * @generated from protobuf field: optional uint32 left_monsters = 8;
     */
    leftMonsters?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.IrodoriChessLeftMonsterNotify.CmdId
 */
export enum IrodoriChessLeftMonsterNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 5338;
     */
    CMD_ID = 5338,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf enum com.midnights.game.MultistagePlayType
 */
export enum MultistagePlayType {
    /**
     * @generated from protobuf enum value: MULTISTAGE_PLAY_TYPE_NON = 0;
     */
    NON = 0,
    /**
     * @generated from protobuf enum value: MULTISTAGE_PLAY_TYPE_MECHANICUS = 1;
     */
    MECHANICUS = 1,
    /**
     * @generated from protobuf enum value: MULTISTAGE_PLAY_TYPE_FLEUR_FAIR = 2;
     */
    FLEUR_FAIR = 2,
    /**
     * @generated from protobuf enum value: MULTISTAGE_PLAY_TYPE_HIDE_AND_SEEK = 3;
     */
    HIDE_AND_SEEK = 3,
    /**
     * @generated from protobuf enum value: MULTISTAGE_PLAY_TYPE_BOUNCE_CONJURING = 4;
     */
    BOUNCE_CONJURING = 4,
    /**
     * @generated from protobuf enum value: MULTISTAGE_PLAY_TYPE_CHESS = 5;
     */
    CHESS = 5,
    /**
     * @generated from protobuf enum value: MULTISTAGE_PLAY_TYPE_IRODORI_CHESS = 6;
     */
    IRODORI_CHESS = 6,
    /**
     * @generated from protobuf enum value: MULTISTAGE_PLAY_TYPE_CHAR_AMUSEMENT = 7;
     */
    CHAR_AMUSEMENT = 7
}
/**
 * @generated from protobuf enum com.midnights.game.InBattleMechanicusStageType
 */
export enum InBattleMechanicusStageType {
    /**
     * @generated from protobuf enum value: IN_BATTLE_MECHANICUS_STAGE_NONE = 0;
     */
    IN_BATTLE_MECHANICUS_STAGE_NONE = 0,
    /**
     * @generated from protobuf enum value: IN_BATTLE_MECHANICUS_STAGE_BUILD = 1;
     */
    IN_BATTLE_MECHANICUS_STAGE_BUILD = 1,
    /**
     * @generated from protobuf enum value: IN_BATTLE_MECHANICUS_STAGE_CARD_FLIP = 2;
     */
    IN_BATTLE_MECHANICUS_STAGE_CARD_FLIP = 2,
    /**
     * @generated from protobuf enum value: IN_BATTLE_MECHANICUS_STAGE_KILL = 3;
     */
    IN_BATTLE_MECHANICUS_STAGE_KILL = 3
}
/**
 * @generated from protobuf enum com.midnights.game.InBattleMechanicusCardChallengeState
 */
export enum InBattleMechanicusCardChallengeState {
    /**
     * @generated from protobuf enum value: IN_BATTLE_MECHANICUS_CARD_CHALLENGE_NONE = 0;
     */
    IN_BATTLE_MECHANICUS_CARD_CHALLENGE_NONE = 0,
    /**
     * @generated from protobuf enum value: IN_BATTLE_MECHANICUS_CARD_CHALLENGE_ON_GOING = 1;
     */
    IN_BATTLE_MECHANICUS_CARD_CHALLENGE_ON_GOING = 1,
    /**
     * @generated from protobuf enum value: IN_BATTLE_MECHANICUS_CARD_CHALLENGE_FAIL = 2;
     */
    IN_BATTLE_MECHANICUS_CARD_CHALLENGE_FAIL = 2,
    /**
     * @generated from protobuf enum value: IN_BATTLE_MECHANICUS_CARD_CHALLENGE_SUCCESS = 3;
     */
    IN_BATTLE_MECHANICUS_CARD_CHALLENGE_SUCCESS = 3
}
/**
 * @generated from protobuf enum com.midnights.game.HideAndSeekStageType
 */
export enum HideAndSeekStageType {
    /**
     * @generated from protobuf enum value: HIDE_AND_SEEK_STAGE_PREPARE = 0;
     */
    HIDE_AND_SEEK_STAGE_PREPARE = 0,
    /**
     * @generated from protobuf enum value: HIDE_AND_SEEK_STAGE_PICK = 1;
     */
    HIDE_AND_SEEK_STAGE_PICK = 1,
    /**
     * @generated from protobuf enum value: HIDE_AND_SEEK_STAGE_GAME = 2;
     */
    HIDE_AND_SEEK_STAGE_GAME = 2,
    /**
     * @generated from protobuf enum value: HIDE_AND_SEEK_STAGE_HIDE = 3;
     */
    HIDE_AND_SEEK_STAGE_HIDE = 3,
    /**
     * @generated from protobuf enum value: HIDE_AND_SEEK_STAGE_SEEK = 4;
     */
    HIDE_AND_SEEK_STAGE_SEEK = 4,
    /**
     * @generated from protobuf enum value: HIDE_AND_SEEK_STAGE_SETTLE = 5;
     */
    HIDE_AND_SEEK_STAGE_SETTLE = 5
}
// @generated message type with reflection information, may provide speed optimized methods
class InBattleMechanicusBuildingInfo$Type extends MessageType<InBattleMechanicusBuildingInfo> {
    constructor() {
        super("com.midnights.game.InBattleMechanicusBuildingInfo", [
            { no: 8, name: "building_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "level", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "cost_points", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "refund_points", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<InBattleMechanicusBuildingInfo>): InBattleMechanicusBuildingInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InBattleMechanicusBuildingInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InBattleMechanicusBuildingInfo): InBattleMechanicusBuildingInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 building_id */ 8:
                    message.buildingId = reader.uint32();
                    break;
                case /* optional uint32 level */ 7:
                    message.level = reader.uint32();
                    break;
                case /* optional uint32 cost_points */ 2:
                    message.costPoints = reader.uint32();
                    break;
                case /* optional uint32 refund_points */ 11:
                    message.refundPoints = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InBattleMechanicusBuildingInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 building_id = 8; */
        if (message.buildingId !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.buildingId);
        /* optional uint32 level = 7; */
        if (message.level !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.level);
        /* optional uint32 cost_points = 2; */
        if (message.costPoints !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.costPoints);
        /* optional uint32 refund_points = 11; */
        if (message.refundPoints !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.refundPoints);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.InBattleMechanicusBuildingInfo
 */
export const InBattleMechanicusBuildingInfo = new InBattleMechanicusBuildingInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InBattleMechanicusPlayerInfo$Type extends MessageType<InBattleMechanicusPlayerInfo> {
    constructor() {
        super("com.midnights.game.InBattleMechanicusPlayerInfo", [
            { no: 5, name: "pick_card_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "uid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "building_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => InBattleMechanicusBuildingInfo },
            { no: 13, name: "is_card_confirmed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "building_points", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<InBattleMechanicusPlayerInfo>): InBattleMechanicusPlayerInfo {
        const message = { buildingList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InBattleMechanicusPlayerInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InBattleMechanicusPlayerInfo): InBattleMechanicusPlayerInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 pick_card_id */ 5:
                    message.pickCardId = reader.uint32();
                    break;
                case /* optional uint32 uid */ 14:
                    message.uid = reader.uint32();
                    break;
                case /* repeated com.midnights.game.InBattleMechanicusBuildingInfo building_list */ 4:
                    message.buildingList.push(InBattleMechanicusBuildingInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool is_card_confirmed */ 13:
                    message.isCardConfirmed = reader.bool();
                    break;
                case /* optional uint32 building_points */ 3:
                    message.buildingPoints = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InBattleMechanicusPlayerInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 pick_card_id = 5; */
        if (message.pickCardId !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.pickCardId);
        /* optional uint32 uid = 14; */
        if (message.uid !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.uid);
        /* repeated com.midnights.game.InBattleMechanicusBuildingInfo building_list = 4; */
        for (let i = 0; i < message.buildingList.length; i++)
            InBattleMechanicusBuildingInfo.internalBinaryWrite(message.buildingList[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional bool is_card_confirmed = 13; */
        if (message.isCardConfirmed !== undefined)
            writer.tag(13, WireType.Varint).bool(message.isCardConfirmed);
        /* optional uint32 building_points = 3; */
        if (message.buildingPoints !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.buildingPoints);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.InBattleMechanicusPlayerInfo
 */
export const InBattleMechanicusPlayerInfo = new InBattleMechanicusPlayerInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InBattleMechanicusMonsterInfo$Type extends MessageType<InBattleMechanicusMonsterInfo> {
    constructor() {
        super("com.midnights.game.InBattleMechanicusMonsterInfo", [
            { no: 1, name: "monster_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "level", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<InBattleMechanicusMonsterInfo>): InBattleMechanicusMonsterInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InBattleMechanicusMonsterInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InBattleMechanicusMonsterInfo): InBattleMechanicusMonsterInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 monster_id */ 1:
                    message.monsterId = reader.uint32();
                    break;
                case /* optional uint32 level */ 14:
                    message.level = reader.uint32();
                    break;
                case /* optional uint32 count */ 13:
                    message.count = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InBattleMechanicusMonsterInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 monster_id = 1; */
        if (message.monsterId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.monsterId);
        /* optional uint32 level = 14; */
        if (message.level !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.level);
        /* optional uint32 count = 13; */
        if (message.count !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.InBattleMechanicusMonsterInfo
 */
export const InBattleMechanicusMonsterInfo = new InBattleMechanicusMonsterInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InBattleMechanicusCardInfo$Type extends MessageType<InBattleMechanicusCardInfo> {
    constructor() {
        super("com.midnights.game.InBattleMechanicusCardInfo", [
            { no: 12, name: "rand_effect_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "end_round", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "challenge_state", kind: "enum", opt: true, T: () => ["com.midnights.game.InBattleMechanicusCardChallengeState", InBattleMechanicusCardChallengeState] },
            { no: 1, name: "cost_points", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "card_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "begin_round", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<InBattleMechanicusCardInfo>): InBattleMechanicusCardInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InBattleMechanicusCardInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InBattleMechanicusCardInfo): InBattleMechanicusCardInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 rand_effect_id */ 12:
                    message.randEffectId = reader.uint32();
                    break;
                case /* optional uint32 end_round */ 3:
                    message.endRound = reader.uint32();
                    break;
                case /* optional com.midnights.game.InBattleMechanicusCardChallengeState challenge_state */ 5:
                    message.challengeState = reader.int32();
                    break;
                case /* optional uint32 cost_points */ 1:
                    message.costPoints = reader.uint32();
                    break;
                case /* optional uint32 card_id */ 11:
                    message.cardId = reader.uint32();
                    break;
                case /* optional uint32 begin_round */ 8:
                    message.beginRound = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InBattleMechanicusCardInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 rand_effect_id = 12; */
        if (message.randEffectId !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.randEffectId);
        /* optional uint32 end_round = 3; */
        if (message.endRound !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.endRound);
        /* optional com.midnights.game.InBattleMechanicusCardChallengeState challenge_state = 5; */
        if (message.challengeState !== undefined)
            writer.tag(5, WireType.Varint).int32(message.challengeState);
        /* optional uint32 cost_points = 1; */
        if (message.costPoints !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.costPoints);
        /* optional uint32 card_id = 11; */
        if (message.cardId !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.cardId);
        /* optional uint32 begin_round = 8; */
        if (message.beginRound !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.beginRound);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.InBattleMechanicusCardInfo
 */
export const InBattleMechanicusCardInfo = new InBattleMechanicusCardInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InBattleMechanicusInfo$Type extends MessageType<InBattleMechanicusInfo> {
    constructor() {
        super("com.midnights.game.InBattleMechanicusInfo", [
            { no: 5, name: "left_monster", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "wait_seconds", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 410, name: "entrance_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 115, name: "exit_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "history_card_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => InBattleMechanicusCardInfo },
            { no: 10, name: "max_excape_monster_num", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "building_stage_duration", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "duration_ms", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "stage", kind: "enum", opt: true, T: () => ["com.midnights.game.InBattleMechanicusStageType", InBattleMechanicusStageType] },
            { no: 12, name: "total_round", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "monster_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => InBattleMechanicusMonsterInfo },
            { no: 6, name: "excaped_monster_num", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "round", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "pick_card_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => InBattleMechanicusCardInfo },
            { no: 7, name: "player_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => InBattleMechanicusPlayerInfo },
            { no: 1, name: "wait_begin_time_us", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "begin_time_ms", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<InBattleMechanicusInfo>): InBattleMechanicusInfo {
        const message = { entranceList: [], exitList: [], historyCardList: [], monsterList: [], pickCardList: [], playerList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InBattleMechanicusInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InBattleMechanicusInfo): InBattleMechanicusInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 left_monster */ 5:
                    message.leftMonster = reader.uint32();
                    break;
                case /* optional uint32 wait_seconds */ 13:
                    message.waitSeconds = reader.uint32();
                    break;
                case /* repeated uint32 entrance_list */ 410:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.entranceList.push(reader.uint32());
                    else
                        message.entranceList.push(reader.uint32());
                    break;
                case /* repeated uint32 exit_list */ 115:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.exitList.push(reader.uint32());
                    else
                        message.exitList.push(reader.uint32());
                    break;
                case /* repeated com.midnights.game.InBattleMechanicusCardInfo history_card_list */ 11:
                    message.historyCardList.push(InBattleMechanicusCardInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 max_excape_monster_num */ 10:
                    message.maxExcapeMonsterNum = reader.uint32();
                    break;
                case /* optional uint32 building_stage_duration */ 4:
                    message.buildingStageDuration = reader.uint32();
                    break;
                case /* optional uint64 duration_ms */ 8:
                    message.durationMs = reader.uint64().toBigInt();
                    break;
                case /* optional com.midnights.game.InBattleMechanicusStageType stage */ 9:
                    message.stage = reader.int32();
                    break;
                case /* optional uint32 total_round */ 12:
                    message.totalRound = reader.uint32();
                    break;
                case /* repeated com.midnights.game.InBattleMechanicusMonsterInfo monster_list */ 14:
                    message.monsterList.push(InBattleMechanicusMonsterInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 excaped_monster_num */ 6:
                    message.excapedMonsterNum = reader.uint32();
                    break;
                case /* optional uint32 round */ 3:
                    message.round = reader.uint32();
                    break;
                case /* repeated com.midnights.game.InBattleMechanicusCardInfo pick_card_list */ 15:
                    message.pickCardList.push(InBattleMechanicusCardInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated com.midnights.game.InBattleMechanicusPlayerInfo player_list */ 7:
                    message.playerList.push(InBattleMechanicusPlayerInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint64 wait_begin_time_us */ 1:
                    message.waitBeginTimeUs = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 begin_time_ms */ 2:
                    message.beginTimeMs = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InBattleMechanicusInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 left_monster = 5; */
        if (message.leftMonster !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.leftMonster);
        /* optional uint32 wait_seconds = 13; */
        if (message.waitSeconds !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.waitSeconds);
        /* repeated uint32 entrance_list = 410; */
        if (message.entranceList.length) {
            writer.tag(410, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.entranceList.length; i++)
                writer.uint32(message.entranceList[i]);
            writer.join();
        }
        /* repeated uint32 exit_list = 115; */
        if (message.exitList.length) {
            writer.tag(115, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.exitList.length; i++)
                writer.uint32(message.exitList[i]);
            writer.join();
        }
        /* repeated com.midnights.game.InBattleMechanicusCardInfo history_card_list = 11; */
        for (let i = 0; i < message.historyCardList.length; i++)
            InBattleMechanicusCardInfo.internalBinaryWrite(message.historyCardList[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 max_excape_monster_num = 10; */
        if (message.maxExcapeMonsterNum !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.maxExcapeMonsterNum);
        /* optional uint32 building_stage_duration = 4; */
        if (message.buildingStageDuration !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.buildingStageDuration);
        /* optional uint64 duration_ms = 8; */
        if (message.durationMs !== undefined)
            writer.tag(8, WireType.Varint).uint64(message.durationMs);
        /* optional com.midnights.game.InBattleMechanicusStageType stage = 9; */
        if (message.stage !== undefined)
            writer.tag(9, WireType.Varint).int32(message.stage);
        /* optional uint32 total_round = 12; */
        if (message.totalRound !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.totalRound);
        /* repeated com.midnights.game.InBattleMechanicusMonsterInfo monster_list = 14; */
        for (let i = 0; i < message.monsterList.length; i++)
            InBattleMechanicusMonsterInfo.internalBinaryWrite(message.monsterList[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 excaped_monster_num = 6; */
        if (message.excapedMonsterNum !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.excapedMonsterNum);
        /* optional uint32 round = 3; */
        if (message.round !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.round);
        /* repeated com.midnights.game.InBattleMechanicusCardInfo pick_card_list = 15; */
        for (let i = 0; i < message.pickCardList.length; i++)
            InBattleMechanicusCardInfo.internalBinaryWrite(message.pickCardList[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* repeated com.midnights.game.InBattleMechanicusPlayerInfo player_list = 7; */
        for (let i = 0; i < message.playerList.length; i++)
            InBattleMechanicusPlayerInfo.internalBinaryWrite(message.playerList[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* optional uint64 wait_begin_time_us = 1; */
        if (message.waitBeginTimeUs !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.waitBeginTimeUs);
        /* optional uint64 begin_time_ms = 2; */
        if (message.beginTimeMs !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.beginTimeMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.InBattleMechanicusInfo
 */
export const InBattleMechanicusInfo = new InBattleMechanicusInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InBattleFleurFairInfo$Type extends MessageType<InBattleFleurFairInfo> {
    constructor() {
        super("com.midnights.game.InBattleFleurFairInfo", [
            { no: 5, name: "gallery_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "gallery_stage_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "preview_stage_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "ability_group_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "preview_display_duration", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<InBattleFleurFairInfo>): InBattleFleurFairInfo {
        const message = { galleryIdList: [], abilityGroupIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InBattleFleurFairInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InBattleFleurFairInfo): InBattleFleurFairInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 gallery_id_list */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.galleryIdList.push(reader.uint32());
                    else
                        message.galleryIdList.push(reader.uint32());
                    break;
                case /* optional uint32 gallery_stage_index */ 6:
                    message.galleryStageIndex = reader.uint32();
                    break;
                case /* optional uint32 preview_stage_index */ 8:
                    message.previewStageIndex = reader.uint32();
                    break;
                case /* repeated uint32 ability_group_id_list */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.abilityGroupIdList.push(reader.uint32());
                    else
                        message.abilityGroupIdList.push(reader.uint32());
                    break;
                case /* optional uint32 preview_display_duration */ 12:
                    message.previewDisplayDuration = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InBattleFleurFairInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 gallery_id_list = 5; */
        if (message.galleryIdList.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.galleryIdList.length; i++)
                writer.uint32(message.galleryIdList[i]);
            writer.join();
        }
        /* optional uint32 gallery_stage_index = 6; */
        if (message.galleryStageIndex !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.galleryStageIndex);
        /* optional uint32 preview_stage_index = 8; */
        if (message.previewStageIndex !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.previewStageIndex);
        /* repeated uint32 ability_group_id_list = 2; */
        if (message.abilityGroupIdList.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.abilityGroupIdList.length; i++)
                writer.uint32(message.abilityGroupIdList[i]);
            writer.join();
        }
        /* optional uint32 preview_display_duration = 12; */
        if (message.previewDisplayDuration !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.previewDisplayDuration);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.InBattleFleurFairInfo
 */
export const InBattleFleurFairInfo = new InBattleFleurFairInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CharAmusementAvatarInfo$Type extends MessageType<CharAmusementAvatarInfo> {
    constructor() {
        super("com.midnights.game.CharAmusementAvatarInfo", [
            { no: 11, name: "uid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "punish_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "avatar_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CharAmusementAvatarInfo>): CharAmusementAvatarInfo {
        const message = { avatarIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CharAmusementAvatarInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CharAmusementAvatarInfo): CharAmusementAvatarInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 uid */ 11:
                    message.uid = reader.uint32();
                    break;
                case /* optional uint32 punish_time */ 7:
                    message.punishTime = reader.uint32();
                    break;
                case /* repeated uint32 avatar_id_list */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.avatarIdList.push(reader.uint32());
                    else
                        message.avatarIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CharAmusementAvatarInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 uid = 11; */
        if (message.uid !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.uid);
        /* optional uint32 punish_time = 7; */
        if (message.punishTime !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.punishTime);
        /* repeated uint32 avatar_id_list = 10; */
        if (message.avatarIdList.length) {
            writer.tag(10, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.avatarIdList.length; i++)
                writer.uint32(message.avatarIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.CharAmusementAvatarInfo
 */
export const CharAmusementAvatarInfo = new CharAmusementAvatarInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CharAmusementInfo$Type extends MessageType<CharAmusementInfo> {
    constructor() {
        super("com.midnights.game.CharAmusementInfo", [
            { no: 11, name: "total_cost_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "stage_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "level_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "preview_stage_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "avatar_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CharAmusementAvatarInfo }
        ]);
    }
    create(value?: PartialMessage<CharAmusementInfo>): CharAmusementInfo {
        const message = { avatarInfoList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CharAmusementInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CharAmusementInfo): CharAmusementInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 total_cost_time */ 11:
                    message.totalCostTime = reader.uint32();
                    break;
                case /* optional uint32 stage_id */ 2:
                    message.stageId = reader.uint32();
                    break;
                case /* optional uint32 level_id */ 10:
                    message.levelId = reader.uint32();
                    break;
                case /* optional uint32 preview_stage_index */ 4:
                    message.previewStageIndex = reader.uint32();
                    break;
                case /* repeated com.midnights.game.CharAmusementAvatarInfo avatar_info_list */ 5:
                    message.avatarInfoList.push(CharAmusementAvatarInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CharAmusementInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 total_cost_time = 11; */
        if (message.totalCostTime !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.totalCostTime);
        /* optional uint32 stage_id = 2; */
        if (message.stageId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.stageId);
        /* optional uint32 level_id = 10; */
        if (message.levelId !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.levelId);
        /* optional uint32 preview_stage_index = 4; */
        if (message.previewStageIndex !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.previewStageIndex);
        /* repeated com.midnights.game.CharAmusementAvatarInfo avatar_info_list = 5; */
        for (let i = 0; i < message.avatarInfoList.length; i++)
            CharAmusementAvatarInfo.internalBinaryWrite(message.avatarInfoList[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.CharAmusementInfo
 */
export const CharAmusementInfo = new CharAmusementInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MultistagePlayInfo$Type extends MessageType<MultistagePlayInfo> {
    constructor() {
        super("com.midnights.game.MultistagePlayInfo", [
            { no: 13, name: "play_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "play_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "stage_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "duration", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "group_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "begin_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "stage_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 1334, name: "mechanicus_info", kind: "message", oneof: "detail", T: () => InBattleMechanicusInfo },
            { no: 1064, name: "fleur_fair_info", kind: "message", oneof: "detail", T: () => InBattleFleurFairInfo },
            { no: 108, name: "hide_and_seek_info", kind: "message", oneof: "detail", T: () => HideAndSeekStageInfo },
            { no: 1758, name: "chess_info", kind: "message", oneof: "detail", T: () => InBattleChessInfo },
            { no: 531, name: "irodori_chess_info", kind: "message", oneof: "detail", T: () => InBattleIrodoriChessInfo },
            { no: 324, name: "char_amusement_info", kind: "message", oneof: "detail", T: () => CharAmusementInfo }
        ]);
    }
    create(value?: PartialMessage<MultistagePlayInfo>): MultistagePlayInfo {
        const message = { detail: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MultistagePlayInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MultistagePlayInfo): MultistagePlayInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 play_index */ 13:
                    message.playIndex = reader.uint32();
                    break;
                case /* optional uint32 play_type */ 11:
                    message.playType = reader.uint32();
                    break;
                case /* optional uint32 stage_type */ 10:
                    message.stageType = reader.uint32();
                    break;
                case /* optional uint32 duration */ 8:
                    message.duration = reader.uint32();
                    break;
                case /* optional uint32 group_id */ 12:
                    message.groupId = reader.uint32();
                    break;
                case /* optional uint32 begin_time */ 9:
                    message.beginTime = reader.uint32();
                    break;
                case /* optional uint32 stage_index */ 1:
                    message.stageIndex = reader.uint32();
                    break;
                case /* com.midnights.game.InBattleMechanicusInfo mechanicus_info */ 1334:
                    message.detail = {
                        oneofKind: "mechanicusInfo",
                        mechanicusInfo: InBattleMechanicusInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).mechanicusInfo)
                    };
                    break;
                case /* com.midnights.game.InBattleFleurFairInfo fleur_fair_info */ 1064:
                    message.detail = {
                        oneofKind: "fleurFairInfo",
                        fleurFairInfo: InBattleFleurFairInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).fleurFairInfo)
                    };
                    break;
                case /* com.midnights.game.HideAndSeekStageInfo hide_and_seek_info */ 108:
                    message.detail = {
                        oneofKind: "hideAndSeekInfo",
                        hideAndSeekInfo: HideAndSeekStageInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).hideAndSeekInfo)
                    };
                    break;
                case /* com.midnights.game.InBattleChessInfo chess_info */ 1758:
                    message.detail = {
                        oneofKind: "chessInfo",
                        chessInfo: InBattleChessInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).chessInfo)
                    };
                    break;
                case /* com.midnights.game.InBattleIrodoriChessInfo irodori_chess_info */ 531:
                    message.detail = {
                        oneofKind: "irodoriChessInfo",
                        irodoriChessInfo: InBattleIrodoriChessInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).irodoriChessInfo)
                    };
                    break;
                case /* com.midnights.game.CharAmusementInfo char_amusement_info */ 324:
                    message.detail = {
                        oneofKind: "charAmusementInfo",
                        charAmusementInfo: CharAmusementInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).charAmusementInfo)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MultistagePlayInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 play_index = 13; */
        if (message.playIndex !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.playIndex);
        /* optional uint32 play_type = 11; */
        if (message.playType !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.playType);
        /* optional uint32 stage_type = 10; */
        if (message.stageType !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.stageType);
        /* optional uint32 duration = 8; */
        if (message.duration !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.duration);
        /* optional uint32 group_id = 12; */
        if (message.groupId !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.groupId);
        /* optional uint32 begin_time = 9; */
        if (message.beginTime !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.beginTime);
        /* optional uint32 stage_index = 1; */
        if (message.stageIndex !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.stageIndex);
        /* com.midnights.game.InBattleMechanicusInfo mechanicus_info = 1334; */
        if (message.detail.oneofKind === "mechanicusInfo")
            InBattleMechanicusInfo.internalBinaryWrite(message.detail.mechanicusInfo, writer.tag(1334, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.InBattleFleurFairInfo fleur_fair_info = 1064; */
        if (message.detail.oneofKind === "fleurFairInfo")
            InBattleFleurFairInfo.internalBinaryWrite(message.detail.fleurFairInfo, writer.tag(1064, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.HideAndSeekStageInfo hide_and_seek_info = 108; */
        if (message.detail.oneofKind === "hideAndSeekInfo")
            HideAndSeekStageInfo.internalBinaryWrite(message.detail.hideAndSeekInfo, writer.tag(108, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.InBattleChessInfo chess_info = 1758; */
        if (message.detail.oneofKind === "chessInfo")
            InBattleChessInfo.internalBinaryWrite(message.detail.chessInfo, writer.tag(1758, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.InBattleIrodoriChessInfo irodori_chess_info = 531; */
        if (message.detail.oneofKind === "irodoriChessInfo")
            InBattleIrodoriChessInfo.internalBinaryWrite(message.detail.irodoriChessInfo, writer.tag(531, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.CharAmusementInfo char_amusement_info = 324; */
        if (message.detail.oneofKind === "charAmusementInfo")
            CharAmusementInfo.internalBinaryWrite(message.detail.charAmusementInfo, writer.tag(324, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.MultistagePlayInfo
 */
export const MultistagePlayInfo = new MultistagePlayInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MultistagePlayInfoNotify$Type extends MessageType<MultistagePlayInfoNotify> {
    constructor() {
        super("com.midnights.game.MultistagePlayInfoNotify", [
            { no: 13, name: "info", kind: "message", T: () => MultistagePlayInfo }
        ]);
    }
    create(value?: PartialMessage<MultistagePlayInfoNotify>): MultistagePlayInfoNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MultistagePlayInfoNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MultistagePlayInfoNotify): MultistagePlayInfoNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.MultistagePlayInfo info */ 13:
                    message.info = MultistagePlayInfo.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MultistagePlayInfoNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.MultistagePlayInfo info = 13; */
        if (message.info)
            MultistagePlayInfo.internalBinaryWrite(message.info, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.MultistagePlayInfoNotify
 */
export const MultistagePlayInfoNotify = new MultistagePlayInfoNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MultistagePlayFinishStageReq$Type extends MessageType<MultistagePlayFinishStageReq> {
    constructor() {
        super("com.midnights.game.MultistagePlayFinishStageReq", [
            { no: 12, name: "group_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "play_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<MultistagePlayFinishStageReq>): MultistagePlayFinishStageReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MultistagePlayFinishStageReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MultistagePlayFinishStageReq): MultistagePlayFinishStageReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 group_id */ 12:
                    message.groupId = reader.uint32();
                    break;
                case /* optional uint32 play_index */ 15:
                    message.playIndex = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MultistagePlayFinishStageReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 group_id = 12; */
        if (message.groupId !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.groupId);
        /* optional uint32 play_index = 15; */
        if (message.playIndex !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.playIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.MultistagePlayFinishStageReq
 */
export const MultistagePlayFinishStageReq = new MultistagePlayFinishStageReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InBattleMechanicusExcapeMonsterNotify$Type extends MessageType<InBattleMechanicusExcapeMonsterNotify> {
    constructor() {
        super("com.midnights.game.InBattleMechanicusExcapeMonsterNotify", [
            { no: 4, name: "excaped_monster_num", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<InBattleMechanicusExcapeMonsterNotify>): InBattleMechanicusExcapeMonsterNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InBattleMechanicusExcapeMonsterNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InBattleMechanicusExcapeMonsterNotify): InBattleMechanicusExcapeMonsterNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 excaped_monster_num */ 4:
                    message.excapedMonsterNum = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InBattleMechanicusExcapeMonsterNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 excaped_monster_num = 4; */
        if (message.excapedMonsterNum !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.excapedMonsterNum);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.InBattleMechanicusExcapeMonsterNotify
 */
export const InBattleMechanicusExcapeMonsterNotify = new InBattleMechanicusExcapeMonsterNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InBattleMechanicusLeftMonsterNotify$Type extends MessageType<InBattleMechanicusLeftMonsterNotify> {
    constructor() {
        super("com.midnights.game.InBattleMechanicusLeftMonsterNotify", [
            { no: 14, name: "left_monster", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<InBattleMechanicusLeftMonsterNotify>): InBattleMechanicusLeftMonsterNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InBattleMechanicusLeftMonsterNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InBattleMechanicusLeftMonsterNotify): InBattleMechanicusLeftMonsterNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 left_monster */ 14:
                    message.leftMonster = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InBattleMechanicusLeftMonsterNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 left_monster = 14; */
        if (message.leftMonster !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.leftMonster);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.InBattleMechanicusLeftMonsterNotify
 */
export const InBattleMechanicusLeftMonsterNotify = new InBattleMechanicusLeftMonsterNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InBattleMechanicusBuildingPointsNotify$Type extends MessageType<InBattleMechanicusBuildingPointsNotify> {
    constructor() {
        super("com.midnights.game.InBattleMechanicusBuildingPointsNotify", [
            { no: 4, name: "player_building_points_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } }
        ]);
    }
    create(value?: PartialMessage<InBattleMechanicusBuildingPointsNotify>): InBattleMechanicusBuildingPointsNotify {
        const message = { playerBuildingPointsMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InBattleMechanicusBuildingPointsNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InBattleMechanicusBuildingPointsNotify): InBattleMechanicusBuildingPointsNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, uint32> player_building_points_map */ 4:
                    this.binaryReadMap4(message.playerBuildingPointsMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: InBattleMechanicusBuildingPointsNotify["playerBuildingPointsMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof InBattleMechanicusBuildingPointsNotify["playerBuildingPointsMap"] | undefined, val: InBattleMechanicusBuildingPointsNotify["playerBuildingPointsMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field com.midnights.game.InBattleMechanicusBuildingPointsNotify.player_building_points_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: InBattleMechanicusBuildingPointsNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, uint32> player_building_points_map = 4; */
        for (let k of Object.keys(message.playerBuildingPointsMap))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.playerBuildingPointsMap[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.InBattleMechanicusBuildingPointsNotify
 */
export const InBattleMechanicusBuildingPointsNotify = new InBattleMechanicusBuildingPointsNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InBattleMechanicusPickCardReq$Type extends MessageType<InBattleMechanicusPickCardReq> {
    constructor() {
        super("com.midnights.game.InBattleMechanicusPickCardReq", [
            { no: 11, name: "group_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "play_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "card_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<InBattleMechanicusPickCardReq>): InBattleMechanicusPickCardReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InBattleMechanicusPickCardReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InBattleMechanicusPickCardReq): InBattleMechanicusPickCardReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 group_id */ 11:
                    message.groupId = reader.uint32();
                    break;
                case /* optional uint32 play_index */ 7:
                    message.playIndex = reader.uint32();
                    break;
                case /* optional uint32 card_id */ 1:
                    message.cardId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InBattleMechanicusPickCardReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 group_id = 11; */
        if (message.groupId !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.groupId);
        /* optional uint32 play_index = 7; */
        if (message.playIndex !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.playIndex);
        /* optional uint32 card_id = 1; */
        if (message.cardId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.cardId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.InBattleMechanicusPickCardReq
 */
export const InBattleMechanicusPickCardReq = new InBattleMechanicusPickCardReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InBattleMechanicusPickCardRsp$Type extends MessageType<InBattleMechanicusPickCardRsp> {
    constructor() {
        super("com.midnights.game.InBattleMechanicusPickCardRsp", [
            { no: 11, name: "retcode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "card_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "play_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "group_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<InBattleMechanicusPickCardRsp>): InBattleMechanicusPickCardRsp {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InBattleMechanicusPickCardRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InBattleMechanicusPickCardRsp): InBattleMechanicusPickCardRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 retcode */ 11:
                    message.retcode = reader.int32();
                    break;
                case /* optional uint32 card_id */ 2:
                    message.cardId = reader.uint32();
                    break;
                case /* optional uint32 play_index */ 4:
                    message.playIndex = reader.uint32();
                    break;
                case /* optional uint32 group_id */ 9:
                    message.groupId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InBattleMechanicusPickCardRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 retcode = 11; */
        if (message.retcode !== undefined)
            writer.tag(11, WireType.Varint).int32(message.retcode);
        /* optional uint32 card_id = 2; */
        if (message.cardId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.cardId);
        /* optional uint32 play_index = 4; */
        if (message.playIndex !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.playIndex);
        /* optional uint32 group_id = 9; */
        if (message.groupId !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.groupId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.InBattleMechanicusPickCardRsp
 */
export const InBattleMechanicusPickCardRsp = new InBattleMechanicusPickCardRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InBattleMechanicusPickCardNotify$Type extends MessageType<InBattleMechanicusPickCardNotify> {
    constructor() {
        super("com.midnights.game.InBattleMechanicusPickCardNotify", [
            { no: 6, name: "player_uid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "group_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "play_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "card_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<InBattleMechanicusPickCardNotify>): InBattleMechanicusPickCardNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InBattleMechanicusPickCardNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InBattleMechanicusPickCardNotify): InBattleMechanicusPickCardNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 player_uid */ 6:
                    message.playerUid = reader.uint32();
                    break;
                case /* optional uint32 group_id */ 7:
                    message.groupId = reader.uint32();
                    break;
                case /* optional uint32 play_index */ 8:
                    message.playIndex = reader.uint32();
                    break;
                case /* optional uint32 card_id */ 10:
                    message.cardId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InBattleMechanicusPickCardNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 player_uid = 6; */
        if (message.playerUid !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.playerUid);
        /* optional uint32 group_id = 7; */
        if (message.groupId !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.groupId);
        /* optional uint32 play_index = 8; */
        if (message.playIndex !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.playIndex);
        /* optional uint32 card_id = 10; */
        if (message.cardId !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.cardId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.InBattleMechanicusPickCardNotify
 */
export const InBattleMechanicusPickCardNotify = new InBattleMechanicusPickCardNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InBattleMechanicusConfirmCardReq$Type extends MessageType<InBattleMechanicusConfirmCardReq> {
    constructor() {
        super("com.midnights.game.InBattleMechanicusConfirmCardReq", [
            { no: 6, name: "play_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "card_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "group_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<InBattleMechanicusConfirmCardReq>): InBattleMechanicusConfirmCardReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InBattleMechanicusConfirmCardReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InBattleMechanicusConfirmCardReq): InBattleMechanicusConfirmCardReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 play_index */ 6:
                    message.playIndex = reader.uint32();
                    break;
                case /* optional uint32 card_id */ 1:
                    message.cardId = reader.uint32();
                    break;
                case /* optional uint32 group_id */ 3:
                    message.groupId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InBattleMechanicusConfirmCardReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 play_index = 6; */
        if (message.playIndex !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.playIndex);
        /* optional uint32 card_id = 1; */
        if (message.cardId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.cardId);
        /* optional uint32 group_id = 3; */
        if (message.groupId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.groupId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.InBattleMechanicusConfirmCardReq
 */
export const InBattleMechanicusConfirmCardReq = new InBattleMechanicusConfirmCardReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InBattleMechanicusConfirmCardRsp$Type extends MessageType<InBattleMechanicusConfirmCardRsp> {
    constructor() {
        super("com.midnights.game.InBattleMechanicusConfirmCardRsp", [
            { no: 2, name: "play_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "card_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "retcode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "group_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<InBattleMechanicusConfirmCardRsp>): InBattleMechanicusConfirmCardRsp {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InBattleMechanicusConfirmCardRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InBattleMechanicusConfirmCardRsp): InBattleMechanicusConfirmCardRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 play_index */ 2:
                    message.playIndex = reader.uint32();
                    break;
                case /* optional uint32 card_id */ 14:
                    message.cardId = reader.uint32();
                    break;
                case /* optional int32 retcode */ 11:
                    message.retcode = reader.int32();
                    break;
                case /* optional uint32 group_id */ 6:
                    message.groupId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InBattleMechanicusConfirmCardRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 play_index = 2; */
        if (message.playIndex !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.playIndex);
        /* optional uint32 card_id = 14; */
        if (message.cardId !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.cardId);
        /* optional int32 retcode = 11; */
        if (message.retcode !== undefined)
            writer.tag(11, WireType.Varint).int32(message.retcode);
        /* optional uint32 group_id = 6; */
        if (message.groupId !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.groupId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.InBattleMechanicusConfirmCardRsp
 */
export const InBattleMechanicusConfirmCardRsp = new InBattleMechanicusConfirmCardRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InBattleMechanicusConfirmCardNotify$Type extends MessageType<InBattleMechanicusConfirmCardNotify> {
    constructor() {
        super("com.midnights.game.InBattleMechanicusConfirmCardNotify", [
            { no: 11, name: "play_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "card_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "group_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "player_uid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<InBattleMechanicusConfirmCardNotify>): InBattleMechanicusConfirmCardNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InBattleMechanicusConfirmCardNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InBattleMechanicusConfirmCardNotify): InBattleMechanicusConfirmCardNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 play_index */ 11:
                    message.playIndex = reader.uint32();
                    break;
                case /* optional uint32 card_id */ 13:
                    message.cardId = reader.uint32();
                    break;
                case /* optional uint32 group_id */ 10:
                    message.groupId = reader.uint32();
                    break;
                case /* optional uint32 player_uid */ 2:
                    message.playerUid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InBattleMechanicusConfirmCardNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 play_index = 11; */
        if (message.playIndex !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.playIndex);
        /* optional uint32 card_id = 13; */
        if (message.cardId !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.cardId);
        /* optional uint32 group_id = 10; */
        if (message.groupId !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.groupId);
        /* optional uint32 player_uid = 2; */
        if (message.playerUid !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.playerUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.InBattleMechanicusConfirmCardNotify
 */
export const InBattleMechanicusConfirmCardNotify = new InBattleMechanicusConfirmCardNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InBattleMechanicusCardResultNotify$Type extends MessageType<InBattleMechanicusCardResultNotify> {
    constructor() {
        super("com.midnights.game.InBattleMechanicusCardResultNotify", [
            { no: 6, name: "wait_seconds", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "group_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "card_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => InBattleMechanicusCardInfo },
            { no: 7, name: "wait_begin_time_us", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "player_confirmed_card_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 8, name: "play_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<InBattleMechanicusCardResultNotify>): InBattleMechanicusCardResultNotify {
        const message = { cardList: [], playerConfirmedCardMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InBattleMechanicusCardResultNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InBattleMechanicusCardResultNotify): InBattleMechanicusCardResultNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 wait_seconds */ 6:
                    message.waitSeconds = reader.uint32();
                    break;
                case /* optional uint32 group_id */ 2:
                    message.groupId = reader.uint32();
                    break;
                case /* repeated com.midnights.game.InBattleMechanicusCardInfo card_list */ 9:
                    message.cardList.push(InBattleMechanicusCardInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint64 wait_begin_time_us */ 7:
                    message.waitBeginTimeUs = reader.uint64().toBigInt();
                    break;
                case /* map<uint32, uint32> player_confirmed_card_map */ 12:
                    this.binaryReadMap12(message.playerConfirmedCardMap, reader, options);
                    break;
                case /* optional uint32 play_index */ 8:
                    message.playIndex = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap12(map: InBattleMechanicusCardResultNotify["playerConfirmedCardMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof InBattleMechanicusCardResultNotify["playerConfirmedCardMap"] | undefined, val: InBattleMechanicusCardResultNotify["playerConfirmedCardMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field com.midnights.game.InBattleMechanicusCardResultNotify.player_confirmed_card_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: InBattleMechanicusCardResultNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 wait_seconds = 6; */
        if (message.waitSeconds !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.waitSeconds);
        /* optional uint32 group_id = 2; */
        if (message.groupId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.groupId);
        /* repeated com.midnights.game.InBattleMechanicusCardInfo card_list = 9; */
        for (let i = 0; i < message.cardList.length; i++)
            InBattleMechanicusCardInfo.internalBinaryWrite(message.cardList[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* optional uint64 wait_begin_time_us = 7; */
        if (message.waitBeginTimeUs !== undefined)
            writer.tag(7, WireType.Varint).uint64(message.waitBeginTimeUs);
        /* map<uint32, uint32> player_confirmed_card_map = 12; */
        for (let k of Object.keys(message.playerConfirmedCardMap))
            writer.tag(12, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.playerConfirmedCardMap[k as any]).join();
        /* optional uint32 play_index = 8; */
        if (message.playIndex !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.playIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.InBattleMechanicusCardResultNotify
 */
export const InBattleMechanicusCardResultNotify = new InBattleMechanicusCardResultNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MultistagePlayFinishStageRsp$Type extends MessageType<MultistagePlayFinishStageRsp> {
    constructor() {
        super("com.midnights.game.MultistagePlayFinishStageRsp", [
            { no: 11, name: "retcode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "group_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "play_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<MultistagePlayFinishStageRsp>): MultistagePlayFinishStageRsp {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MultistagePlayFinishStageRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MultistagePlayFinishStageRsp): MultistagePlayFinishStageRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 retcode */ 11:
                    message.retcode = reader.int32();
                    break;
                case /* optional uint32 group_id */ 12:
                    message.groupId = reader.uint32();
                    break;
                case /* optional uint32 play_index */ 6:
                    message.playIndex = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MultistagePlayFinishStageRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 retcode = 11; */
        if (message.retcode !== undefined)
            writer.tag(11, WireType.Varint).int32(message.retcode);
        /* optional uint32 group_id = 12; */
        if (message.groupId !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.groupId);
        /* optional uint32 play_index = 6; */
        if (message.playIndex !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.playIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.MultistagePlayFinishStageRsp
 */
export const MultistagePlayFinishStageRsp = new MultistagePlayFinishStageRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MultistageSettleWatcherInfo$Type extends MessageType<MultistageSettleWatcherInfo> {
    constructor() {
        super("com.midnights.game.MultistageSettleWatcherInfo", [
            { no: 13, name: "total_progress", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "cur_progress", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "watcher_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "is_inverse", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MultistageSettleWatcherInfo>): MultistageSettleWatcherInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MultistageSettleWatcherInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MultistageSettleWatcherInfo): MultistageSettleWatcherInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 total_progress */ 13:
                    message.totalProgress = reader.uint32();
                    break;
                case /* optional uint32 cur_progress */ 5:
                    message.curProgress = reader.uint32();
                    break;
                case /* optional uint32 watcher_id */ 7:
                    message.watcherId = reader.uint32();
                    break;
                case /* optional bool is_inverse */ 12:
                    message.isInverse = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MultistageSettleWatcherInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 total_progress = 13; */
        if (message.totalProgress !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.totalProgress);
        /* optional uint32 cur_progress = 5; */
        if (message.curProgress !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.curProgress);
        /* optional uint32 watcher_id = 7; */
        if (message.watcherId !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.watcherId);
        /* optional bool is_inverse = 12; */
        if (message.isInverse !== undefined)
            writer.tag(12, WireType.Varint).bool(message.isInverse);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.MultistageSettleWatcherInfo
 */
export const MultistageSettleWatcherInfo = new MultistageSettleWatcherInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InBattleMechanicusSettleNotify$Type extends MessageType<InBattleMechanicusSettleNotify> {
    constructor() {
        super("com.midnights.game.InBattleMechanicusSettleNotify", [
            { no: 15, name: "group_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "scene_time_ms", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "difficulty_percentage", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "total_token", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "watcher_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MultistageSettleWatcherInfo },
            { no: 13, name: "real_token", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "is_success", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "play_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<InBattleMechanicusSettleNotify>): InBattleMechanicusSettleNotify {
        const message = { watcherList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InBattleMechanicusSettleNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InBattleMechanicusSettleNotify): InBattleMechanicusSettleNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 group_id */ 15:
                    message.groupId = reader.uint32();
                    break;
                case /* optional uint64 scene_time_ms */ 11:
                    message.sceneTimeMs = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 difficulty_percentage */ 6:
                    message.difficultyPercentage = reader.uint32();
                    break;
                case /* optional uint32 total_token */ 7:
                    message.totalToken = reader.uint32();
                    break;
                case /* repeated com.midnights.game.MultistageSettleWatcherInfo watcher_list */ 3:
                    message.watcherList.push(MultistageSettleWatcherInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 real_token */ 13:
                    message.realToken = reader.uint32();
                    break;
                case /* optional bool is_success */ 2:
                    message.isSuccess = reader.bool();
                    break;
                case /* optional uint32 play_index */ 14:
                    message.playIndex = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InBattleMechanicusSettleNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 group_id = 15; */
        if (message.groupId !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.groupId);
        /* optional uint64 scene_time_ms = 11; */
        if (message.sceneTimeMs !== undefined)
            writer.tag(11, WireType.Varint).uint64(message.sceneTimeMs);
        /* optional uint32 difficulty_percentage = 6; */
        if (message.difficultyPercentage !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.difficultyPercentage);
        /* optional uint32 total_token = 7; */
        if (message.totalToken !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.totalToken);
        /* repeated com.midnights.game.MultistageSettleWatcherInfo watcher_list = 3; */
        for (let i = 0; i < message.watcherList.length; i++)
            MultistageSettleWatcherInfo.internalBinaryWrite(message.watcherList[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 real_token = 13; */
        if (message.realToken !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.realToken);
        /* optional bool is_success = 2; */
        if (message.isSuccess !== undefined)
            writer.tag(2, WireType.Varint).bool(message.isSuccess);
        /* optional uint32 play_index = 14; */
        if (message.playIndex !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.playIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.InBattleMechanicusSettleNotify
 */
export const InBattleMechanicusSettleNotify = new InBattleMechanicusSettleNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InBattleMechanicusSettleInfo$Type extends MessageType<InBattleMechanicusSettleInfo> {
    constructor() {
        super("com.midnights.game.InBattleMechanicusSettleInfo", [
            { no: 15, name: "scene_time_ms", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "total_token", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "real_token", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "watcher_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MultistageSettleWatcherInfo },
            { no: 6, name: "is_success", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "play_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "difficulty_percentage", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "group_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<InBattleMechanicusSettleInfo>): InBattleMechanicusSettleInfo {
        const message = { watcherList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InBattleMechanicusSettleInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InBattleMechanicusSettleInfo): InBattleMechanicusSettleInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 scene_time_ms */ 15:
                    message.sceneTimeMs = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 total_token */ 4:
                    message.totalToken = reader.uint32();
                    break;
                case /* optional uint32 real_token */ 8:
                    message.realToken = reader.uint32();
                    break;
                case /* repeated com.midnights.game.MultistageSettleWatcherInfo watcher_list */ 7:
                    message.watcherList.push(MultistageSettleWatcherInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool is_success */ 6:
                    message.isSuccess = reader.bool();
                    break;
                case /* optional uint32 play_index */ 3:
                    message.playIndex = reader.uint32();
                    break;
                case /* optional uint32 difficulty_percentage */ 10:
                    message.difficultyPercentage = reader.uint32();
                    break;
                case /* optional uint32 group_id */ 13:
                    message.groupId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InBattleMechanicusSettleInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 scene_time_ms = 15; */
        if (message.sceneTimeMs !== undefined)
            writer.tag(15, WireType.Varint).uint64(message.sceneTimeMs);
        /* optional uint32 total_token = 4; */
        if (message.totalToken !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.totalToken);
        /* optional uint32 real_token = 8; */
        if (message.realToken !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.realToken);
        /* repeated com.midnights.game.MultistageSettleWatcherInfo watcher_list = 7; */
        for (let i = 0; i < message.watcherList.length; i++)
            MultistageSettleWatcherInfo.internalBinaryWrite(message.watcherList[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* optional bool is_success = 6; */
        if (message.isSuccess !== undefined)
            writer.tag(6, WireType.Varint).bool(message.isSuccess);
        /* optional uint32 play_index = 3; */
        if (message.playIndex !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.playIndex);
        /* optional uint32 difficulty_percentage = 10; */
        if (message.difficultyPercentage !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.difficultyPercentage);
        /* optional uint32 group_id = 13; */
        if (message.groupId !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.groupId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.InBattleMechanicusSettleInfo
 */
export const InBattleMechanicusSettleInfo = new InBattleMechanicusSettleInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MultistagePlaySettleNotify$Type extends MessageType<MultistagePlaySettleNotify> {
    constructor() {
        super("com.midnights.game.MultistagePlaySettleNotify", [
            { no: 14, name: "play_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "group_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 1402, name: "mechanicus_settle_info", kind: "message", oneof: "detail", T: () => InBattleMechanicusSettleInfo },
            { no: 1283, name: "chess_settle_info", kind: "message", oneof: "detail", T: () => InBattleChessSettleInfo },
            { no: 612, name: "irodori_chess_settle_info", kind: "message", oneof: "detail", T: () => InBattleIrodoriChessSettleInfo }
        ]);
    }
    create(value?: PartialMessage<MultistagePlaySettleNotify>): MultistagePlaySettleNotify {
        const message = { detail: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MultistagePlaySettleNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MultistagePlaySettleNotify): MultistagePlaySettleNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 play_index */ 14:
                    message.playIndex = reader.uint32();
                    break;
                case /* optional uint32 group_id */ 4:
                    message.groupId = reader.uint32();
                    break;
                case /* com.midnights.game.InBattleMechanicusSettleInfo mechanicus_settle_info */ 1402:
                    message.detail = {
                        oneofKind: "mechanicusSettleInfo",
                        mechanicusSettleInfo: InBattleMechanicusSettleInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).mechanicusSettleInfo)
                    };
                    break;
                case /* com.midnights.game.InBattleChessSettleInfo chess_settle_info */ 1283:
                    message.detail = {
                        oneofKind: "chessSettleInfo",
                        chessSettleInfo: InBattleChessSettleInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).chessSettleInfo)
                    };
                    break;
                case /* com.midnights.game.InBattleIrodoriChessSettleInfo irodori_chess_settle_info */ 612:
                    message.detail = {
                        oneofKind: "irodoriChessSettleInfo",
                        irodoriChessSettleInfo: InBattleIrodoriChessSettleInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).irodoriChessSettleInfo)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MultistagePlaySettleNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 play_index = 14; */
        if (message.playIndex !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.playIndex);
        /* optional uint32 group_id = 4; */
        if (message.groupId !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.groupId);
        /* com.midnights.game.InBattleMechanicusSettleInfo mechanicus_settle_info = 1402; */
        if (message.detail.oneofKind === "mechanicusSettleInfo")
            InBattleMechanicusSettleInfo.internalBinaryWrite(message.detail.mechanicusSettleInfo, writer.tag(1402, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.InBattleChessSettleInfo chess_settle_info = 1283; */
        if (message.detail.oneofKind === "chessSettleInfo")
            InBattleChessSettleInfo.internalBinaryWrite(message.detail.chessSettleInfo, writer.tag(1283, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.InBattleIrodoriChessSettleInfo irodori_chess_settle_info = 612; */
        if (message.detail.oneofKind === "irodoriChessSettleInfo")
            InBattleIrodoriChessSettleInfo.internalBinaryWrite(message.detail.irodoriChessSettleInfo, writer.tag(612, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.MultistagePlaySettleNotify
 */
export const MultistagePlaySettleNotify = new MultistagePlaySettleNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MultistagePlayStageEndNotify$Type extends MessageType<MultistagePlayStageEndNotify> {
    constructor() {
        super("com.midnights.game.MultistagePlayStageEndNotify", [
            { no: 15, name: "group_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "play_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<MultistagePlayStageEndNotify>): MultistagePlayStageEndNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MultistagePlayStageEndNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MultistagePlayStageEndNotify): MultistagePlayStageEndNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 group_id */ 15:
                    message.groupId = reader.uint32();
                    break;
                case /* optional uint32 play_index */ 9:
                    message.playIndex = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MultistagePlayStageEndNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 group_id = 15; */
        if (message.groupId !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.groupId);
        /* optional uint32 play_index = 9; */
        if (message.playIndex !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.playIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.MultistagePlayStageEndNotify
 */
export const MultistagePlayStageEndNotify = new MultistagePlayStageEndNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MultistagePlayEndNotify$Type extends MessageType<MultistagePlayEndNotify> {
    constructor() {
        super("com.midnights.game.MultistagePlayEndNotify", [
            { no: 5, name: "group_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "play_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<MultistagePlayEndNotify>): MultistagePlayEndNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MultistagePlayEndNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MultistagePlayEndNotify): MultistagePlayEndNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 group_id */ 5:
                    message.groupId = reader.uint32();
                    break;
                case /* optional uint32 play_index */ 13:
                    message.playIndex = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MultistagePlayEndNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 group_id = 5; */
        if (message.groupId !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.groupId);
        /* optional uint32 play_index = 13; */
        if (message.playIndex !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.playIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.MultistagePlayEndNotify
 */
export const MultistagePlayEndNotify = new MultistagePlayEndNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FleurFairBuffEnergyNotify$Type extends MessageType<FleurFairBuffEnergyNotify> {
    constructor() {
        super("com.midnights.game.FleurFairBuffEnergyNotify", [
            { no: 4, name: "energy", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<FleurFairBuffEnergyNotify>): FleurFairBuffEnergyNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FleurFairBuffEnergyNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FleurFairBuffEnergyNotify): FleurFairBuffEnergyNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 energy */ 4:
                    message.energy = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FleurFairBuffEnergyNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 energy = 4; */
        if (message.energy !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.energy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.FleurFairBuffEnergyNotify
 */
export const FleurFairBuffEnergyNotify = new FleurFairBuffEnergyNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FleurFairGallerySettleInfo$Type extends MessageType<FleurFairGallerySettleInfo> {
    constructor() {
        super("com.midnights.game.FleurFairGallerySettleInfo", [
            { no: 2, name: "energy", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "gallery_stage_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "energy_stat_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } },
            { no: 9, name: "gallery_stage_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "is_success", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<FleurFairGallerySettleInfo>): FleurFairGallerySettleInfo {
        const message = { energyStatMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FleurFairGallerySettleInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FleurFairGallerySettleInfo): FleurFairGallerySettleInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 energy */ 2:
                    message.energy = reader.uint32();
                    break;
                case /* optional uint32 gallery_stage_index */ 11:
                    message.galleryStageIndex = reader.uint32();
                    break;
                case /* map<uint32, int32> energy_stat_map */ 6:
                    this.binaryReadMap6(message.energyStatMap, reader, options);
                    break;
                case /* optional uint32 gallery_stage_count */ 9:
                    message.galleryStageCount = reader.uint32();
                    break;
                case /* optional bool is_success */ 1:
                    message.isSuccess = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap6(map: FleurFairGallerySettleInfo["energyStatMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof FleurFairGallerySettleInfo["energyStatMap"] | undefined, val: FleurFairGallerySettleInfo["energyStatMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field com.midnights.game.FleurFairGallerySettleInfo.energy_stat_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: FleurFairGallerySettleInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 energy = 2; */
        if (message.energy !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.energy);
        /* optional uint32 gallery_stage_index = 11; */
        if (message.galleryStageIndex !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.galleryStageIndex);
        /* map<uint32, int32> energy_stat_map = 6; */
        for (let k of Object.keys(message.energyStatMap))
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).int32(message.energyStatMap[k as any]).join();
        /* optional uint32 gallery_stage_count = 9; */
        if (message.galleryStageCount !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.galleryStageCount);
        /* optional bool is_success = 1; */
        if (message.isSuccess !== undefined)
            writer.tag(1, WireType.Varint).bool(message.isSuccess);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.FleurFairGallerySettleInfo
 */
export const FleurFairGallerySettleInfo = new FleurFairGallerySettleInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FleurFairPlayerStatInfo$Type extends MessageType<FleurFairPlayerStatInfo> {
    constructor() {
        super("com.midnights.game.FleurFairPlayerStatInfo", [
            { no: 11, name: "online_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "uid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "profile_picture", kind: "message", T: () => ProfilePicture },
            { no: 3, name: "stat_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "head_image", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "nick_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "param", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<FleurFairPlayerStatInfo>): FleurFairPlayerStatInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FleurFairPlayerStatInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FleurFairPlayerStatInfo): FleurFairPlayerStatInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string online_id */ 11:
                    message.onlineId = reader.string();
                    break;
                case /* optional uint32 uid */ 8:
                    message.uid = reader.uint32();
                    break;
                case /* optional com.midnights.game.ProfilePicture profile_picture */ 1:
                    message.profilePicture = ProfilePicture.internalBinaryRead(reader, reader.uint32(), options, message.profilePicture);
                    break;
                case /* optional uint32 stat_id */ 3:
                    message.statId = reader.uint32();
                    break;
                case /* optional uint32 head_image */ 6:
                    message.headImage = reader.uint32();
                    break;
                case /* optional string nick_name */ 15:
                    message.nickName = reader.string();
                    break;
                case /* optional int32 param */ 5:
                    message.param = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FleurFairPlayerStatInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string online_id = 11; */
        if (message.onlineId !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.onlineId);
        /* optional uint32 uid = 8; */
        if (message.uid !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.uid);
        /* optional com.midnights.game.ProfilePicture profile_picture = 1; */
        if (message.profilePicture)
            ProfilePicture.internalBinaryWrite(message.profilePicture, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 stat_id = 3; */
        if (message.statId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.statId);
        /* optional uint32 head_image = 6; */
        if (message.headImage !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.headImage);
        /* optional string nick_name = 15; */
        if (message.nickName !== undefined)
            writer.tag(15, WireType.LengthDelimited).string(message.nickName);
        /* optional int32 param = 5; */
        if (message.param !== undefined)
            writer.tag(5, WireType.Varint).int32(message.param);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.FleurFairPlayerStatInfo
 */
export const FleurFairPlayerStatInfo = new FleurFairPlayerStatInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FleurFairBossSettleInfo$Type extends MessageType<FleurFairBossSettleInfo> {
    constructor() {
        super("com.midnights.game.FleurFairBossSettleInfo", [
            { no: 15, name: "reward_token_num", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "stat_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FleurFairPlayerStatInfo },
            { no: 10, name: "is_success", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "energy", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "cost_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<FleurFairBossSettleInfo>): FleurFairBossSettleInfo {
        const message = { statInfoList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FleurFairBossSettleInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FleurFairBossSettleInfo): FleurFairBossSettleInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 reward_token_num */ 15:
                    message.rewardTokenNum = reader.uint32();
                    break;
                case /* repeated com.midnights.game.FleurFairPlayerStatInfo stat_info_list */ 1:
                    message.statInfoList.push(FleurFairPlayerStatInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool is_success */ 10:
                    message.isSuccess = reader.bool();
                    break;
                case /* optional uint32 energy */ 12:
                    message.energy = reader.uint32();
                    break;
                case /* optional uint32 cost_time */ 8:
                    message.costTime = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FleurFairBossSettleInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 reward_token_num = 15; */
        if (message.rewardTokenNum !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.rewardTokenNum);
        /* repeated com.midnights.game.FleurFairPlayerStatInfo stat_info_list = 1; */
        for (let i = 0; i < message.statInfoList.length; i++)
            FleurFairPlayerStatInfo.internalBinaryWrite(message.statInfoList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional bool is_success = 10; */
        if (message.isSuccess !== undefined)
            writer.tag(10, WireType.Varint).bool(message.isSuccess);
        /* optional uint32 energy = 12; */
        if (message.energy !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.energy);
        /* optional uint32 cost_time = 8; */
        if (message.costTime !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.costTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.FleurFairBossSettleInfo
 */
export const FleurFairBossSettleInfo = new FleurFairBossSettleInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FleurFairStageSettleNotify$Type extends MessageType<FleurFairStageSettleNotify> {
    constructor() {
        super("com.midnights.game.FleurFairStageSettleNotify", [
            { no: 10, name: "stage_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "gallery_settle_info", kind: "message", oneof: "detail", T: () => FleurFairGallerySettleInfo },
            { no: 14, name: "boss_settle_info", kind: "message", oneof: "detail", T: () => FleurFairBossSettleInfo }
        ]);
    }
    create(value?: PartialMessage<FleurFairStageSettleNotify>): FleurFairStageSettleNotify {
        const message = { detail: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FleurFairStageSettleNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FleurFairStageSettleNotify): FleurFairStageSettleNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 stage_type */ 10:
                    message.stageType = reader.uint32();
                    break;
                case /* com.midnights.game.FleurFairGallerySettleInfo gallery_settle_info */ 13:
                    message.detail = {
                        oneofKind: "gallerySettleInfo",
                        gallerySettleInfo: FleurFairGallerySettleInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).gallerySettleInfo)
                    };
                    break;
                case /* com.midnights.game.FleurFairBossSettleInfo boss_settle_info */ 14:
                    message.detail = {
                        oneofKind: "bossSettleInfo",
                        bossSettleInfo: FleurFairBossSettleInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).bossSettleInfo)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FleurFairStageSettleNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 stage_type = 10; */
        if (message.stageType !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.stageType);
        /* com.midnights.game.FleurFairGallerySettleInfo gallery_settle_info = 13; */
        if (message.detail.oneofKind === "gallerySettleInfo")
            FleurFairGallerySettleInfo.internalBinaryWrite(message.detail.gallerySettleInfo, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.FleurFairBossSettleInfo boss_settle_info = 14; */
        if (message.detail.oneofKind === "bossSettleInfo")
            FleurFairBossSettleInfo.internalBinaryWrite(message.detail.bossSettleInfo, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.FleurFairStageSettleNotify
 */
export const FleurFairStageSettleNotify = new FleurFairStageSettleNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FleurFairFinishGalleryStageNotify$Type extends MessageType<FleurFairFinishGalleryStageNotify> {
    constructor() {
        super("com.midnights.game.FleurFairFinishGalleryStageNotify", []);
    }
    create(value?: PartialMessage<FleurFairFinishGalleryStageNotify>): FleurFairFinishGalleryStageNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FleurFairFinishGalleryStageNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FleurFairFinishGalleryStageNotify): FleurFairFinishGalleryStageNotify {
        return target ?? this.create();
    }
    internalBinaryWrite(message: FleurFairFinishGalleryStageNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.FleurFairFinishGalleryStageNotify
 */
export const FleurFairFinishGalleryStageNotify = new FleurFairFinishGalleryStageNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HideAndSeekPlayerBattleInfo$Type extends MessageType<HideAndSeekPlayerBattleInfo> {
    constructor() {
        super("com.midnights.game.HideAndSeekPlayerBattleInfo", [
            { no: 3, name: "costume_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "skill_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "is_ready", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "avatar_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<HideAndSeekPlayerBattleInfo>): HideAndSeekPlayerBattleInfo {
        const message = { skillList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HideAndSeekPlayerBattleInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HideAndSeekPlayerBattleInfo): HideAndSeekPlayerBattleInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 costume_id */ 3:
                    message.costumeId = reader.uint32();
                    break;
                case /* repeated uint32 skill_list */ 15:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.skillList.push(reader.uint32());
                    else
                        message.skillList.push(reader.uint32());
                    break;
                case /* optional bool is_ready */ 12:
                    message.isReady = reader.bool();
                    break;
                case /* optional uint32 avatar_id */ 6:
                    message.avatarId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HideAndSeekPlayerBattleInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 costume_id = 3; */
        if (message.costumeId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.costumeId);
        /* repeated uint32 skill_list = 15; */
        if (message.skillList.length) {
            writer.tag(15, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.skillList.length; i++)
                writer.uint32(message.skillList[i]);
            writer.join();
        }
        /* optional bool is_ready = 12; */
        if (message.isReady !== undefined)
            writer.tag(12, WireType.Varint).bool(message.isReady);
        /* optional uint32 avatar_id = 6; */
        if (message.avatarId !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.avatarId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.HideAndSeekPlayerBattleInfo
 */
export const HideAndSeekPlayerBattleInfo = new HideAndSeekPlayerBattleInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HideAndSeekStageInfo$Type extends MessageType<HideAndSeekStageInfo> {
    constructor() {
        super("com.midnights.game.HideAndSeekStageInfo", [
            { no: 8, name: "map_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "is_record_score", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "stage_type", kind: "enum", opt: true, T: () => ["com.midnights.game.HideAndSeekStageType", HideAndSeekStageType] },
            { no: 2, name: "battle_info_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => HideAndSeekPlayerBattleInfo } },
            { no: 1, name: "hider_uid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "hunter_uid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<HideAndSeekStageInfo>): HideAndSeekStageInfo {
        const message = { battleInfoMap: {}, hiderUidList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HideAndSeekStageInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HideAndSeekStageInfo): HideAndSeekStageInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 map_id */ 8:
                    message.mapId = reader.uint32();
                    break;
                case /* optional bool is_record_score */ 3:
                    message.isRecordScore = reader.bool();
                    break;
                case /* optional com.midnights.game.HideAndSeekStageType stage_type */ 7:
                    message.stageType = reader.int32();
                    break;
                case /* map<uint32, com.midnights.game.HideAndSeekPlayerBattleInfo> battle_info_map */ 2:
                    this.binaryReadMap2(message.battleInfoMap, reader, options);
                    break;
                case /* repeated uint32 hider_uid_list */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.hiderUidList.push(reader.uint32());
                    else
                        message.hiderUidList.push(reader.uint32());
                    break;
                case /* optional uint32 hunter_uid */ 10:
                    message.hunterUid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: HideAndSeekStageInfo["battleInfoMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof HideAndSeekStageInfo["battleInfoMap"] | undefined, val: HideAndSeekStageInfo["battleInfoMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = HideAndSeekPlayerBattleInfo.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field com.midnights.game.HideAndSeekStageInfo.battle_info_map");
            }
        }
        map[key ?? 0] = val ?? HideAndSeekPlayerBattleInfo.create();
    }
    internalBinaryWrite(message: HideAndSeekStageInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 map_id = 8; */
        if (message.mapId !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.mapId);
        /* optional bool is_record_score = 3; */
        if (message.isRecordScore !== undefined)
            writer.tag(3, WireType.Varint).bool(message.isRecordScore);
        /* optional com.midnights.game.HideAndSeekStageType stage_type = 7; */
        if (message.stageType !== undefined)
            writer.tag(7, WireType.Varint).int32(message.stageType);
        /* map<uint32, com.midnights.game.HideAndSeekPlayerBattleInfo> battle_info_map = 2; */
        for (let k of Object.keys(message.battleInfoMap)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            HideAndSeekPlayerBattleInfo.internalBinaryWrite(message.battleInfoMap[k as any], writer, options);
            writer.join().join();
        }
        /* repeated uint32 hider_uid_list = 1; */
        if (message.hiderUidList.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.hiderUidList.length; i++)
                writer.uint32(message.hiderUidList[i]);
            writer.join();
        }
        /* optional uint32 hunter_uid = 10; */
        if (message.hunterUid !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.hunterUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.HideAndSeekStageInfo
 */
export const HideAndSeekStageInfo = new HideAndSeekStageInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HideAndSeekSelectAvatarReq$Type extends MessageType<HideAndSeekSelectAvatarReq> {
    constructor() {
        super("com.midnights.game.HideAndSeekSelectAvatarReq", [
            { no: 8, name: "avatar_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<HideAndSeekSelectAvatarReq>): HideAndSeekSelectAvatarReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HideAndSeekSelectAvatarReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HideAndSeekSelectAvatarReq): HideAndSeekSelectAvatarReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 avatar_id */ 8:
                    message.avatarId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HideAndSeekSelectAvatarReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 avatar_id = 8; */
        if (message.avatarId !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.avatarId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.HideAndSeekSelectAvatarReq
 */
export const HideAndSeekSelectAvatarReq = new HideAndSeekSelectAvatarReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HideAndSeekSelectAvatarRsp$Type extends MessageType<HideAndSeekSelectAvatarRsp> {
    constructor() {
        super("com.midnights.game.HideAndSeekSelectAvatarRsp", [
            { no: 2, name: "retcode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "avatar_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<HideAndSeekSelectAvatarRsp>): HideAndSeekSelectAvatarRsp {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HideAndSeekSelectAvatarRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HideAndSeekSelectAvatarRsp): HideAndSeekSelectAvatarRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 retcode */ 2:
                    message.retcode = reader.int32();
                    break;
                case /* optional uint32 avatar_id */ 3:
                    message.avatarId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HideAndSeekSelectAvatarRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 retcode = 2; */
        if (message.retcode !== undefined)
            writer.tag(2, WireType.Varint).int32(message.retcode);
        /* optional uint32 avatar_id = 3; */
        if (message.avatarId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.avatarId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.HideAndSeekSelectAvatarRsp
 */
export const HideAndSeekSelectAvatarRsp = new HideAndSeekSelectAvatarRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HideAndSeekSetReadyReq$Type extends MessageType<HideAndSeekSetReadyReq> {
    constructor() {
        super("com.midnights.game.HideAndSeekSetReadyReq", []);
    }
    create(value?: PartialMessage<HideAndSeekSetReadyReq>): HideAndSeekSetReadyReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HideAndSeekSetReadyReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HideAndSeekSetReadyReq): HideAndSeekSetReadyReq {
        return target ?? this.create();
    }
    internalBinaryWrite(message: HideAndSeekSetReadyReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.HideAndSeekSetReadyReq
 */
export const HideAndSeekSetReadyReq = new HideAndSeekSetReadyReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HideAndSeekSetReadyRsp$Type extends MessageType<HideAndSeekSetReadyRsp> {
    constructor() {
        super("com.midnights.game.HideAndSeekSetReadyRsp", [
            { no: 11, name: "retcode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<HideAndSeekSetReadyRsp>): HideAndSeekSetReadyRsp {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HideAndSeekSetReadyRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HideAndSeekSetReadyRsp): HideAndSeekSetReadyRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 retcode */ 11:
                    message.retcode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HideAndSeekSetReadyRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 retcode = 11; */
        if (message.retcode !== undefined)
            writer.tag(11, WireType.Varint).int32(message.retcode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.HideAndSeekSetReadyRsp
 */
export const HideAndSeekSetReadyRsp = new HideAndSeekSetReadyRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HideAndSeekSettleInfo$Type extends MessageType<HideAndSeekSettleInfo> {
    constructor() {
        super("com.midnights.game.HideAndSeekSettleInfo", [
            { no: 2, name: "uid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "profile_picture", kind: "message", T: () => ProfilePicture },
            { no: 8, name: "card_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ExhibitionDisplayInfo },
            { no: 3, name: "nickname", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "head_image", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "online_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HideAndSeekSettleInfo>): HideAndSeekSettleInfo {
        const message = { cardList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HideAndSeekSettleInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HideAndSeekSettleInfo): HideAndSeekSettleInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 uid */ 2:
                    message.uid = reader.uint32();
                    break;
                case /* optional com.midnights.game.ProfilePicture profile_picture */ 1:
                    message.profilePicture = ProfilePicture.internalBinaryRead(reader, reader.uint32(), options, message.profilePicture);
                    break;
                case /* repeated com.midnights.game.ExhibitionDisplayInfo card_list */ 8:
                    message.cardList.push(ExhibitionDisplayInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string nickname */ 3:
                    message.nickname = reader.string();
                    break;
                case /* optional uint32 head_image */ 4:
                    message.headImage = reader.uint32();
                    break;
                case /* optional string online_id */ 10:
                    message.onlineId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HideAndSeekSettleInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 uid = 2; */
        if (message.uid !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.uid);
        /* optional com.midnights.game.ProfilePicture profile_picture = 1; */
        if (message.profilePicture)
            ProfilePicture.internalBinaryWrite(message.profilePicture, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated com.midnights.game.ExhibitionDisplayInfo card_list = 8; */
        for (let i = 0; i < message.cardList.length; i++)
            ExhibitionDisplayInfo.internalBinaryWrite(message.cardList[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* optional string nickname = 3; */
        if (message.nickname !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.nickname);
        /* optional uint32 head_image = 4; */
        if (message.headImage !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.headImage);
        /* optional string online_id = 10; */
        if (message.onlineId !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.onlineId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.HideAndSeekSettleInfo
 */
export const HideAndSeekSettleInfo = new HideAndSeekSettleInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HideAndSeekSettleNotify$Type extends MessageType<HideAndSeekSettleNotify> {
    constructor() {
        super("com.midnights.game.HideAndSeekSettleNotify", [
            { no: 2, name: "cost_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "settle_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HideAndSeekSettleInfo },
            { no: 15, name: "winner_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "reason", kind: "enum", opt: true, T: () => ["com.midnights.game.HideAndSeekSettleNotify.SettleReason", HideAndSeekSettleNotify_SettleReason] },
            { no: 13, name: "play_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "is_record_score", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "score_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ExhibitionDisplayInfo },
            { no: 14, name: "stage_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<HideAndSeekSettleNotify>): HideAndSeekSettleNotify {
        const message = { settleInfoList: [], winnerList: [], scoreList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HideAndSeekSettleNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HideAndSeekSettleNotify): HideAndSeekSettleNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 cost_time */ 2:
                    message.costTime = reader.uint32();
                    break;
                case /* repeated com.midnights.game.HideAndSeekSettleInfo settle_info_list */ 8:
                    message.settleInfoList.push(HideAndSeekSettleInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 winner_list */ 15:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.winnerList.push(reader.uint32());
                    else
                        message.winnerList.push(reader.uint32());
                    break;
                case /* optional com.midnights.game.HideAndSeekSettleNotify.SettleReason reason */ 4:
                    message.reason = reader.int32();
                    break;
                case /* optional uint32 play_index */ 13:
                    message.playIndex = reader.uint32();
                    break;
                case /* optional bool is_record_score */ 6:
                    message.isRecordScore = reader.bool();
                    break;
                case /* repeated com.midnights.game.ExhibitionDisplayInfo score_list */ 9:
                    message.scoreList.push(ExhibitionDisplayInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 stage_type */ 14:
                    message.stageType = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HideAndSeekSettleNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 cost_time = 2; */
        if (message.costTime !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.costTime);
        /* repeated com.midnights.game.HideAndSeekSettleInfo settle_info_list = 8; */
        for (let i = 0; i < message.settleInfoList.length; i++)
            HideAndSeekSettleInfo.internalBinaryWrite(message.settleInfoList[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 winner_list = 15; */
        if (message.winnerList.length) {
            writer.tag(15, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.winnerList.length; i++)
                writer.uint32(message.winnerList[i]);
            writer.join();
        }
        /* optional com.midnights.game.HideAndSeekSettleNotify.SettleReason reason = 4; */
        if (message.reason !== undefined)
            writer.tag(4, WireType.Varint).int32(message.reason);
        /* optional uint32 play_index = 13; */
        if (message.playIndex !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.playIndex);
        /* optional bool is_record_score = 6; */
        if (message.isRecordScore !== undefined)
            writer.tag(6, WireType.Varint).bool(message.isRecordScore);
        /* repeated com.midnights.game.ExhibitionDisplayInfo score_list = 9; */
        for (let i = 0; i < message.scoreList.length; i++)
            ExhibitionDisplayInfo.internalBinaryWrite(message.scoreList[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 stage_type = 14; */
        if (message.stageType !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.stageType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.HideAndSeekSettleNotify
 */
export const HideAndSeekSettleNotify = new HideAndSeekSettleNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HideAndSeekPlayerReadyNotify$Type extends MessageType<HideAndSeekPlayerReadyNotify> {
    constructor() {
        super("com.midnights.game.HideAndSeekPlayerReadyNotify", [
            { no: 5, name: "uid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<HideAndSeekPlayerReadyNotify>): HideAndSeekPlayerReadyNotify {
        const message = { uidList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HideAndSeekPlayerReadyNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HideAndSeekPlayerReadyNotify): HideAndSeekPlayerReadyNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 uid_list */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.uidList.push(reader.uint32());
                    else
                        message.uidList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HideAndSeekPlayerReadyNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 uid_list = 5; */
        if (message.uidList.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.uidList.length; i++)
                writer.uint32(message.uidList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.HideAndSeekPlayerReadyNotify
 */
export const HideAndSeekPlayerReadyNotify = new HideAndSeekPlayerReadyNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HideAndSeekPlayerSetAvatarNotify$Type extends MessageType<HideAndSeekPlayerSetAvatarNotify> {
    constructor() {
        super("com.midnights.game.HideAndSeekPlayerSetAvatarNotify", [
            { no: 2, name: "avatar_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "costume_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "uid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<HideAndSeekPlayerSetAvatarNotify>): HideAndSeekPlayerSetAvatarNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HideAndSeekPlayerSetAvatarNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HideAndSeekPlayerSetAvatarNotify): HideAndSeekPlayerSetAvatarNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 avatar_id */ 2:
                    message.avatarId = reader.uint32();
                    break;
                case /* optional uint32 costume_id */ 13:
                    message.costumeId = reader.uint32();
                    break;
                case /* optional uint32 uid */ 5:
                    message.uid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HideAndSeekPlayerSetAvatarNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 avatar_id = 2; */
        if (message.avatarId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.avatarId);
        /* optional uint32 costume_id = 13; */
        if (message.costumeId !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.costumeId);
        /* optional uint32 uid = 5; */
        if (message.uid !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.uid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.HideAndSeekPlayerSetAvatarNotify
 */
export const HideAndSeekPlayerSetAvatarNotify = new HideAndSeekPlayerSetAvatarNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChessCardInfo$Type extends MessageType<ChessCardInfo> {
    constructor() {
        super("com.midnights.game.ChessCardInfo", [
            { no: 12, name: "effect_stack", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "card_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ChessCardInfo>): ChessCardInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChessCardInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChessCardInfo): ChessCardInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 effect_stack */ 12:
                    message.effectStack = reader.uint32();
                    break;
                case /* optional uint32 card_id */ 11:
                    message.cardId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChessCardInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 effect_stack = 12; */
        if (message.effectStack !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.effectStack);
        /* optional uint32 card_id = 11; */
        if (message.cardId !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.cardId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.ChessCardInfo
 */
export const ChessCardInfo = new ChessCardInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InBattleChessInfo$Type extends MessageType<InBattleChessInfo> {
    constructor() {
        super("com.midnights.game.InBattleChessInfo", [
            { no: 2, name: "ban_card_tag_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "round", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "selected_card_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ChessCardInfo },
            { no: 1, name: "mystery_info", kind: "message", T: () => ChessMysteryInfo },
            { no: 8, name: "player_info_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => ChessPlayerInfo } },
            { no: 6, name: "max_escapable_monsters", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "excaped_monsters", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "total_round", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "left_monsters", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<InBattleChessInfo>): InBattleChessInfo {
        const message = { banCardTagList: [], selectedCardInfoList: [], playerInfoMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InBattleChessInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InBattleChessInfo): InBattleChessInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 ban_card_tag_list */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.banCardTagList.push(reader.uint32());
                    else
                        message.banCardTagList.push(reader.uint32());
                    break;
                case /* optional uint32 round */ 4:
                    message.round = reader.uint32();
                    break;
                case /* repeated com.midnights.game.ChessCardInfo selected_card_info_list */ 9:
                    message.selectedCardInfoList.push(ChessCardInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional com.midnights.game.ChessMysteryInfo mystery_info */ 1:
                    message.mysteryInfo = ChessMysteryInfo.internalBinaryRead(reader, reader.uint32(), options, message.mysteryInfo);
                    break;
                case /* map<uint32, com.midnights.game.ChessPlayerInfo> player_info_map */ 8:
                    this.binaryReadMap8(message.playerInfoMap, reader, options);
                    break;
                case /* optional uint32 max_escapable_monsters */ 6:
                    message.maxEscapableMonsters = reader.uint32();
                    break;
                case /* optional uint32 excaped_monsters */ 12:
                    message.excapedMonsters = reader.uint32();
                    break;
                case /* optional uint32 total_round */ 14:
                    message.totalRound = reader.uint32();
                    break;
                case /* optional uint32 left_monsters */ 15:
                    message.leftMonsters = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap8(map: InBattleChessInfo["playerInfoMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof InBattleChessInfo["playerInfoMap"] | undefined, val: InBattleChessInfo["playerInfoMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = ChessPlayerInfo.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field com.midnights.game.InBattleChessInfo.player_info_map");
            }
        }
        map[key ?? 0] = val ?? ChessPlayerInfo.create();
    }
    internalBinaryWrite(message: InBattleChessInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 ban_card_tag_list = 2; */
        if (message.banCardTagList.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.banCardTagList.length; i++)
                writer.uint32(message.banCardTagList[i]);
            writer.join();
        }
        /* optional uint32 round = 4; */
        if (message.round !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.round);
        /* repeated com.midnights.game.ChessCardInfo selected_card_info_list = 9; */
        for (let i = 0; i < message.selectedCardInfoList.length; i++)
            ChessCardInfo.internalBinaryWrite(message.selectedCardInfoList[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* optional com.midnights.game.ChessMysteryInfo mystery_info = 1; */
        if (message.mysteryInfo)
            ChessMysteryInfo.internalBinaryWrite(message.mysteryInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* map<uint32, com.midnights.game.ChessPlayerInfo> player_info_map = 8; */
        for (let k of Object.keys(message.playerInfoMap)) {
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            ChessPlayerInfo.internalBinaryWrite(message.playerInfoMap[k as any], writer, options);
            writer.join().join();
        }
        /* optional uint32 max_escapable_monsters = 6; */
        if (message.maxEscapableMonsters !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.maxEscapableMonsters);
        /* optional uint32 excaped_monsters = 12; */
        if (message.excapedMonsters !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.excapedMonsters);
        /* optional uint32 total_round = 14; */
        if (message.totalRound !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.totalRound);
        /* optional uint32 left_monsters = 15; */
        if (message.leftMonsters !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.leftMonsters);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.InBattleChessInfo
 */
export const InBattleChessInfo = new InBattleChessInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InBattleChessSettleInfo$Type extends MessageType<InBattleChessSettleInfo> {
    constructor() {
        super("com.midnights.game.InBattleChessSettleInfo", [
            { no: 7, name: "is_success", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "chess_exp", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "chess_level", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "old_chess_level", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "score_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ExhibitionDisplayInfo },
            { no: 14, name: "scene_time_ms", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "old_chess_exp", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<InBattleChessSettleInfo>): InBattleChessSettleInfo {
        const message = { scoreList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InBattleChessSettleInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InBattleChessSettleInfo): InBattleChessSettleInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool is_success */ 7:
                    message.isSuccess = reader.bool();
                    break;
                case /* optional uint32 chess_exp */ 11:
                    message.chessExp = reader.uint32();
                    break;
                case /* optional uint32 chess_level */ 13:
                    message.chessLevel = reader.uint32();
                    break;
                case /* optional uint32 old_chess_level */ 10:
                    message.oldChessLevel = reader.uint32();
                    break;
                case /* repeated com.midnights.game.ExhibitionDisplayInfo score_list */ 1:
                    message.scoreList.push(ExhibitionDisplayInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint64 scene_time_ms */ 14:
                    message.sceneTimeMs = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 old_chess_exp */ 2:
                    message.oldChessExp = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InBattleChessSettleInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool is_success = 7; */
        if (message.isSuccess !== undefined)
            writer.tag(7, WireType.Varint).bool(message.isSuccess);
        /* optional uint32 chess_exp = 11; */
        if (message.chessExp !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.chessExp);
        /* optional uint32 chess_level = 13; */
        if (message.chessLevel !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.chessLevel);
        /* optional uint32 old_chess_level = 10; */
        if (message.oldChessLevel !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.oldChessLevel);
        /* repeated com.midnights.game.ExhibitionDisplayInfo score_list = 1; */
        for (let i = 0; i < message.scoreList.length; i++)
            ExhibitionDisplayInfo.internalBinaryWrite(message.scoreList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional uint64 scene_time_ms = 14; */
        if (message.sceneTimeMs !== undefined)
            writer.tag(14, WireType.Varint).uint64(message.sceneTimeMs);
        /* optional uint32 old_chess_exp = 2; */
        if (message.oldChessExp !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.oldChessExp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.InBattleChessSettleInfo
 */
export const InBattleChessSettleInfo = new InBattleChessSettleInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChessPlayerInfo$Type extends MessageType<ChessPlayerInfo> {
    constructor() {
        super("com.midnights.game.ChessPlayerInfo", [
            { no: 5, name: "uid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "free_refresh_limit", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "candidate_card_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ChessNormalCardInfo },
            { no: 12, name: "building_points", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "candidate_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "free_refresh_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "refresh_cost", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ChessPlayerInfo>): ChessPlayerInfo {
        const message = { candidateCardInfoList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChessPlayerInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChessPlayerInfo): ChessPlayerInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 uid */ 5:
                    message.uid = reader.uint32();
                    break;
                case /* optional uint32 free_refresh_limit */ 10:
                    message.freeRefreshLimit = reader.uint32();
                    break;
                case /* repeated com.midnights.game.ChessNormalCardInfo candidate_card_info_list */ 3:
                    message.candidateCardInfoList.push(ChessNormalCardInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 building_points */ 12:
                    message.buildingPoints = reader.uint32();
                    break;
                case /* optional uint32 candidate_index */ 6:
                    message.candidateIndex = reader.uint32();
                    break;
                case /* optional uint32 free_refresh_count */ 13:
                    message.freeRefreshCount = reader.uint32();
                    break;
                case /* optional uint32 refresh_cost */ 7:
                    message.refreshCost = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChessPlayerInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 uid = 5; */
        if (message.uid !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.uid);
        /* optional uint32 free_refresh_limit = 10; */
        if (message.freeRefreshLimit !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.freeRefreshLimit);
        /* repeated com.midnights.game.ChessNormalCardInfo candidate_card_info_list = 3; */
        for (let i = 0; i < message.candidateCardInfoList.length; i++)
            ChessNormalCardInfo.internalBinaryWrite(message.candidateCardInfoList[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 building_points = 12; */
        if (message.buildingPoints !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.buildingPoints);
        /* optional uint32 candidate_index = 6; */
        if (message.candidateIndex !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.candidateIndex);
        /* optional uint32 free_refresh_count = 13; */
        if (message.freeRefreshCount !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.freeRefreshCount);
        /* optional uint32 refresh_cost = 7; */
        if (message.refreshCost !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.refreshCost);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.ChessPlayerInfo
 */
export const ChessPlayerInfo = new ChessPlayerInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChessMonsterInfo$Type extends MessageType<ChessMonsterInfo> {
    constructor() {
        super("com.midnights.game.ChessMonsterInfo", [
            { no: 12, name: "monster_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "level", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "affix_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ChessMonsterInfo>): ChessMonsterInfo {
        const message = { affixList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChessMonsterInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChessMonsterInfo): ChessMonsterInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 monster_id */ 12:
                    message.monsterId = reader.uint32();
                    break;
                case /* optional uint32 level */ 2:
                    message.level = reader.uint32();
                    break;
                case /* repeated uint32 affix_list */ 13:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.affixList.push(reader.uint32());
                    else
                        message.affixList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChessMonsterInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 monster_id = 12; */
        if (message.monsterId !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.monsterId);
        /* optional uint32 level = 2; */
        if (message.level !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.level);
        /* repeated uint32 affix_list = 13; */
        if (message.affixList.length) {
            writer.tag(13, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.affixList.length; i++)
                writer.uint32(message.affixList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.ChessMonsterInfo
 */
export const ChessMonsterInfo = new ChessMonsterInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChessEntranceInfo$Type extends MessageType<ChessEntranceInfo> {
    constructor() {
        super("com.midnights.game.ChessEntranceInfo", [
            { no: 14, name: "monster_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ChessMonsterInfo },
            { no: 15, name: "entrance_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "entrance_point_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ChessEntranceInfo>): ChessEntranceInfo {
        const message = { monsterInfoList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChessEntranceInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChessEntranceInfo): ChessEntranceInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated com.midnights.game.ChessMonsterInfo monster_info_list */ 14:
                    message.monsterInfoList.push(ChessMonsterInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 entrance_index */ 15:
                    message.entranceIndex = reader.uint32();
                    break;
                case /* optional uint32 entrance_point_id */ 8:
                    message.entrancePointId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChessEntranceInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated com.midnights.game.ChessMonsterInfo monster_info_list = 14; */
        for (let i = 0; i < message.monsterInfoList.length; i++)
            ChessMonsterInfo.internalBinaryWrite(message.monsterInfoList[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 entrance_index = 15; */
        if (message.entranceIndex !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.entranceIndex);
        /* optional uint32 entrance_point_id = 8; */
        if (message.entrancePointId !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.entrancePointId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.ChessEntranceInfo
 */
export const ChessEntranceInfo = new ChessEntranceInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChessEntranceDetailInfo$Type extends MessageType<ChessEntranceDetailInfo> {
    constructor() {
        super("com.midnights.game.ChessEntranceDetailInfo", [
            { no: 4, name: "info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ChessEntranceInfo }
        ]);
    }
    create(value?: PartialMessage<ChessEntranceDetailInfo>): ChessEntranceDetailInfo {
        const message = { infoList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChessEntranceDetailInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChessEntranceDetailInfo): ChessEntranceDetailInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated com.midnights.game.ChessEntranceInfo info_list */ 4:
                    message.infoList.push(ChessEntranceInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChessEntranceDetailInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated com.midnights.game.ChessEntranceInfo info_list = 4; */
        for (let i = 0; i < message.infoList.length; i++)
            ChessEntranceInfo.internalBinaryWrite(message.infoList[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.ChessEntranceDetailInfo
 */
export const ChessEntranceDetailInfo = new ChessEntranceDetailInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChessMysteryInfo$Type extends MessageType<ChessMysteryInfo> {
    constructor() {
        super("com.midnights.game.ChessMysteryInfo", [
            { no: 13, name: "entrance_point_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 3, name: "exit_point_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "detail_info_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => ChessEntranceDetailInfo } }
        ]);
    }
    create(value?: PartialMessage<ChessMysteryInfo>): ChessMysteryInfo {
        const message = { entrancePointMap: {}, exitPointIdList: [], detailInfoMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChessMysteryInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChessMysteryInfo): ChessMysteryInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, uint32> entrance_point_map */ 13:
                    this.binaryReadMap13(message.entrancePointMap, reader, options);
                    break;
                case /* repeated uint32 exit_point_id_list */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.exitPointIdList.push(reader.uint32());
                    else
                        message.exitPointIdList.push(reader.uint32());
                    break;
                case /* map<uint32, com.midnights.game.ChessEntranceDetailInfo> detail_info_map */ 5:
                    this.binaryReadMap5(message.detailInfoMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap13(map: ChessMysteryInfo["entrancePointMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ChessMysteryInfo["entrancePointMap"] | undefined, val: ChessMysteryInfo["entrancePointMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field com.midnights.game.ChessMysteryInfo.entrance_point_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap5(map: ChessMysteryInfo["detailInfoMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ChessMysteryInfo["detailInfoMap"] | undefined, val: ChessMysteryInfo["detailInfoMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = ChessEntranceDetailInfo.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field com.midnights.game.ChessMysteryInfo.detail_info_map");
            }
        }
        map[key ?? 0] = val ?? ChessEntranceDetailInfo.create();
    }
    internalBinaryWrite(message: ChessMysteryInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, uint32> entrance_point_map = 13; */
        for (let k of Object.keys(message.entrancePointMap))
            writer.tag(13, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.entrancePointMap[k as any]).join();
        /* repeated uint32 exit_point_id_list = 3; */
        if (message.exitPointIdList.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.exitPointIdList.length; i++)
                writer.uint32(message.exitPointIdList[i]);
            writer.join();
        }
        /* map<uint32, com.midnights.game.ChessEntranceDetailInfo> detail_info_map = 5; */
        for (let k of Object.keys(message.detailInfoMap)) {
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            ChessEntranceDetailInfo.internalBinaryWrite(message.detailInfoMap[k as any], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.ChessMysteryInfo
 */
export const ChessMysteryInfo = new ChessMysteryInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChessNormalCardInfo$Type extends MessageType<ChessNormalCardInfo> {
    constructor() {
        super("com.midnights.game.ChessNormalCardInfo", [
            { no: 2, name: "card_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "cost_points", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "is_attach_curse", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ChessNormalCardInfo>): ChessNormalCardInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChessNormalCardInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChessNormalCardInfo): ChessNormalCardInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 card_id */ 2:
                    message.cardId = reader.uint32();
                    break;
                case /* optional uint32 cost_points */ 15:
                    message.costPoints = reader.uint32();
                    break;
                case /* optional bool is_attach_curse */ 6:
                    message.isAttachCurse = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChessNormalCardInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 card_id = 2; */
        if (message.cardId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.cardId);
        /* optional uint32 cost_points = 15; */
        if (message.costPoints !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.costPoints);
        /* optional bool is_attach_curse = 6; */
        if (message.isAttachCurse !== undefined)
            writer.tag(6, WireType.Varint).bool(message.isAttachCurse);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.ChessNormalCardInfo
 */
export const ChessNormalCardInfo = new ChessNormalCardInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChessPickCardReq$Type extends MessageType<ChessPickCardReq> {
    constructor() {
        super("com.midnights.game.ChessPickCardReq", [
            { no: 1, name: "card_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "card_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ChessPickCardReq>): ChessPickCardReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChessPickCardReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChessPickCardReq): ChessPickCardReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 card_id */ 1:
                    message.cardId = reader.uint32();
                    break;
                case /* optional uint32 card_index */ 4:
                    message.cardIndex = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChessPickCardReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 card_id = 1; */
        if (message.cardId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.cardId);
        /* optional uint32 card_index = 4; */
        if (message.cardIndex !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.cardIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.ChessPickCardReq
 */
export const ChessPickCardReq = new ChessPickCardReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChessPickCardRsp$Type extends MessageType<ChessPickCardRsp> {
    constructor() {
        super("com.midnights.game.ChessPickCardRsp", [
            { no: 11, name: "card_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "card_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "retcode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ChessPickCardRsp>): ChessPickCardRsp {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChessPickCardRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChessPickCardRsp): ChessPickCardRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 card_index */ 11:
                    message.cardIndex = reader.uint32();
                    break;
                case /* optional uint32 card_id */ 1:
                    message.cardId = reader.uint32();
                    break;
                case /* optional int32 retcode */ 4:
                    message.retcode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChessPickCardRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 card_index = 11; */
        if (message.cardIndex !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.cardIndex);
        /* optional uint32 card_id = 1; */
        if (message.cardId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.cardId);
        /* optional int32 retcode = 4; */
        if (message.retcode !== undefined)
            writer.tag(4, WireType.Varint).int32(message.retcode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.ChessPickCardRsp
 */
export const ChessPickCardRsp = new ChessPickCardRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChessPickCardNotify$Type extends MessageType<ChessPickCardNotify> {
    constructor() {
        super("com.midnights.game.ChessPickCardNotify", [
            { no: 13, name: "curse_card_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "normal_card_info", kind: "message", T: () => ChessNormalCardInfo }
        ]);
    }
    create(value?: PartialMessage<ChessPickCardNotify>): ChessPickCardNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChessPickCardNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChessPickCardNotify): ChessPickCardNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 curse_card_id */ 13:
                    message.curseCardId = reader.uint32();
                    break;
                case /* optional com.midnights.game.ChessNormalCardInfo normal_card_info */ 1:
                    message.normalCardInfo = ChessNormalCardInfo.internalBinaryRead(reader, reader.uint32(), options, message.normalCardInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChessPickCardNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 curse_card_id = 13; */
        if (message.curseCardId !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.curseCardId);
        /* optional com.midnights.game.ChessNormalCardInfo normal_card_info = 1; */
        if (message.normalCardInfo)
            ChessNormalCardInfo.internalBinaryWrite(message.normalCardInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.ChessPickCardNotify
 */
export const ChessPickCardNotify = new ChessPickCardNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChessManualRefreshCardsReq$Type extends MessageType<ChessManualRefreshCardsReq> {
    constructor() {
        super("com.midnights.game.ChessManualRefreshCardsReq", []);
    }
    create(value?: PartialMessage<ChessManualRefreshCardsReq>): ChessManualRefreshCardsReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChessManualRefreshCardsReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChessManualRefreshCardsReq): ChessManualRefreshCardsReq {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ChessManualRefreshCardsReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.ChessManualRefreshCardsReq
 */
export const ChessManualRefreshCardsReq = new ChessManualRefreshCardsReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChessManualRefreshCardsRsp$Type extends MessageType<ChessManualRefreshCardsRsp> {
    constructor() {
        super("com.midnights.game.ChessManualRefreshCardsRsp", [
            { no: 12, name: "retcode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ChessManualRefreshCardsRsp>): ChessManualRefreshCardsRsp {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChessManualRefreshCardsRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChessManualRefreshCardsRsp): ChessManualRefreshCardsRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 retcode */ 12:
                    message.retcode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChessManualRefreshCardsRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 retcode = 12; */
        if (message.retcode !== undefined)
            writer.tag(12, WireType.Varint).int32(message.retcode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.ChessManualRefreshCardsRsp
 */
export const ChessManualRefreshCardsRsp = new ChessManualRefreshCardsRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChessPlayerInfoNotify$Type extends MessageType<ChessPlayerInfoNotify> {
    constructor() {
        super("com.midnights.game.ChessPlayerInfoNotify", [
            { no: 10, name: "player_info", kind: "message", T: () => ChessPlayerInfo }
        ]);
    }
    create(value?: PartialMessage<ChessPlayerInfoNotify>): ChessPlayerInfoNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChessPlayerInfoNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChessPlayerInfoNotify): ChessPlayerInfoNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.ChessPlayerInfo player_info */ 10:
                    message.playerInfo = ChessPlayerInfo.internalBinaryRead(reader, reader.uint32(), options, message.playerInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChessPlayerInfoNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.ChessPlayerInfo player_info = 10; */
        if (message.playerInfo)
            ChessPlayerInfo.internalBinaryWrite(message.playerInfo, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.ChessPlayerInfoNotify
 */
export const ChessPlayerInfoNotify = new ChessPlayerInfoNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChessLeftMonstersNotify$Type extends MessageType<ChessLeftMonstersNotify> {
    constructor() {
        super("com.midnights.game.ChessLeftMonstersNotify", [
            { no: 6, name: "left_monsters", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ChessLeftMonstersNotify>): ChessLeftMonstersNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChessLeftMonstersNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChessLeftMonstersNotify): ChessLeftMonstersNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 left_monsters */ 6:
                    message.leftMonsters = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChessLeftMonstersNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 left_monsters = 6; */
        if (message.leftMonsters !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.leftMonsters);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.ChessLeftMonstersNotify
 */
export const ChessLeftMonstersNotify = new ChessLeftMonstersNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChessEscapedMonstersNotify$Type extends MessageType<ChessEscapedMonstersNotify> {
    constructor() {
        super("com.midnights.game.ChessEscapedMonstersNotify", [
            { no: 14, name: "excaped_monsters", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ChessEscapedMonstersNotify>): ChessEscapedMonstersNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChessEscapedMonstersNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChessEscapedMonstersNotify): ChessEscapedMonstersNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 excaped_monsters */ 14:
                    message.excapedMonsters = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChessEscapedMonstersNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 excaped_monsters = 14; */
        if (message.excapedMonsters !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.excapedMonsters);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.ChessEscapedMonstersNotify
 */
export const ChessEscapedMonstersNotify = new ChessEscapedMonstersNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChessSelectedCardsNotify$Type extends MessageType<ChessSelectedCardsNotify> {
    constructor() {
        super("com.midnights.game.ChessSelectedCardsNotify", [
            { no: 4, name: "selected_card_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ChessCardInfo }
        ]);
    }
    create(value?: PartialMessage<ChessSelectedCardsNotify>): ChessSelectedCardsNotify {
        const message = { selectedCardInfoList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChessSelectedCardsNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChessSelectedCardsNotify): ChessSelectedCardsNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated com.midnights.game.ChessCardInfo selected_card_info_list */ 4:
                    message.selectedCardInfoList.push(ChessCardInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChessSelectedCardsNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated com.midnights.game.ChessCardInfo selected_card_info_list = 4; */
        for (let i = 0; i < message.selectedCardInfoList.length; i++)
            ChessCardInfo.internalBinaryWrite(message.selectedCardInfoList[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.ChessSelectedCardsNotify
 */
export const ChessSelectedCardsNotify = new ChessSelectedCardsNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GlobalBuildingInfoNotify$Type extends MessageType<GlobalBuildingInfoNotify> {
    constructor() {
        super("com.midnights.game.GlobalBuildingInfoNotify", [
            { no: 5, name: "current_num", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "building_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BuildingInfo },
            { no: 13, name: "max_num", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GlobalBuildingInfoNotify>): GlobalBuildingInfoNotify {
        const message = { buildingList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GlobalBuildingInfoNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GlobalBuildingInfoNotify): GlobalBuildingInfoNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 current_num */ 5:
                    message.currentNum = reader.uint32();
                    break;
                case /* repeated com.midnights.game.BuildingInfo building_list */ 3:
                    message.buildingList.push(BuildingInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 max_num */ 13:
                    message.maxNum = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GlobalBuildingInfoNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 current_num = 5; */
        if (message.currentNum !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.currentNum);
        /* repeated com.midnights.game.BuildingInfo building_list = 3; */
        for (let i = 0; i < message.buildingList.length; i++)
            BuildingInfo.internalBinaryWrite(message.buildingList[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 max_num = 13; */
        if (message.maxNum !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.maxNum);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GlobalBuildingInfoNotify
 */
export const GlobalBuildingInfoNotify = new GlobalBuildingInfoNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InBattleIrodoriChessInfo$Type extends MessageType<InBattleIrodoriChessInfo> {
    constructor() {
        super("com.midnights.game.InBattleIrodoriChessInfo", [
            { no: 3, name: "mystery_info", kind: "message", T: () => IrodoriChessMysteryInfo },
            { no: 12, name: "left_monsters", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "selected_card_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "building_points", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "settle_score", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<InBattleIrodoriChessInfo>): InBattleIrodoriChessInfo {
        const message = { selectedCardIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InBattleIrodoriChessInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InBattleIrodoriChessInfo): InBattleIrodoriChessInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.IrodoriChessMysteryInfo mystery_info */ 3:
                    message.mysteryInfo = IrodoriChessMysteryInfo.internalBinaryRead(reader, reader.uint32(), options, message.mysteryInfo);
                    break;
                case /* optional uint32 left_monsters */ 12:
                    message.leftMonsters = reader.uint32();
                    break;
                case /* repeated uint32 selected_card_id_list */ 13:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.selectedCardIdList.push(reader.uint32());
                    else
                        message.selectedCardIdList.push(reader.uint32());
                    break;
                case /* optional uint32 building_points */ 7:
                    message.buildingPoints = reader.uint32();
                    break;
                case /* optional uint32 settle_score */ 4:
                    message.settleScore = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InBattleIrodoriChessInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.IrodoriChessMysteryInfo mystery_info = 3; */
        if (message.mysteryInfo)
            IrodoriChessMysteryInfo.internalBinaryWrite(message.mysteryInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 left_monsters = 12; */
        if (message.leftMonsters !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.leftMonsters);
        /* repeated uint32 selected_card_id_list = 13; */
        if (message.selectedCardIdList.length) {
            writer.tag(13, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.selectedCardIdList.length; i++)
                writer.uint32(message.selectedCardIdList[i]);
            writer.join();
        }
        /* optional uint32 building_points = 7; */
        if (message.buildingPoints !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.buildingPoints);
        /* optional uint32 settle_score = 4; */
        if (message.settleScore !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.settleScore);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.InBattleIrodoriChessInfo
 */
export const InBattleIrodoriChessInfo = new InBattleIrodoriChessInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IrodoriChessMonsterInfo$Type extends MessageType<IrodoriChessMonsterInfo> {
    constructor() {
        super("com.midnights.game.IrodoriChessMonsterInfo", [
            { no: 6, name: "grant_points", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "level", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "monster_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "affix_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<IrodoriChessMonsterInfo>): IrodoriChessMonsterInfo {
        const message = { affixList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IrodoriChessMonsterInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IrodoriChessMonsterInfo): IrodoriChessMonsterInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 grant_points */ 6:
                    message.grantPoints = reader.uint32();
                    break;
                case /* optional uint32 level */ 13:
                    message.level = reader.uint32();
                    break;
                case /* optional uint32 monster_id */ 14:
                    message.monsterId = reader.uint32();
                    break;
                case /* repeated uint32 affix_list */ 11:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.affixList.push(reader.uint32());
                    else
                        message.affixList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IrodoriChessMonsterInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 grant_points = 6; */
        if (message.grantPoints !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.grantPoints);
        /* optional uint32 level = 13; */
        if (message.level !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.level);
        /* optional uint32 monster_id = 14; */
        if (message.monsterId !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.monsterId);
        /* repeated uint32 affix_list = 11; */
        if (message.affixList.length) {
            writer.tag(11, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.affixList.length; i++)
                writer.uint32(message.affixList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.IrodoriChessMonsterInfo
 */
export const IrodoriChessMonsterInfo = new IrodoriChessMonsterInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IrodoriChessEntranceInfo$Type extends MessageType<IrodoriChessEntranceInfo> {
    constructor() {
        super("com.midnights.game.IrodoriChessEntranceInfo", [
            { no: 6, name: "monster_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => IrodoriChessMonsterInfo },
            { no: 4, name: "entrance_point_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<IrodoriChessEntranceInfo>): IrodoriChessEntranceInfo {
        const message = { monsterInfoList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IrodoriChessEntranceInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IrodoriChessEntranceInfo): IrodoriChessEntranceInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated com.midnights.game.IrodoriChessMonsterInfo monster_info_list */ 6:
                    message.monsterInfoList.push(IrodoriChessMonsterInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 entrance_point_id */ 4:
                    message.entrancePointId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IrodoriChessEntranceInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated com.midnights.game.IrodoriChessMonsterInfo monster_info_list = 6; */
        for (let i = 0; i < message.monsterInfoList.length; i++)
            IrodoriChessMonsterInfo.internalBinaryWrite(message.monsterInfoList[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 entrance_point_id = 4; */
        if (message.entrancePointId !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.entrancePointId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.IrodoriChessEntranceInfo
 */
export const IrodoriChessEntranceInfo = new IrodoriChessEntranceInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IrodoriChessEntranceDetailInfo$Type extends MessageType<IrodoriChessEntranceDetailInfo> {
    constructor() {
        super("com.midnights.game.IrodoriChessEntranceDetailInfo", [
            { no: 15, name: "info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => IrodoriChessEntranceInfo }
        ]);
    }
    create(value?: PartialMessage<IrodoriChessEntranceDetailInfo>): IrodoriChessEntranceDetailInfo {
        const message = { infoList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IrodoriChessEntranceDetailInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IrodoriChessEntranceDetailInfo): IrodoriChessEntranceDetailInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated com.midnights.game.IrodoriChessEntranceInfo info_list */ 15:
                    message.infoList.push(IrodoriChessEntranceInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IrodoriChessEntranceDetailInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated com.midnights.game.IrodoriChessEntranceInfo info_list = 15; */
        for (let i = 0; i < message.infoList.length; i++)
            IrodoriChessEntranceInfo.internalBinaryWrite(message.infoList[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.IrodoriChessEntranceDetailInfo
 */
export const IrodoriChessEntranceDetailInfo = new IrodoriChessEntranceDetailInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IrodoriChessMysteryInfo$Type extends MessageType<IrodoriChessMysteryInfo> {
    constructor() {
        super("com.midnights.game.IrodoriChessMysteryInfo", [
            { no: 5, name: "entrance_detail_info", kind: "message", T: () => IrodoriChessEntranceDetailInfo },
            { no: 2, name: "entrance_point_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "exit_point_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<IrodoriChessMysteryInfo>): IrodoriChessMysteryInfo {
        const message = { entrancePointIdList: [], exitPointIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IrodoriChessMysteryInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IrodoriChessMysteryInfo): IrodoriChessMysteryInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.IrodoriChessEntranceDetailInfo entrance_detail_info */ 5:
                    message.entranceDetailInfo = IrodoriChessEntranceDetailInfo.internalBinaryRead(reader, reader.uint32(), options, message.entranceDetailInfo);
                    break;
                case /* repeated uint32 entrance_point_id_list */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.entrancePointIdList.push(reader.uint32());
                    else
                        message.entrancePointIdList.push(reader.uint32());
                    break;
                case /* repeated uint32 exit_point_id_list */ 13:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.exitPointIdList.push(reader.uint32());
                    else
                        message.exitPointIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IrodoriChessMysteryInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.IrodoriChessEntranceDetailInfo entrance_detail_info = 5; */
        if (message.entranceDetailInfo)
            IrodoriChessEntranceDetailInfo.internalBinaryWrite(message.entranceDetailInfo, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 entrance_point_id_list = 2; */
        if (message.entrancePointIdList.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.entrancePointIdList.length; i++)
                writer.uint32(message.entrancePointIdList[i]);
            writer.join();
        }
        /* repeated uint32 exit_point_id_list = 13; */
        if (message.exitPointIdList.length) {
            writer.tag(13, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.exitPointIdList.length; i++)
                writer.uint32(message.exitPointIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.IrodoriChessMysteryInfo
 */
export const IrodoriChessMysteryInfo = new IrodoriChessMysteryInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InBattleIrodoriChessSettleInfo$Type extends MessageType<InBattleIrodoriChessSettleInfo> {
    constructor() {
        super("com.midnights.game.InBattleIrodoriChessSettleInfo", [
            { no: 5, name: "is_new_record", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "is_activity_end", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 1, name: "scene_time_ms", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "settle_score", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "is_perfect", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "kill_monster_num", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<InBattleIrodoriChessSettleInfo>): InBattleIrodoriChessSettleInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InBattleIrodoriChessSettleInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InBattleIrodoriChessSettleInfo): InBattleIrodoriChessSettleInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool is_new_record */ 5:
                    message.isNewRecord = reader.bool();
                    break;
                case /* optional bool is_activity_end */ 2:
                    message.isActivityEnd = reader.bool();
                    break;
                case /* optional uint64 scene_time_ms */ 1:
                    message.sceneTimeMs = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 settle_score */ 3:
                    message.settleScore = reader.uint32();
                    break;
                case /* optional bool is_perfect */ 12:
                    message.isPerfect = reader.bool();
                    break;
                case /* optional uint32 kill_monster_num */ 7:
                    message.killMonsterNum = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InBattleIrodoriChessSettleInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool is_new_record = 5; */
        if (message.isNewRecord !== undefined)
            writer.tag(5, WireType.Varint).bool(message.isNewRecord);
        /* optional bool is_activity_end = 2; */
        if (message.isActivityEnd !== undefined)
            writer.tag(2, WireType.Varint).bool(message.isActivityEnd);
        /* optional uint64 scene_time_ms = 1; */
        if (message.sceneTimeMs !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.sceneTimeMs);
        /* optional uint32 settle_score = 3; */
        if (message.settleScore !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.settleScore);
        /* optional bool is_perfect = 12; */
        if (message.isPerfect !== undefined)
            writer.tag(12, WireType.Varint).bool(message.isPerfect);
        /* optional uint32 kill_monster_num = 7; */
        if (message.killMonsterNum !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.killMonsterNum);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.InBattleIrodoriChessSettleInfo
 */
export const InBattleIrodoriChessSettleInfo = new InBattleIrodoriChessSettleInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IrodoriChessPlayerInfo$Type extends MessageType<IrodoriChessPlayerInfo> {
    constructor() {
        super("com.midnights.game.IrodoriChessPlayerInfo", [
            { no: 4, name: "uid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "building_points", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "settle_score", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<IrodoriChessPlayerInfo>): IrodoriChessPlayerInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IrodoriChessPlayerInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IrodoriChessPlayerInfo): IrodoriChessPlayerInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 uid */ 4:
                    message.uid = reader.uint32();
                    break;
                case /* optional uint32 building_points */ 9:
                    message.buildingPoints = reader.uint32();
                    break;
                case /* optional uint32 settle_score */ 3:
                    message.settleScore = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IrodoriChessPlayerInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 uid = 4; */
        if (message.uid !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.uid);
        /* optional uint32 building_points = 9; */
        if (message.buildingPoints !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.buildingPoints);
        /* optional uint32 settle_score = 3; */
        if (message.settleScore !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.settleScore);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.IrodoriChessPlayerInfo
 */
export const IrodoriChessPlayerInfo = new IrodoriChessPlayerInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IrodoriChessPlayerInfoNotify$Type extends MessageType<IrodoriChessPlayerInfoNotify> {
    constructor() {
        super("com.midnights.game.IrodoriChessPlayerInfoNotify", [
            { no: 6, name: "player_info", kind: "message", T: () => IrodoriChessPlayerInfo }
        ]);
    }
    create(value?: PartialMessage<IrodoriChessPlayerInfoNotify>): IrodoriChessPlayerInfoNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IrodoriChessPlayerInfoNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IrodoriChessPlayerInfoNotify): IrodoriChessPlayerInfoNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.IrodoriChessPlayerInfo player_info */ 6:
                    message.playerInfo = IrodoriChessPlayerInfo.internalBinaryRead(reader, reader.uint32(), options, message.playerInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IrodoriChessPlayerInfoNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.IrodoriChessPlayerInfo player_info = 6; */
        if (message.playerInfo)
            IrodoriChessPlayerInfo.internalBinaryWrite(message.playerInfo, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.IrodoriChessPlayerInfoNotify
 */
export const IrodoriChessPlayerInfoNotify = new IrodoriChessPlayerInfoNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IrodoriChessLeftMonsterNotify$Type extends MessageType<IrodoriChessLeftMonsterNotify> {
    constructor() {
        super("com.midnights.game.IrodoriChessLeftMonsterNotify", [
            { no: 8, name: "left_monsters", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<IrodoriChessLeftMonsterNotify>): IrodoriChessLeftMonsterNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IrodoriChessLeftMonsterNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IrodoriChessLeftMonsterNotify): IrodoriChessLeftMonsterNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 left_monsters */ 8:
                    message.leftMonsters = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IrodoriChessLeftMonsterNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 left_monsters = 8; */
        if (message.leftMonsters !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.leftMonsters);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.IrodoriChessLeftMonsterNotify
 */
export const IrodoriChessLeftMonsterNotify = new IrodoriChessLeftMonsterNotify$Type();
