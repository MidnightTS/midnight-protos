// @generated by protobuf-ts 2.8.1 with parameter output_typescript
// @generated from protobuf file "cmd_gcg.proto" (package "com.midnights.game", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { GCGLevelType } from "./cmd_gcg_common";
import { ItemParam } from "./define";
import { GCGGameBusinessType } from "./cmd_gcg_common";
import { ProfilePicture } from "./define";
import { GCGEndReason } from "./cmd_gcg_common";
import { GCGClientPerformType } from "./cmd_gcg_common";
import { GCGDiceSideType } from "./cmd_gcg_common";
import { GCGZoneType } from "./cmd_gcg_common";
import { GCGPhaseType } from "./cmd_gcg_common";
import { GCGReason } from "./cmd_gcg_common";
/**
 * @generated from protobuf message com.midnights.game.GCGAttackCostInfo
 */
export interface GCGAttackCostInfo {
    /**
     * @generated from protobuf field: optional uint32 skill_id = 8;
     */
    skillId?: number;
    /**
     * @generated from protobuf field: map<uint32, uint32> cost_map = 3;
     */
    costMap: {
        [key: number]: number;
    };
}
/**
 * @generated from protobuf message com.midnights.game.GCGPlayCardCostInfo
 */
export interface GCGPlayCardCostInfo {
    /**
     * @generated from protobuf field: map<uint32, uint32> cost_map = 14;
     */
    costMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: optional uint32 card_id = 1;
     */
    cardId?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGSelectOnStageCostInfo
 */
export interface GCGSelectOnStageCostInfo {
    /**
     * @generated from protobuf field: map<uint32, uint32> cost_map = 8;
     */
    costMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: optional uint32 card_guid = 9;
     */
    cardGuid?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGCostReviseInfo
 */
export interface GCGCostReviseInfo {
    /**
     * @generated from protobuf field: optional bool is_can_attack = 4;
     */
    isCanAttack?: boolean;
    /**
     * @generated from protobuf field: repeated uint32 can_use_hand_card_id_list = 11;
     */
    canUseHandCardIdList: number[];
    /**
     * @generated from protobuf field: repeated com.midnights.game.GCGPlayCardCostInfo play_card_cost_list = 5;
     */
    playCardCostList: GCGPlayCardCostInfo[];
    /**
     * @generated from protobuf field: repeated com.midnights.game.GCGSelectOnStageCostInfo select_on_stage_cost_list = 10;
     */
    selectOnStageCostList: GCGSelectOnStageCostInfo[];
    /**
     * @generated from protobuf field: repeated com.midnights.game.GCGAttackCostInfo attack_cost_list = 2;
     */
    attackCostList: GCGAttackCostInfo[];
}
/**
 * @generated from protobuf message com.midnights.game.GCGMsgTokenChange
 */
export interface GCGMsgTokenChange {
    /**
     * @generated from protobuf field: optional uint32 before = 13;
     */
    before?: number;
    /**
     * @generated from protobuf field: optional uint32 token_type = 4;
     */
    tokenType?: number;
    /**
     * @generated from protobuf field: optional uint32 card_guid = 2;
     */
    cardGuid?: number;
    /**
     * @generated from protobuf field: optional uint32 after = 11;
     */
    after?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGReason reason = 7;
     */
    reason?: GCGReason;
}
/**
 * @generated from protobuf message com.midnights.game.GCGMsgPhaseChange
 */
export interface GCGMsgPhaseChange {
    /**
     * @generated from protobuf field: map<uint32, uint32> allow_controller_map = 15;
     */
    allowControllerMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGPhaseType before_phase = 12;
     */
    beforePhase?: GCGPhaseType;
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGPhaseType after_phase = 5;
     */
    afterPhase?: GCGPhaseType;
}
/**
 * @generated from protobuf message com.midnights.game.GCGMsgAddCards
 */
export interface GCGMsgAddCards {
    /**
     * @generated from protobuf field: optional uint32 pos = 11;
     */
    pos?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGZoneType zone = 2;
     */
    zone?: GCGZoneType;
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGReason reason = 15;
     */
    reason?: GCGReason;
    /**
     * @generated from protobuf field: optional uint32 controller_id = 13;
     */
    controllerId?: number;
    /**
     * @generated from protobuf field: repeated uint32 card_guid_list = 14;
     */
    cardGuidList: number[];
}
/**
 * @generated from protobuf message com.midnights.game.GCGMsgRemoveCards
 */
export interface GCGMsgRemoveCards {
    /**
     * @generated from protobuf field: optional uint32 controller_id = 15;
     */
    controllerId?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGZoneType zone = 10;
     */
    zone?: GCGZoneType;
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGReason reason = 5;
     */
    reason?: GCGReason;
    /**
     * @generated from protobuf field: repeated uint32 card_guid_list = 1;
     */
    cardGuidList: number[];
}
/**
 * @generated from protobuf message com.midnights.game.GCGMsgMoveCard
 */
export interface GCGMsgMoveCard {
    /**
     * @generated from protobuf field: optional uint32 controller_id = 14;
     */
    controllerId?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGZoneType to = 5;
     */
    to?: GCGZoneType;
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGZoneType from = 12;
     */
    from?: GCGZoneType;
    /**
     * @generated from protobuf field: optional bool is_fail = 10;
     */
    isFail?: boolean;
    /**
     * @generated from protobuf field: optional uint32 card_guid = 7;
     */
    cardGuid?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGReason reason = 6;
     */
    reason?: GCGReason;
}
/**
 * @generated from protobuf message com.midnights.game.GCGMsgSelectOnStage
 */
export interface GCGMsgSelectOnStage {
    /**
     * @generated from protobuf field: optional uint32 controller_id = 6;
     */
    controllerId?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGReason reason = 10;
     */
    reason?: GCGReason;
    /**
     * @generated from protobuf field: optional uint32 card_guid = 4;
     */
    cardGuid?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGMsgSelectOnStageByEffect
 */
export interface GCGMsgSelectOnStageByEffect {
    /**
     * @generated from protobuf field: optional uint32 skill_id = 12;
     */
    skillId?: number;
    /**
     * @generated from protobuf field: optional uint32 controller_id = 15;
     */
    controllerId?: number;
    /**
     * @generated from protobuf field: optional uint32 card_guid = 1;
     */
    cardGuid?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGMsgDiceRoll
 */
export interface GCGMsgDiceRoll {
    /**
     * @generated from protobuf field: repeated com.midnights.game.GCGDiceSideType dice_side_list = 10;
     */
    diceSideList: GCGDiceSideType[];
    /**
     * @generated from protobuf field: optional uint32 dice_num = 15;
     */
    diceNum?: number;
    /**
     * @generated from protobuf field: optional uint32 controller_id = 5;
     */
    controllerId?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGMsgDiceReroll
 */
export interface GCGMsgDiceReroll {
    /**
     * @generated from protobuf field: optional uint32 controller_id = 2;
     */
    controllerId?: number;
    /**
     * @generated from protobuf field: repeated uint32 select_dice_index_list = 1;
     */
    selectDiceIndexList: number[];
    /**
     * @generated from protobuf field: repeated com.midnights.game.GCGDiceSideType dice_side_list = 6;
     */
    diceSideList: GCGDiceSideType[];
}
/**
 * @generated from protobuf message com.midnights.game.GCGMsgPass
 */
export interface GCGMsgPass {
    /**
     * @generated from protobuf field: optional uint32 controller_id = 14;
     */
    controllerId?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGMsgCharDie
 */
export interface GCGMsgCharDie {
    /**
     * @generated from protobuf field: optional uint32 controller_id = 5;
     */
    controllerId?: number;
    /**
     * @generated from protobuf field: optional uint32 card_guid = 11;
     */
    cardGuid?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGMsgUseSkill
 */
export interface GCGMsgUseSkill {
    /**
     * @generated from protobuf field: optional uint32 skill_id = 9;
     */
    skillId?: number;
    /**
     * @generated from protobuf field: optional uint32 card_guid = 6;
     */
    cardGuid?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGMsgUseSkillEnd
 */
export interface GCGMsgUseSkillEnd {
    /**
     * @generated from protobuf field: optional uint32 card_guid = 11;
     */
    cardGuid?: number;
    /**
     * @generated from protobuf field: optional uint32 skill_id = 12;
     */
    skillId?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGDamageDetail
 */
export interface GCGDamageDetail {
    /**
     * @generated from protobuf field: optional uint32 skill_id = 10;
     */
    skillId?: number;
    /**
     * @generated from protobuf field: optional uint32 card_guid = 7;
     */
    cardGuid?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGMsgSkillResult
 */
export interface GCGMsgSkillResult {
    /**
     * @generated from protobuf field: optional uint32 skill_id = 12;
     */
    skillId?: number;
    /**
     * @generated from protobuf field: optional uint32 last_hp = 14;
     */
    lastHp?: number;
    /**
     * @generated from protobuf field: repeated com.midnights.game.GCGDamageDetail detail_list = 2;
     */
    detailList: GCGDamageDetail[];
    /**
     * @generated from protobuf field: optional uint32 target_card_guid = 7;
     */
    targetCardGuid?: number;
    /**
     * @generated from protobuf field: optional uint32 effect_element = 5;
     */
    effectElement?: number;
    /**
     * @generated from protobuf field: optional uint32 from_result_seq = 15;
     */
    fromResultSeq?: number;
    /**
     * @generated from protobuf field: optional uint32 damage = 6;
     */
    damage?: number;
    /**
     * @generated from protobuf field: optional uint32 result_seq = 4;
     */
    resultSeq?: number;
    /**
     * @generated from protobuf field: optional uint32 src_card_guid = 8;
     */
    srcCardGuid?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGMsgCostDice
 */
export interface GCGMsgCostDice {
    /**
     * @generated from protobuf field: optional uint32 controller_id = 6;
     */
    controllerId?: number;
    /**
     * @generated from protobuf field: repeated uint32 select_dice_index_list = 13;
     */
    selectDiceIndexList: number[];
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGReason reason = 9;
     */
    reason?: GCGReason;
}
/**
 * @generated from protobuf message com.midnights.game.GCGMsgAddDice
 */
export interface GCGMsgAddDice {
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGReason reason = 4;
     */
    reason?: GCGReason;
    /**
     * @generated from protobuf field: optional uint32 controller_id = 10;
     */
    controllerId?: number;
    /**
     * @generated from protobuf field: optional int32 change_count = 1;
     */
    changeCount?: number;
    /**
     * @generated from protobuf field: map<uint32, com.midnights.game.GCGDiceSideType> dice_map = 8;
     */
    diceMap: {
        [key: number]: GCGDiceSideType;
    };
}
/**
 * @generated from protobuf message com.midnights.game.GCGMsgNewCard
 */
export interface GCGMsgNewCard {
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGCard card = 15;
     */
    card?: GCGCard;
}
/**
 * @generated from protobuf message com.midnights.game.GCGMsgUpdateController
 */
export interface GCGMsgUpdateController {
    /**
     * @generated from protobuf field: map<uint32, uint32> allow_controller_map = 7;
     */
    allowControllerMap: {
        [key: number]: number;
    };
}
/**
 * @generated from protobuf message com.midnights.game.GCGMsgModifyAdd
 */
export interface GCGMsgModifyAdd {
    /**
     * @generated from protobuf field: optional uint32 pos = 9;
     */
    pos?: number;
    /**
     * @generated from protobuf field: optional uint32 owner_card_guid = 10;
     */
    ownerCardGuid?: number;
    /**
     * @generated from protobuf field: repeated uint32 card_guid_list = 15;
     */
    cardGuidList: number[];
    /**
     * @generated from protobuf field: optional uint32 controller_id = 14;
     */
    controllerId?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGReason reason = 11;
     */
    reason?: GCGReason;
}
/**
 * @generated from protobuf message com.midnights.game.GCGMsgModifyRemove
 */
export interface GCGMsgModifyRemove {
    /**
     * @generated from protobuf field: optional uint32 controller_id = 14;
     */
    controllerId?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGReason reason = 12;
     */
    reason?: GCGReason;
    /**
     * @generated from protobuf field: optional uint32 owner_card_guid = 5;
     */
    ownerCardGuid?: number;
    /**
     * @generated from protobuf field: repeated uint32 card_guid_list = 4;
     */
    cardGuidList: number[];
}
/**
 * @generated from protobuf message com.midnights.game.GCGMsgPVEGenCardOp
 */
export interface GCGMsgPVEGenCardOp {
    /**
     * @generated from protobuf field: repeated uint32 skill_id_list = 1;
     */
    skillIdList: number[];
    /**
     * @generated from protobuf field: optional uint32 card_guid = 11;
     */
    cardGuid?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGMsgPVEDoOp
 */
export interface GCGMsgPVEDoOp {
    /**
     * @generated from protobuf field: optional uint32 skill_id = 4;
     */
    skillId?: number;
    /**
     * @generated from protobuf field: optional uint32 card_guid = 10;
     */
    cardGuid?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGMsgDuelDataChange
 */
export interface GCGMsgDuelDataChange {
    /**
     * @generated from protobuf field: optional uint32 round = 14;
     */
    round?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGMsgClientPerform
 */
export interface GCGMsgClientPerform {
    /**
     * @generated from protobuf field: repeated uint32 param_list = 2;
     */
    paramList: number[];
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGClientPerformType perform_type = 5;
     */
    performType?: GCGClientPerformType;
}
/**
 * @generated from protobuf message com.midnights.game.GCGMsgGameOver
 */
export interface GCGMsgGameOver {
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGEndReason end_reason = 13;
     */
    endReason?: GCGEndReason;
    /**
     * @generated from protobuf field: optional uint32 win_controller_id = 6;
     */
    winControllerId?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGMsgOpTimer
 */
export interface GCGMsgOpTimer {
    /**
     * @generated from protobuf field: optional fixed64 begin_time = 9;
     */
    beginTime?: bigint;
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGPhaseType phase = 3;
     */
    phase?: GCGPhaseType;
    /**
     * @generated from protobuf field: optional fixed64 time_stamp = 13;
     */
    timeStamp?: bigint;
    /**
     * @generated from protobuf field: optional uint32 controller_id = 8;
     */
    controllerId?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGMsgWaitingListChange
 */
export interface GCGMsgWaitingListChange {
    /**
     * @generated from protobuf field: optional uint32 cur_index = 6;
     */
    curIndex?: number;
    /**
     * @generated from protobuf field: optional uint32 controller_id = 4;
     */
    controllerId?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGMsgCardUpdate
 */
export interface GCGMsgCardUpdate {
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGCard card = 7;
     */
    card?: GCGCard;
}
/**
 * @generated from protobuf message com.midnights.game.GCGMsgCostRevise
 */
export interface GCGMsgCostRevise {
    /**
     * @generated from protobuf field: optional uint32 controller_id = 5;
     */
    controllerId?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGCostReviseInfo cost_revise = 13;
     */
    costRevise?: GCGCostReviseInfo;
}
/**
 * @generated from protobuf message com.midnights.game.GCGMessage
 */
export interface GCGMessage {
    /**
     * @generated from protobuf oneof: message
     */
    message: {
        oneofKind: "tokenChange";
        /**
         * @generated from protobuf field: com.midnights.game.GCGMsgTokenChange token_change = 12;
         */
        tokenChange: GCGMsgTokenChange;
    } | {
        oneofKind: "phaseChange";
        /**
         * @generated from protobuf field: com.midnights.game.GCGMsgPhaseChange phase_change = 13;
         */
        phaseChange: GCGMsgPhaseChange;
    } | {
        oneofKind: "addCards";
        /**
         * @generated from protobuf field: com.midnights.game.GCGMsgAddCards add_cards = 10;
         */
        addCards: GCGMsgAddCards;
    } | {
        oneofKind: "removeCards";
        /**
         * @generated from protobuf field: com.midnights.game.GCGMsgRemoveCards remove_cards = 14;
         */
        removeCards: GCGMsgRemoveCards;
    } | {
        oneofKind: "selectOnStage";
        /**
         * @generated from protobuf field: com.midnights.game.GCGMsgSelectOnStage select_on_stage = 6;
         */
        selectOnStage: GCGMsgSelectOnStage;
    } | {
        oneofKind: "diceRoll";
        /**
         * @generated from protobuf field: com.midnights.game.GCGMsgDiceRoll dice_roll = 9;
         */
        diceRoll: GCGMsgDiceRoll;
    } | {
        oneofKind: "diceReroll";
        /**
         * @generated from protobuf field: com.midnights.game.GCGMsgDiceReroll dice_reroll = 11;
         */
        diceReroll: GCGMsgDiceReroll;
    } | {
        oneofKind: "pass";
        /**
         * @generated from protobuf field: com.midnights.game.GCGMsgPass pass = 5;
         */
        pass: GCGMsgPass;
    } | {
        oneofKind: "charDie";
        /**
         * @generated from protobuf field: com.midnights.game.GCGMsgCharDie char_die = 2;
         */
        charDie: GCGMsgCharDie;
    } | {
        oneofKind: "skillResult";
        /**
         * @generated from protobuf field: com.midnights.game.GCGMsgSkillResult skill_result = 1;
         */
        skillResult: GCGMsgSkillResult;
    } | {
        oneofKind: "costDice";
        /**
         * @generated from protobuf field: com.midnights.game.GCGMsgCostDice cost_dice = 7;
         */
        costDice: GCGMsgCostDice;
    } | {
        oneofKind: "addDice";
        /**
         * @generated from protobuf field: com.midnights.game.GCGMsgAddDice add_dice = 3;
         */
        addDice: GCGMsgAddDice;
    } | {
        oneofKind: "moveCard";
        /**
         * @generated from protobuf field: com.midnights.game.GCGMsgMoveCard move_card = 15;
         */
        moveCard: GCGMsgMoveCard;
    } | {
        oneofKind: "useSkill";
        /**
         * @generated from protobuf field: com.midnights.game.GCGMsgUseSkill use_skill = 4;
         */
        useSkill: GCGMsgUseSkill;
    } | {
        oneofKind: "newCard";
        /**
         * @generated from protobuf field: com.midnights.game.GCGMsgNewCard new_card = 1848;
         */
        newCard: GCGMsgNewCard;
    } | {
        oneofKind: "updateController";
        /**
         * @generated from protobuf field: com.midnights.game.GCGMsgUpdateController update_controller = 429;
         */
        updateController: GCGMsgUpdateController;
    } | {
        oneofKind: "modifyAdd";
        /**
         * @generated from protobuf field: com.midnights.game.GCGMsgModifyAdd modify_add = 1851;
         */
        modifyAdd: GCGMsgModifyAdd;
    } | {
        oneofKind: "modifyRemove";
        /**
         * @generated from protobuf field: com.midnights.game.GCGMsgModifyRemove modify_remove = 471;
         */
        modifyRemove: GCGMsgModifyRemove;
    } | {
        oneofKind: "useSkillEnd";
        /**
         * @generated from protobuf field: com.midnights.game.GCGMsgUseSkillEnd use_skill_end = 1411;
         */
        useSkillEnd: GCGMsgUseSkillEnd;
    } | {
        oneofKind: "pveGenCardOp";
        /**
         * @generated from protobuf field: com.midnights.game.GCGMsgPVEGenCardOp pve_gen_card_op = 1741;
         */
        pveGenCardOp: GCGMsgPVEGenCardOp;
    } | {
        oneofKind: "pveDoOp";
        /**
         * @generated from protobuf field: com.midnights.game.GCGMsgPVEDoOp pve_do_op = 614;
         */
        pveDoOp: GCGMsgPVEDoOp;
    } | {
        oneofKind: "duelDataChange";
        /**
         * @generated from protobuf field: com.midnights.game.GCGMsgDuelDataChange duel_data_change = 1008;
         */
        duelDataChange: GCGMsgDuelDataChange;
    } | {
        oneofKind: "clientPerform";
        /**
         * @generated from protobuf field: com.midnights.game.GCGMsgClientPerform client_perform = 1035;
         */
        clientPerform: GCGMsgClientPerform;
    } | {
        oneofKind: "gameOver";
        /**
         * @generated from protobuf field: com.midnights.game.GCGMsgGameOver game_over = 714;
         */
        gameOver: GCGMsgGameOver;
    } | {
        oneofKind: "opTimer";
        /**
         * @generated from protobuf field: com.midnights.game.GCGMsgOpTimer op_timer = 1862;
         */
        opTimer: GCGMsgOpTimer;
    } | {
        oneofKind: "waitingListChange";
        /**
         * @generated from protobuf field: com.midnights.game.GCGMsgWaitingListChange waiting_list_change = 1678;
         */
        waitingListChange: GCGMsgWaitingListChange;
    } | {
        oneofKind: "cardUpdate";
        /**
         * @generated from protobuf field: com.midnights.game.GCGMsgCardUpdate card_update = 1879;
         */
        cardUpdate: GCGMsgCardUpdate;
    } | {
        oneofKind: "selectOnStageByEffect";
        /**
         * @generated from protobuf field: com.midnights.game.GCGMsgSelectOnStageByEffect select_on_stage_by_effect = 2042;
         */
        selectOnStageByEffect: GCGMsgSelectOnStageByEffect;
    } | {
        oneofKind: "costRevise";
        /**
         * @generated from protobuf field: com.midnights.game.GCGMsgCostRevise cost_revise = 1350;
         */
        costRevise: GCGMsgCostRevise;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message com.midnights.game.GCGMessagePack
 */
export interface GCGMessagePack {
    /**
     * @generated from protobuf field: optional uint32 msg_seq = 10;
     */
    msgSeq?: number;
    /**
     * @generated from protobuf field: repeated com.midnights.game.GCGMessage msg_list = 13;
     */
    msgList: GCGMessage[];
}
/**
 * @generated from protobuf message com.midnights.game.GCGOperationRedraw
 */
export interface GCGOperationRedraw {
    /**
     * @generated from protobuf field: repeated uint32 card_list = 2;
     */
    cardList: number[];
}
/**
 * @generated from protobuf message com.midnights.game.GCGOperationOnStageSelect
 */
export interface GCGOperationOnStageSelect {
    /**
     * @generated from protobuf field: optional uint32 card_guid = 5;
     */
    cardGuid?: number;
    /**
     * @generated from protobuf field: repeated uint32 cost_dice_index_list = 4;
     */
    costDiceIndexList: number[];
}
/**
 * @generated from protobuf message com.midnights.game.GCGOperationReroll
 */
export interface GCGOperationReroll {
    /**
     * @generated from protobuf field: repeated uint32 dice_index_list = 12;
     */
    diceIndexList: number[];
}
/**
 * @generated from protobuf message com.midnights.game.GCGOperationAttack
 */
export interface GCGOperationAttack {
    /**
     * @generated from protobuf field: repeated uint32 cost_dice_index_list = 8;
     */
    costDiceIndexList: number[];
    /**
     * @generated from protobuf field: optional uint32 skill_id = 2;
     */
    skillId?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGOperationPass
 */
export interface GCGOperationPass {
}
/**
 * @generated from protobuf message com.midnights.game.GCGOperationPlayCard
 */
export interface GCGOperationPlayCard {
    /**
     * @generated from protobuf field: optional uint32 card_guid = 12;
     */
    cardGuid?: number;
    /**
     * @generated from protobuf field: repeated uint32 cost_dice_index_list = 4;
     */
    costDiceIndexList: number[];
    /**
     * @generated from protobuf field: repeated uint32 target_card_guid_list = 10;
     */
    targetCardGuidList: number[];
}
/**
 * @generated from protobuf message com.midnights.game.GCGOperationReboot
 */
export interface GCGOperationReboot {
    /**
     * @generated from protobuf field: repeated uint32 cost_card_guid_list = 7;
     */
    costCardGuidList: number[];
    /**
     * @generated from protobuf field: repeated uint32 dice_index_list = 6;
     */
    diceIndexList: number[];
}
/**
 * @generated from protobuf message com.midnights.game.GCGOperationSurrender
 */
export interface GCGOperationSurrender {
}
/**
 * @generated from protobuf message com.midnights.game.GCGOperation
 */
export interface GCGOperation {
    /**
     * @generated from protobuf oneof: op
     */
    op: {
        oneofKind: "opRedraw";
        /**
         * @generated from protobuf field: com.midnights.game.GCGOperationRedraw op_redraw = 10;
         */
        opRedraw: GCGOperationRedraw;
    } | {
        oneofKind: "opSelectOnStage";
        /**
         * @generated from protobuf field: com.midnights.game.GCGOperationOnStageSelect op_select_on_stage = 4;
         */
        opSelectOnStage: GCGOperationOnStageSelect;
    } | {
        oneofKind: "opReroll";
        /**
         * @generated from protobuf field: com.midnights.game.GCGOperationReroll op_reroll = 9;
         */
        opReroll: GCGOperationReroll;
    } | {
        oneofKind: "opAttack";
        /**
         * @generated from protobuf field: com.midnights.game.GCGOperationAttack op_attack = 11;
         */
        opAttack: GCGOperationAttack;
    } | {
        oneofKind: "opPass";
        /**
         * @generated from protobuf field: com.midnights.game.GCGOperationPass op_pass = 15;
         */
        opPass: GCGOperationPass;
    } | {
        oneofKind: "opPlayCard";
        /**
         * @generated from protobuf field: com.midnights.game.GCGOperationPlayCard op_play_card = 2;
         */
        opPlayCard: GCGOperationPlayCard;
    } | {
        oneofKind: "opReboot";
        /**
         * @generated from protobuf field: com.midnights.game.GCGOperationReboot op_reboot = 5;
         */
        opReboot: GCGOperationReboot;
    } | {
        oneofKind: "opSurrender";
        /**
         * @generated from protobuf field: com.midnights.game.GCGOperationSurrender op_surrender = 1;
         */
        opSurrender: GCGOperationSurrender;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message com.midnights.game.GCGOperationData
 */
export interface GCGOperationData {
    /**
     * @generated from protobuf field: optional uint32 controller_id = 2;
     */
    controllerId?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGOperation op = 12;
     */
    op?: GCGOperation;
}
/**
 * @generated from protobuf message com.midnights.game.GCGOperationReplay
 */
export interface GCGOperationReplay {
    /**
     * @generated from protobuf field: optional uint32 game_id = 1;
     */
    gameId?: number;
    /**
     * @generated from protobuf field: optional uint32 seed = 11;
     */
    seed?: number;
    /**
     * @generated from protobuf field: repeated com.midnights.game.GCGOperationData operation_data_list = 9;
     */
    operationDataList: GCGOperationData[];
}
/**
 * @generated from protobuf message com.midnights.game.GCGToken
 */
export interface GCGToken {
    /**
     * @generated from protobuf field: optional uint32 value = 11;
     */
    value?: number;
    /**
     * @generated from protobuf field: optional uint32 key = 4;
     */
    key?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGCard
 */
export interface GCGCard {
    /**
     * @generated from protobuf field: optional uint32 guid = 15;
     */
    guid?: number;
    /**
     * @generated from protobuf field: repeated com.midnights.game.GCGToken token_list = 2;
     */
    tokenList: GCGToken[];
    /**
     * @generated from protobuf field: optional bool is_show = 14;
     */
    isShow?: boolean;
    /**
     * @generated from protobuf field: optional uint32 controller_id = 7;
     */
    controllerId?: number;
    /**
     * @generated from protobuf field: optional uint32 id = 6;
     */
    id?: number;
    /**
     * @generated from protobuf field: repeated uint32 tag_list = 3;
     */
    tagList: number[];
    /**
     * @generated from protobuf field: optional uint32 face_type = 5;
     */
    faceType?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGZone
 */
export interface GCGZone {
    /**
     * @generated from protobuf field: repeated uint32 card_list = 4;
     */
    cardList: number[];
}
/**
 * @generated from protobuf message com.midnights.game.GCGWaitingCharacter
 */
export interface GCGWaitingCharacter {
    /**
     * @generated from protobuf field: optional uint32 card_id = 2;
     */
    cardId?: number;
    /**
     * @generated from protobuf field: optional uint32 cond_count = 14;
     */
    condCount?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGPlayerField
 */
export interface GCGPlayerField {
    /**
     * @generated from protobuf field: map<uint32, com.midnights.game.GCGZone> modify_zone_map = 2;
     */
    modifyZoneMap: {
        [key: number]: GCGZone;
    };
    /**
     * @generated from protobuf field: optional uint32 cur_waiting_index = 383;
     */
    curWaitingIndex?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGZone summon_zone = 1;
     */
    summonZone?: GCGZone;
    /**
     * @generated from protobuf field: optional uint32 field_show_id = 8;
     */
    fieldShowId?: number;
    /**
     * @generated from protobuf field: optional uint32 card_back_show_id = 12;
     */
    cardBackShowId?: number;
    /**
     * @generated from protobuf field: optional uint32 dice_count = 3;
     */
    diceCount?: number;
    /**
     * @generated from protobuf field: optional uint32 controller_id = 10;
     */
    controllerId?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGZone on_stage_zone = 14;
     */
    onStageZone?: GCGZone;
    /**
     * @generated from protobuf field: optional bool is_passed = 7;
     */
    isPassed?: boolean;
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGZone character_zone = 5;
     */
    characterZone?: GCGZone;
    /**
     * @generated from protobuf field: optional uint32 on_stage_character_guid = 6;
     */
    onStageCharacterGuid?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGZone assist_zone = 15;
     */
    assistZone?: GCGZone;
    /**
     * @generated from protobuf field: optional uint32 deck_card_num = 13;
     */
    deckCardNum?: number;
    /**
     * @generated from protobuf field: repeated com.midnights.game.GCGDiceSideType dice_side_list = 11;
     */
    diceSideList: GCGDiceSideType[];
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGZone hand_zone = 9;
     */
    handZone?: GCGZone;
    /**
     * @generated from protobuf field: repeated com.midnights.game.GCGPVEIntention intention_list = 1192;
     */
    intentionList: GCGPVEIntention[];
    /**
     * @generated from protobuf field: repeated com.midnights.game.GCGWaitingCharacter waiting_list = 4;
     */
    waitingList: GCGWaitingCharacter[];
}
/**
 * @generated from protobuf message com.midnights.game.GCGPhase
 */
export interface GCGPhase {
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGPhaseType phase_type = 5;
     */
    phaseType?: GCGPhaseType;
    /**
     * @generated from protobuf field: map<uint32, uint32> allow_controller_map = 6;
     */
    allowControllerMap: {
        [key: number]: number;
    };
}
/**
 * @generated from protobuf message com.midnights.game.GCGControllerShowInfo
 */
export interface GCGControllerShowInfo {
    /**
     * @generated from protobuf field: optional com.midnights.game.ProfilePicture profile_picture = 11;
     */
    profilePicture?: ProfilePicture;
    /**
     * @generated from protobuf field: optional string nick_name = 14;
     */
    nickName?: string;
    /**
     * @generated from protobuf field: optional uint32 controller_id = 9;
     */
    controllerId?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGPVEIntention
 */
export interface GCGPVEIntention {
    /**
     * @generated from protobuf field: optional uint32 card_guid = 9;
     */
    cardGuid?: number;
    /**
     * @generated from protobuf field: repeated uint32 skill_id_list = 7;
     */
    skillIdList: number[];
}
/**
 * @generated from protobuf message com.midnights.game.GCGDuelChallenge
 */
export interface GCGDuelChallenge {
    /**
     * @generated from protobuf field: optional uint32 total_progress = 7;
     */
    totalProgress?: number;
    /**
     * @generated from protobuf field: optional uint32 challenge_id = 10;
     */
    challengeId?: number;
    /**
     * @generated from protobuf field: optional uint32 cur_progress = 12;
     */
    curProgress?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGDuel
 */
export interface GCGDuel {
    /**
     * @generated from protobuf field: optional uint32 server_seq = 3;
     */
    serverSeq?: number;
    /**
     * @generated from protobuf field: repeated com.midnights.game.GCGPlayerField field_list = 7;
     */
    fieldList: GCGPlayerField[];
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGGameBusinessType business_type = 14;
     */
    businessType?: GCGGameBusinessType;
    /**
     * @generated from protobuf field: repeated com.midnights.game.GCGDuelChallenge challenge_list = 5;
     */
    challengeList: GCGDuelChallenge[];
    /**
     * @generated from protobuf field: optional uint32 game_id = 11;
     */
    gameId?: number;
    /**
     * @generated from protobuf field: optional uint32 controller_id = 13;
     */
    controllerId?: number;
    /**
     * @generated from protobuf field: optional uint32 round = 15;
     */
    round?: number;
    /**
     * @generated from protobuf field: optional uint32 cur_controller_id = 12;
     */
    curControllerId?: number;
    /**
     * @generated from protobuf field: repeated com.midnights.game.GCGPVEIntention intetion_list = 1;
     */
    intetionList: GCGPVEIntention[];
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGCostReviseInfo cost_revise = 10;
     */
    costRevise?: GCGCostReviseInfo;
    /**
     * @generated from protobuf field: repeated uint32 card_id_list = 4;
     */
    cardIdList: number[];
    /**
     * @generated from protobuf field: repeated com.midnights.game.GCGCard card_list = 9;
     */
    cardList: GCGCard[];
    /**
     * @generated from protobuf field: repeated com.midnights.game.GCGControllerShowInfo show_info_list = 6;
     */
    showInfoList: GCGControllerShowInfo[];
    /**
     * @generated from protobuf field: optional uint32 game_type = 2;
     */
    gameType?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGPhase phase = 8;
     */
    phase?: GCGPhase;
}
/**
 * @generated from protobuf message com.midnights.game.GCGNewCardInfoNotify
 */
export interface GCGNewCardInfoNotify {
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGCard card = 1;
     */
    card?: GCGCard;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGNewCardInfoNotify.CmdId
 */
export enum GCGNewCardInfoNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7203;
     */
    CMD_ID = 7203,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGOperationReq
 */
export interface GCGOperationReq {
    /**
     * @generated from protobuf field: optional uint32 op_seq = 2;
     */
    opSeq?: number;
    /**
     * @generated from protobuf field: optional uint32 redirect_uid = 7;
     */
    redirectUid?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGOperation op = 15;
     */
    op?: GCGOperation;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGOperationReq.CmdId
 */
export enum GCGOperationReq_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7107;
     */
    CMD_ID = 7107,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGOperationRsp
 */
export interface GCGOperationRsp {
    /**
     * @generated from protobuf field: optional int32 retcode = 8;
     */
    retcode?: number;
    /**
     * @generated from protobuf field: optional uint32 op_seq = 4;
     */
    opSeq?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGOperationRsp.CmdId
 */
export enum GCGOperationRsp_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7600;
     */
    CMD_ID = 7600,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGMessagePackNotify
 */
export interface GCGMessagePackNotify {
    /**
     * @generated from protobuf field: optional uint32 server_seq = 5;
     */
    serverSeq?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGMessagePack message_pack = 8;
     */
    messagePack?: GCGMessagePack;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGMessagePackNotify.CmdId
 */
export enum GCGMessagePackNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7516;
     */
    CMD_ID = 7516,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGAskDuelReq
 */
export interface GCGAskDuelReq {
}
/**
 * @generated from protobuf enum com.midnights.game.GCGAskDuelReq.CmdId
 */
export enum GCGAskDuelReq_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7237;
     */
    CMD_ID = 7237,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGAskDuelRsp
 */
export interface GCGAskDuelRsp {
    /**
     * @generated from protobuf field: optional int32 retcode = 3;
     */
    retcode?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGDuel duel = 13;
     */
    duel?: GCGDuel;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGAskDuelRsp.CmdId
 */
export enum GCGAskDuelRsp_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7869;
     */
    CMD_ID = 7869,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGPlayerBriefData
 */
export interface GCGPlayerBriefData {
    /**
     * @generated from protobuf field: map<uint32, uint32> card_face_map = 8;
     */
    cardFaceMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: optional string nick_name = 9;
     */
    nickName?: string;
    /**
     * @generated from protobuf field: optional com.midnights.game.ProfilePicture profile_picture = 12;
     */
    profilePicture?: ProfilePicture;
    /**
     * @generated from protobuf field: repeated uint32 card_id_list = 3;
     */
    cardIdList: number[];
    /**
     * @generated from protobuf field: optional uint32 controller_id = 5;
     */
    controllerId?: number;
    /**
     * @generated from protobuf field: optional uint32 uid = 10;
     */
    uid?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGGameBriefData
 */
export interface GCGGameBriefData {
    /**
     * @generated from protobuf field: optional uint32 game_id = 14;
     */
    gameId?: number;
    /**
     * @generated from protobuf field: optional uint32 game_uid = 9;
     */
    gameUid?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGGameBusinessType business_type = 13;
     */
    businessType?: GCGGameBusinessType;
    /**
     * @generated from protobuf field: optional uint32 verify_code = 5;
     */
    verifyCode?: number;
    /**
     * @generated from protobuf field: repeated com.midnights.game.GCGPlayerBriefData player_brief_list = 12;
     */
    playerBriefList: GCGPlayerBriefData[];
}
/**
 * @generated from protobuf message com.midnights.game.GCGGameBriefDataNotify
 */
export interface GCGGameBriefDataNotify {
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGGameBriefData gcg_brief_data = 10;
     */
    gcgBriefData?: GCGGameBriefData;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGGameBriefDataNotify.CmdId
 */
export enum GCGGameBriefDataNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7539;
     */
    CMD_ID = 7539,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGInitFinishReq
 */
export interface GCGInitFinishReq {
}
/**
 * @generated from protobuf enum com.midnights.game.GCGInitFinishReq.CmdId
 */
export enum GCGInitFinishReq_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7684;
     */
    CMD_ID = 7684,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGInitFinishRsp
 */
export interface GCGInitFinishRsp {
    /**
     * @generated from protobuf field: optional int32 retcode = 2;
     */
    retcode?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGInitFinishRsp.CmdId
 */
export enum GCGInitFinishRsp_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7433;
     */
    CMD_ID = 7433,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGHeartBeatNotify
 */
export interface GCGHeartBeatNotify {
    /**
     * @generated from protobuf field: optional uint32 server_seq = 6;
     */
    serverSeq?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGHeartBeatNotify.CmdId
 */
export enum GCGHeartBeatNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7224;
     */
    CMD_ID = 7224,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGSkillPreviewHpInfo
 */
export interface GCGSkillPreviewHpInfo {
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGSkillHpChangeType change_type = 4;
     */
    changeType?: GCGSkillHpChangeType;
    /**
     * @generated from protobuf field: optional uint32 hp_change_value = 13;
     */
    hpChangeValue?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGSkillPreviewReactionInfo
 */
export interface GCGSkillPreviewReactionInfo {
    /**
     * @generated from protobuf field: optional uint32 source_element = 13;
     */
    sourceElement?: number;
    /**
     * @generated from protobuf field: optional uint32 target_element = 1;
     */
    targetElement?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGSkillPreviewElementReactionInfo
 */
export interface GCGSkillPreviewElementReactionInfo {
    /**
     * @generated from protobuf field: repeated uint32 fresh_list = 8;
     */
    freshList: number[];
    /**
     * @generated from protobuf field: repeated uint32 source_list = 2;
     */
    sourceList: number[];
    /**
     * @generated from protobuf field: repeated com.midnights.game.GCGSkillPreviewReactionInfo reaction_list = 14;
     */
    reactionList: GCGSkillPreviewReactionInfo[];
}
/**
 * @generated from protobuf message com.midnights.game.GCGSkillPreviewCardInfo
 */
export interface GCGSkillPreviewCardInfo {
    /**
     * @generated from protobuf field: optional uint32 controller_id = 3;
     */
    controllerId?: number;
    /**
     * @generated from protobuf field: optional uint32 owner_card_guid = 11;
     */
    ownerCardGuid?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGZoneType zone_type = 14;
     */
    zoneType?: GCGZoneType;
    /**
     * @generated from protobuf field: optional uint32 card_id = 13;
     */
    cardId?: number;
    /**
     * @generated from protobuf field: optional uint32 card_guid = 6;
     */
    cardGuid?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGSkillPreviewOnstageChangeInfo
 */
export interface GCGSkillPreviewOnstageChangeInfo {
    /**
     * @generated from protobuf field: optional uint32 target_onstage_card_guid = 6;
     */
    targetOnstageCardGuid?: number;
    /**
     * @generated from protobuf field: optional uint32 source_onstage_card_guid = 15;
     */
    sourceOnstageCardGuid?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGSkillPreviewTokenInfo
 */
export interface GCGSkillPreviewTokenInfo {
    /**
     * @generated from protobuf field: optional uint32 token_type = 3;
     */
    tokenType?: number;
    /**
     * @generated from protobuf field: optional uint32 after_value = 12;
     */
    afterValue?: number;
    /**
     * @generated from protobuf field: optional uint32 before_value = 15;
     */
    beforeValue?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGSkillPreviewTokenChangeInfo
 */
export interface GCGSkillPreviewTokenChangeInfo {
    /**
     * @generated from protobuf field: repeated com.midnights.game.GCGSkillPreviewTokenInfo token_change_list = 14;
     */
    tokenChangeList: GCGSkillPreviewTokenInfo[];
}
/**
 * @generated from protobuf message com.midnights.game.GCGSkillPreviewInfo
 */
export interface GCGSkillPreviewInfo {
    /**
     * @generated from protobuf field: repeated com.midnights.game.GCGSkillPreviewCardInfo rm_card_list = 12;
     */
    rmCardList: GCGSkillPreviewCardInfo[];
    /**
     * @generated from protobuf field: map<uint32, com.midnights.game.GCGSkillPreviewHpInfo> hp_info_map = 8;
     */
    hpInfoMap: {
        [key: number]: GCGSkillPreviewHpInfo;
    };
    /**
     * @generated from protobuf field: map<uint32, com.midnights.game.GCGSkillPreviewElementReactionInfo> reaction_info_map = 5;
     */
    reactionInfoMap: {
        [key: number]: GCGSkillPreviewElementReactionInfo;
    };
    /**
     * @generated from protobuf field: repeated com.midnights.game.GCGSkillPreviewOnstageChangeInfo change_onstage_character_list = 9;
     */
    changeOnstageCharacterList: GCGSkillPreviewOnstageChangeInfo[];
    /**
     * @generated from protobuf field: optional uint32 skill_id = 6;
     */
    skillId?: number;
    /**
     * @generated from protobuf field: map<uint32, com.midnights.game.GCGSkillPreviewTokenChangeInfo> card_token_change_map = 3;
     */
    cardTokenChangeMap: {
        [key: number]: GCGSkillPreviewTokenChangeInfo;
    };
    /**
     * @generated from protobuf field: repeated com.midnights.game.GCGSkillPreviewCardInfo add_card_list = 11;
     */
    addCardList: GCGSkillPreviewCardInfo[];
}
/**
 * @generated from protobuf message com.midnights.game.GCGSkillPreviewNotify
 */
export interface GCGSkillPreviewNotify {
    /**
     * @generated from protobuf field: repeated com.midnights.game.GCGSkillPreviewInfo skill_preview_list = 9;
     */
    skillPreviewList: GCGSkillPreviewInfo[];
    /**
     * @generated from protobuf field: optional uint32 onstage_card_guid = 5;
     */
    onstageCardGuid?: number;
    /**
     * @generated from protobuf field: optional uint32 controller_id = 15;
     */
    controllerId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGSkillPreviewNotify.CmdId
 */
export enum GCGSkillPreviewNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7503;
     */
    CMD_ID = 7503,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGSkillPreviewAskReq
 */
export interface GCGSkillPreviewAskReq {
}
/**
 * @generated from protobuf enum com.midnights.game.GCGSkillPreviewAskReq.CmdId
 */
export enum GCGSkillPreviewAskReq_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7509;
     */
    CMD_ID = 7509,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGSkillPreviewAskRsp
 */
export interface GCGSkillPreviewAskRsp {
    /**
     * @generated from protobuf field: optional int32 retcode = 1;
     */
    retcode?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGSkillPreviewAskRsp.CmdId
 */
export enum GCGSkillPreviewAskRsp_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7409;
     */
    CMD_ID = 7409,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGChallengeUpdateNotify
 */
export interface GCGChallengeUpdateNotify {
    /**
     * @generated from protobuf field: optional uint32 server_seq = 12;
     */
    serverSeq?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGDuelChallenge challenge = 13;
     */
    challenge?: GCGDuelChallenge;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGChallengeUpdateNotify.CmdId
 */
export enum GCGChallengeUpdateNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7268;
     */
    CMD_ID = 7268,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGDSDeckData
 */
export interface GCGDSDeckData {
    /**
     * @generated from protobuf field: repeated uint32 card_list = 1;
     */
    cardList: number[];
    /**
     * @generated from protobuf field: optional uint32 card_back_id = 15;
     */
    cardBackId?: number;
    /**
     * @generated from protobuf field: repeated uint32 character_card_list = 10;
     */
    characterCardList: number[];
    /**
     * @generated from protobuf field: optional string name = 5;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional uint32 id = 3;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional fixed32 create_time = 13;
     */
    createTime?: number;
    /**
     * @generated from protobuf field: optional bool is_valid = 4;
     */
    isValid?: boolean;
    /**
     * @generated from protobuf field: optional uint32 field_id = 7;
     */
    fieldId?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGDSCardData
 */
export interface GCGDSCardData {
    /**
     * @generated from protobuf field: optional uint32 card_id = 14;
     */
    cardId?: number;
    /**
     * @generated from protobuf field: repeated uint32 unlock_face_type_list = 9;
     */
    unlockFaceTypeList: number[];
    /**
     * @generated from protobuf field: optional uint32 num = 12;
     */
    num?: number;
    /**
     * @generated from protobuf field: optional uint32 proficiency = 8;
     */
    proficiency?: number;
    /**
     * @generated from protobuf field: optional uint32 face_type = 6;
     */
    faceType?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGDSDataNotify
 */
export interface GCGDSDataNotify {
    /**
     * @generated from protobuf field: repeated com.midnights.game.GCGDSDeckData deck_list = 4;
     */
    deckList: GCGDSDeckData[];
    /**
     * @generated from protobuf field: repeated uint32 unlock_card_back_id_list = 5;
     */
    unlockCardBackIdList: number[];
    /**
     * @generated from protobuf field: repeated uint32 unlock_field_id_list = 6;
     */
    unlockFieldIdList: number[];
    /**
     * @generated from protobuf field: optional uint32 cur_deck_id = 10;
     */
    curDeckId?: number;
    /**
     * @generated from protobuf field: repeated com.midnights.game.GCGDSCardData card_list = 3;
     */
    cardList: GCGDSCardData[];
    /**
     * @generated from protobuf field: repeated uint32 unlock_deck_id_list = 1;
     */
    unlockDeckIdList: number[];
}
/**
 * @generated from protobuf enum com.midnights.game.GCGDSDataNotify.CmdId
 */
export enum GCGDSDataNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7122;
     */
    CMD_ID = 7122,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGDSCardBackUnlockNotify
 */
export interface GCGDSCardBackUnlockNotify {
    /**
     * @generated from protobuf field: optional uint32 card_back_id = 6;
     */
    cardBackId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGDSCardBackUnlockNotify.CmdId
 */
export enum GCGDSCardBackUnlockNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7265;
     */
    CMD_ID = 7265,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGDSFieldUnlockNotify
 */
export interface GCGDSFieldUnlockNotify {
    /**
     * @generated from protobuf field: optional uint32 field_id = 1;
     */
    fieldId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGDSFieldUnlockNotify.CmdId
 */
export enum GCGDSFieldUnlockNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7333;
     */
    CMD_ID = 7333,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGDSCardFaceUnlockNotify
 */
export interface GCGDSCardFaceUnlockNotify {
    /**
     * @generated from protobuf field: optional uint32 card_id = 13;
     */
    cardId?: number;
    /**
     * @generated from protobuf field: optional uint32 face_type = 1;
     */
    faceType?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGDSCardFaceUnlockNotify.CmdId
 */
export enum GCGDSCardFaceUnlockNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7049;
     */
    CMD_ID = 7049,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGDSCardNumChangeNotify
 */
export interface GCGDSCardNumChangeNotify {
    /**
     * @generated from protobuf field: optional uint32 card_id = 4;
     */
    cardId?: number;
    /**
     * @generated from protobuf field: optional uint32 num = 10;
     */
    num?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGDSCardNumChangeNotify.CmdId
 */
export enum GCGDSCardNumChangeNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7358;
     */
    CMD_ID = 7358,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGDSChangeCardFaceReq
 */
export interface GCGDSChangeCardFaceReq {
    /**
     * @generated from protobuf field: optional uint32 face_type = 6;
     */
    faceType?: number;
    /**
     * @generated from protobuf field: optional uint32 card_id = 3;
     */
    cardId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGDSChangeCardFaceReq.CmdId
 */
export enum GCGDSChangeCardFaceReq_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7169;
     */
    CMD_ID = 7169,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGDSChangeCardFaceRsp
 */
export interface GCGDSChangeCardFaceRsp {
    /**
     * @generated from protobuf field: optional uint32 face_type = 8;
     */
    faceType?: number;
    /**
     * @generated from protobuf field: optional uint32 card_id = 4;
     */
    cardId?: number;
    /**
     * @generated from protobuf field: optional int32 retcode = 9;
     */
    retcode?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGDSChangeCardFaceRsp.CmdId
 */
export enum GCGDSChangeCardFaceRsp_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7331;
     */
    CMD_ID = 7331,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGDSChangeCardBackReq
 */
export interface GCGDSChangeCardBackReq {
    /**
     * @generated from protobuf field: optional uint32 deck_id = 10;
     */
    deckId?: number;
    /**
     * @generated from protobuf field: optional uint32 card_back_id = 12;
     */
    cardBackId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGDSChangeCardBackReq.CmdId
 */
export enum GCGDSChangeCardBackReq_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7292;
     */
    CMD_ID = 7292,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGDSChangeCardBackRsp
 */
export interface GCGDSChangeCardBackRsp {
    /**
     * @generated from protobuf field: optional int32 retcode = 15;
     */
    retcode?: number;
    /**
     * @generated from protobuf field: optional uint32 card_back_id = 6;
     */
    cardBackId?: number;
    /**
     * @generated from protobuf field: optional uint32 deck_id = 5;
     */
    deckId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGDSChangeCardBackRsp.CmdId
 */
export enum GCGDSChangeCardBackRsp_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7044;
     */
    CMD_ID = 7044,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGDSChangeFieldReq
 */
export interface GCGDSChangeFieldReq {
    /**
     * @generated from protobuf field: optional uint32 field_id = 6;
     */
    fieldId?: number;
    /**
     * @generated from protobuf field: optional uint32 deck_id = 11;
     */
    deckId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGDSChangeFieldReq.CmdId
 */
export enum GCGDSChangeFieldReq_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7541;
     */
    CMD_ID = 7541,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGDSChangeFieldRsp
 */
export interface GCGDSChangeFieldRsp {
    /**
     * @generated from protobuf field: optional int32 retcode = 1;
     */
    retcode?: number;
    /**
     * @generated from protobuf field: optional uint32 field_id = 3;
     */
    fieldId?: number;
    /**
     * @generated from protobuf field: optional uint32 deck_id = 2;
     */
    deckId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGDSChangeFieldRsp.CmdId
 */
export enum GCGDSChangeFieldRsp_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7444;
     */
    CMD_ID = 7444,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGDSChangeDeckNameReq
 */
export interface GCGDSChangeDeckNameReq {
    /**
     * @generated from protobuf field: optional uint32 deck_id = 13;
     */
    deckId?: number;
    /**
     * @generated from protobuf field: optional string name = 7;
     */
    name?: string;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGDSChangeDeckNameReq.CmdId
 */
export enum GCGDSChangeDeckNameReq_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7432;
     */
    CMD_ID = 7432,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGDSChangeDeckNameRsp
 */
export interface GCGDSChangeDeckNameRsp {
    /**
     * @generated from protobuf field: optional uint32 deck_id = 13;
     */
    deckId?: number;
    /**
     * @generated from protobuf field: optional int32 retcode = 14;
     */
    retcode?: number;
    /**
     * @generated from protobuf field: optional string name = 1;
     */
    name?: string;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGDSChangeDeckNameRsp.CmdId
 */
export enum GCGDSChangeDeckNameRsp_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7916;
     */
    CMD_ID = 7916,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGDSDeckSaveReq
 */
export interface GCGDSDeckSaveReq {
    /**
     * @generated from protobuf field: optional uint32 deck_id = 1;
     */
    deckId?: number;
    /**
     * @generated from protobuf field: repeated uint32 card_list = 4;
     */
    cardList: number[];
    /**
     * @generated from protobuf field: repeated uint32 character_card_list = 9;
     */
    characterCardList: number[];
    /**
     * @generated from protobuf field: optional string name = 14;
     */
    name?: string;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGDSDeckSaveReq.CmdId
 */
export enum GCGDSDeckSaveReq_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7104;
     */
    CMD_ID = 7104,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGDSDeckSaveRsp
 */
export interface GCGDSDeckSaveRsp {
    /**
     * @generated from protobuf field: optional fixed32 create_time = 14;
     */
    createTime?: number;
    /**
     * @generated from protobuf field: optional uint32 deck_id = 11;
     */
    deckId?: number;
    /**
     * @generated from protobuf field: optional int32 retcode = 8;
     */
    retcode?: number;
    /**
     * @generated from protobuf field: optional bool is_valid = 4;
     */
    isValid?: boolean;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGDSDeckSaveRsp.CmdId
 */
export enum GCGDSDeckSaveRsp_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7269;
     */
    CMD_ID = 7269,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGDSChangeCurDeckReq
 */
export interface GCGDSChangeCurDeckReq {
    /**
     * @generated from protobuf field: optional uint32 deck_id = 3;
     */
    deckId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGDSChangeCurDeckReq.CmdId
 */
export enum GCGDSChangeCurDeckReq_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7131;
     */
    CMD_ID = 7131,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGDSChangeCurDeckRsp
 */
export interface GCGDSChangeCurDeckRsp {
    /**
     * @generated from protobuf field: optional int32 retcode = 8;
     */
    retcode?: number;
    /**
     * @generated from protobuf field: optional uint32 deck_id = 14;
     */
    deckId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGDSChangeCurDeckRsp.CmdId
 */
export enum GCGDSChangeCurDeckRsp_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7301;
     */
    CMD_ID = 7301,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGDSCurDeckChangeNotify
 */
export interface GCGDSCurDeckChangeNotify {
    /**
     * @generated from protobuf field: optional uint32 deck_id = 6;
     */
    deckId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGDSCurDeckChangeNotify.CmdId
 */
export enum GCGDSCurDeckChangeNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7796;
     */
    CMD_ID = 7796,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGDSDeleteDeckReq
 */
export interface GCGDSDeleteDeckReq {
    /**
     * @generated from protobuf field: optional uint32 deck_id = 15;
     */
    deckId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGDSDeleteDeckReq.CmdId
 */
export enum GCGDSDeleteDeckReq_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7988;
     */
    CMD_ID = 7988,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGDSDeleteDeckRsp
 */
export interface GCGDSDeleteDeckRsp {
    /**
     * @generated from protobuf field: optional int32 retcode = 14;
     */
    retcode?: number;
    /**
     * @generated from protobuf field: optional uint32 deck_id = 7;
     */
    deckId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGDSDeleteDeckRsp.CmdId
 */
export enum GCGDSDeleteDeckRsp_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7524;
     */
    CMD_ID = 7524,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGDSDeckUnlockNotify
 */
export interface GCGDSDeckUnlockNotify {
    /**
     * @generated from protobuf field: optional uint32 deck_id = 15;
     */
    deckId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGDSDeckUnlockNotify.CmdId
 */
export enum GCGDSDeckUnlockNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7732;
     */
    CMD_ID = 7732,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGDSCardProficiencyNotify
 */
export interface GCGDSCardProficiencyNotify {
    /**
     * @generated from protobuf field: optional uint32 proficiency = 2;
     */
    proficiency?: number;
    /**
     * @generated from protobuf field: optional uint32 card_id = 12;
     */
    cardId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGDSCardProficiencyNotify.CmdId
 */
export enum GCGDSCardProficiencyNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7680;
     */
    CMD_ID = 7680,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGTCTavernInfoNotify
 */
export interface GCGTCTavernInfoNotify {
    /**
     * @generated from protobuf field: optional bool is_last_duel_win = 14;
     */
    isLastDuelWin?: boolean;
    /**
     * @generated from protobuf field: optional uint32 level_id = 11;
     */
    levelId?: number;
    /**
     * @generated from protobuf field: optional bool is_owner_in_duel = 5;
     */
    isOwnerInDuel?: boolean;
    /**
     * @generated from protobuf field: optional uint32 point_id = 3;
     */
    pointId?: number;
    /**
     * @generated from protobuf field: optional uint32 avatar_id = 12;
     */
    avatarId?: number;
    /**
     * @generated from protobuf field: optional uint32 character_id = 7;
     */
    characterId?: number;
    /**
     * @generated from protobuf field: optional uint32 element_type = 10;
     */
    elementType?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGTCTavernInfoNotify.CmdId
 */
export enum GCGTCTavernInfoNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7011;
     */
    CMD_ID = 7011,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGTCInviteReq
 */
export interface GCGTCInviteReq {
    /**
     * @generated from protobuf field: optional uint32 level_id = 3;
     */
    levelId?: number;
    /**
     * @generated from protobuf field: optional uint32 character_id = 6;
     */
    characterId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGTCInviteReq.CmdId
 */
export enum GCGTCInviteReq_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7922;
     */
    CMD_ID = 7922,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGTCInviteRsp
 */
export interface GCGTCInviteRsp {
    /**
     * @generated from protobuf field: optional uint32 character_id = 12;
     */
    characterId?: number;
    /**
     * @generated from protobuf field: optional int32 retcode = 5;
     */
    retcode?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGTCInviteRsp.CmdId
 */
export enum GCGTCInviteRsp_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7328;
     */
    CMD_ID = 7328,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGTCTavernChallengeData
 */
export interface GCGTCTavernChallengeData {
    /**
     * @generated from protobuf field: repeated uint32 unlock_level_id_list = 1;
     */
    unlockLevelIdList: number[];
    /**
     * @generated from protobuf field: optional uint32 character_id = 8;
     */
    characterId?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGTCTavernChallengeDataNotify
 */
export interface GCGTCTavernChallengeDataNotify {
    /**
     * @generated from protobuf field: repeated com.midnights.game.GCGTCTavernChallengeData tavern_challenge_list = 13;
     */
    tavernChallengeList: GCGTCTavernChallengeData[];
}
/**
 * @generated from protobuf enum com.midnights.game.GCGTCTavernChallengeDataNotify.CmdId
 */
export enum GCGTCTavernChallengeDataNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7294;
     */
    CMD_ID = 7294,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGTCTavernChallengeUpdateNotify
 */
export interface GCGTCTavernChallengeUpdateNotify {
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGTCTavernChallengeData tavern_challenge = 5;
     */
    tavernChallenge?: GCGTCTavernChallengeData;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGTCTavernChallengeUpdateNotify.CmdId
 */
export enum GCGTCTavernChallengeUpdateNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7184;
     */
    CMD_ID = 7184,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGGrowthLevelNotify
 */
export interface GCGGrowthLevelNotify {
    /**
     * @generated from protobuf field: optional uint32 exp = 7;
     */
    exp?: number;
    /**
     * @generated from protobuf field: optional uint32 level = 11;
     */
    level?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGGrowthLevelNotify.CmdId
 */
export enum GCGGrowthLevelNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7736;
     */
    CMD_ID = 7736,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGGrowthLevelRewardNotify
 */
export interface GCGGrowthLevelRewardNotify {
    /**
     * @generated from protobuf field: repeated uint32 level_reward_taken_list = 8;
     */
    levelRewardTakenList: number[];
}
/**
 * @generated from protobuf enum com.midnights.game.GCGGrowthLevelRewardNotify.CmdId
 */
export enum GCGGrowthLevelRewardNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7477;
     */
    CMD_ID = 7477,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGGrowthLevelTakeRewardReq
 */
export interface GCGGrowthLevelTakeRewardReq {
    /**
     * @generated from protobuf field: optional uint32 level = 4;
     */
    level?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGGrowthLevelTakeRewardReq.CmdId
 */
export enum GCGGrowthLevelTakeRewardReq_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7051;
     */
    CMD_ID = 7051,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGGrowthLevelTakeRewardRsp
 */
export interface GCGGrowthLevelTakeRewardRsp {
    /**
     * @generated from protobuf field: optional uint32 level = 1;
     */
    level?: number;
    /**
     * @generated from protobuf field: optional int32 retcode = 13;
     */
    retcode?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGGrowthLevelTakeRewardRsp.CmdId
 */
export enum GCGGrowthLevelTakeRewardRsp_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7670;
     */
    CMD_ID = 7670,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGInviteGuestBattleReq
 */
export interface GCGInviteGuestBattleReq {
    /**
     * @generated from protobuf field: optional uint32 uid = 11;
     */
    uid?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGInviteGuestBattleReq.CmdId
 */
export enum GCGInviteGuestBattleReq_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7783;
     */
    CMD_ID = 7783,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGInviteGuestBattleRsp
 */
export interface GCGInviteGuestBattleRsp {
    /**
     * @generated from protobuf field: optional int32 retcode = 3;
     */
    retcode?: number;
    /**
     * @generated from protobuf field: optional uint32 uid = 11;
     */
    uid?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGInviteGuestBattleRsp.CmdId
 */
export enum GCGInviteGuestBattleRsp_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7251;
     */
    CMD_ID = 7251,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGInviteBattleNotify
 */
export interface GCGInviteBattleNotify {
}
/**
 * @generated from protobuf enum com.midnights.game.GCGInviteBattleNotify.CmdId
 */
export enum GCGInviteBattleNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7692;
     */
    CMD_ID = 7692,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGApplyInviteBattleReq
 */
export interface GCGApplyInviteBattleReq {
    /**
     * @generated from protobuf field: optional bool is_agree = 9;
     */
    isAgree?: boolean;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGApplyInviteBattleReq.CmdId
 */
export enum GCGApplyInviteBattleReq_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7730;
     */
    CMD_ID = 7730,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGApplyInviteBattleRsp
 */
export interface GCGApplyInviteBattleRsp {
    /**
     * @generated from protobuf field: optional int32 retcode = 5;
     */
    retcode?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGApplyInviteBattleRsp.CmdId
 */
export enum GCGApplyInviteBattleRsp_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7304;
     */
    CMD_ID = 7304,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGApplyInviteBattleNotify
 */
export interface GCGApplyInviteBattleNotify {
    /**
     * @generated from protobuf field: optional bool is_agree = 14;
     */
    isAgree?: boolean;
    /**
     * @generated from protobuf field: optional int32 retcode = 6;
     */
    retcode?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGApplyInviteBattleNotify.CmdId
 */
export enum GCGApplyInviteBattleNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7820;
     */
    CMD_ID = 7820,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGSettleNotify
 */
export interface GCGSettleNotify {
    /**
     * @generated from protobuf field: optional uint32 game_id = 7;
     */
    gameId?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGGameBusinessType business_type = 2;
     */
    businessType?: GCGGameBusinessType;
    /**
     * @generated from protobuf field: optional bool is_win = 13;
     */
    isWin?: boolean;
    /**
     * @generated from protobuf field: repeated com.midnights.game.ItemParam reward_item_list = 9;
     */
    rewardItemList: ItemParam[];
    /**
     * @generated from protobuf field: repeated uint32 finished_challenge_id_list = 6;
     */
    finishedChallengeIdList: number[];
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGEndReason reason = 3;
     */
    reason?: GCGEndReason;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGSettleNotify.CmdId
 */
export enum GCGSettleNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7769;
     */
    CMD_ID = 7769,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGResourceStateNotify
 */
export interface GCGResourceStateNotify {
    /**
     * @generated from protobuf field: optional bool is_complete = 5;
     */
    isComplete?: boolean;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGResourceStateNotify.CmdId
 */
export enum GCGResourceStateNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7876;
     */
    CMD_ID = 7876,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGClientSettleReq
 */
export interface GCGClientSettleReq {
}
/**
 * @generated from protobuf enum com.midnights.game.GCGClientSettleReq.CmdId
 */
export enum GCGClientSettleReq_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7506;
     */
    CMD_ID = 7506,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGClientSettleRsp
 */
export interface GCGClientSettleRsp {
    /**
     * @generated from protobuf field: optional uint32 close_time = 4;
     */
    closeTime?: number;
    /**
     * @generated from protobuf field: optional int32 retcode = 1;
     */
    retcode?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGClientSettleRsp.CmdId
 */
export enum GCGClientSettleRsp_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7105;
     */
    CMD_ID = 7105,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGSettleOptionReq
 */
export interface GCGSettleOptionReq {
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGSettleOption option = 5;
     */
    option?: GCGSettleOption;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGSettleOptionReq.CmdId
 */
export enum GCGSettleOptionReq_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7124;
     */
    CMD_ID = 7124,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGSettleOptionRsp
 */
export interface GCGSettleOptionRsp {
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGSettleOption option = 13;
     */
    option?: GCGSettleOption;
    /**
     * @generated from protobuf field: optional int32 retcode = 14;
     */
    retcode?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGSettleOptionRsp.CmdId
 */
export enum GCGSettleOptionRsp_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7735;
     */
    CMD_ID = 7735,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGBasicDataNotify
 */
export interface GCGBasicDataNotify {
    /**
     * @generated from protobuf field: optional uint32 level = 9;
     */
    level?: number;
    /**
     * @generated from protobuf field: optional uint32 exp = 4;
     */
    exp?: number;
    /**
     * @generated from protobuf field: repeated uint32 level_reward_taken_list = 12;
     */
    levelRewardTakenList: number[];
}
/**
 * @generated from protobuf enum com.midnights.game.GCGBasicDataNotify.CmdId
 */
export enum GCGBasicDataNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7319;
     */
    CMD_ID = 7319,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGTavernNpcInfo
 */
export interface GCGTavernNpcInfo {
    /**
     * @generated from protobuf field: optional uint32 id = 6;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional uint32 level_id = 10;
     */
    levelId?: number;
    /**
     * @generated from protobuf field: optional uint32 scene_point_id = 3;
     */
    scenePointId?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGTavernNpcInfoNotify
 */
export interface GCGTavernNpcInfoNotify {
    /**
     * @generated from protobuf field: repeated com.midnights.game.GCGTavernNpcInfo week_npc_list = 1;
     */
    weekNpcList: GCGTavernNpcInfo[];
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGTavernNpcInfo character_npc = 5;
     */
    characterNpc?: GCGTavernNpcInfo;
    /**
     * @generated from protobuf field: repeated com.midnights.game.GCGTavernNpcInfo const_npc_list = 15;
     */
    constNpcList: GCGTavernNpcInfo[];
}
/**
 * @generated from protobuf enum com.midnights.game.GCGTavernNpcInfoNotify.CmdId
 */
export enum GCGTavernNpcInfoNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7290;
     */
    CMD_ID = 7290,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGStartChallengeReq
 */
export interface GCGStartChallengeReq {
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGLevelType level_type = 5;
     */
    levelType?: GCGLevelType;
    /**
     * @generated from protobuf field: optional uint32 config_id = 13;
     */
    configId?: number;
    /**
     * @generated from protobuf field: optional uint32 level_id = 12;
     */
    levelId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGStartChallengeReq.CmdId
 */
export enum GCGStartChallengeReq_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7595;
     */
    CMD_ID = 7595,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGStartChallengeRsp
 */
export interface GCGStartChallengeRsp {
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGLevelType level_type = 12;
     */
    levelType?: GCGLevelType;
    /**
     * @generated from protobuf field: optional int32 retcode = 15;
     */
    retcode?: number;
    /**
     * @generated from protobuf field: optional uint32 config_id = 6;
     */
    configId?: number;
    /**
     * @generated from protobuf field: optional uint32 level_id = 1;
     */
    levelId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGStartChallengeRsp.CmdId
 */
export enum GCGStartChallengeRsp_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7763;
     */
    CMD_ID = 7763,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGWeekChallengeInfo
 */
export interface GCGWeekChallengeInfo {
    /**
     * @generated from protobuf field: optional uint32 npc_id = 4;
     */
    npcId?: number;
    /**
     * @generated from protobuf field: optional bool is_finished = 7;
     */
    isFinished?: boolean;
    /**
     * @generated from protobuf field: optional uint32 unlock_time = 1;
     */
    unlockTime?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGWeekChallengeInfoNotify
 */
export interface GCGWeekChallengeInfoNotify {
    /**
     * @generated from protobuf field: repeated com.midnights.game.GCGWeekChallengeInfo challenge_info_list = 15;
     */
    challengeInfoList: GCGWeekChallengeInfo[];
    /**
     * @generated from protobuf field: optional uint32 next_refresh_time = 7;
     */
    nextRefreshTime?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGWeekChallengeInfoNotify.CmdId
 */
export enum GCGWeekChallengeInfoNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7615;
     */
    CMD_ID = 7615,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGLevelData
 */
export interface GCGLevelData {
    /**
     * @generated from protobuf field: repeated uint32 finished_challenge_id_list = 10;
     */
    finishedChallengeIdList: number[];
    /**
     * @generated from protobuf field: optional uint32 level_id = 9;
     */
    levelId?: number;
}
/**
 * @generated from protobuf message com.midnights.game.GCGBossChallengeData
 */
export interface GCGBossChallengeData {
    /**
     * @generated from protobuf field: optional uint32 id = 9;
     */
    id?: number;
    /**
     * @generated from protobuf field: repeated uint32 unlock_level_id_list = 14;
     */
    unlockLevelIdList: number[];
}
/**
 * @generated from protobuf message com.midnights.game.GCGLevelChallengeNotify
 */
export interface GCGLevelChallengeNotify {
    /**
     * @generated from protobuf field: repeated com.midnights.game.GCGBossChallengeData unlock_boss_challenge_list = 3;
     */
    unlockBossChallengeList: GCGBossChallengeData[];
    /**
     * @generated from protobuf field: repeated uint32 unlock_world_challenge_list = 8;
     */
    unlockWorldChallengeList: number[];
    /**
     * @generated from protobuf field: repeated com.midnights.game.GCGLevelData level_list = 10;
     */
    levelList: GCGLevelData[];
}
/**
 * @generated from protobuf enum com.midnights.game.GCGLevelChallengeNotify.CmdId
 */
export enum GCGLevelChallengeNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7055;
     */
    CMD_ID = 7055,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGLevelChallengeFinishNotify
 */
export interface GCGLevelChallengeFinishNotify {
    /**
     * @generated from protobuf field: repeated uint32 finished_challenge_id_list = 10;
     */
    finishedChallengeIdList: number[];
    /**
     * @generated from protobuf field: optional uint32 level_id = 15;
     */
    levelId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGLevelChallengeFinishNotify.CmdId
 */
export enum GCGLevelChallengeFinishNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7629;
     */
    CMD_ID = 7629,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGWorldChallengeUnlockNotify
 */
export interface GCGWorldChallengeUnlockNotify {
    /**
     * @generated from protobuf field: repeated uint32 unlock_id_list = 8;
     */
    unlockIdList: number[];
}
/**
 * @generated from protobuf enum com.midnights.game.GCGWorldChallengeUnlockNotify.CmdId
 */
export enum GCGWorldChallengeUnlockNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7204;
     */
    CMD_ID = 7204,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.GCGBossChallengeUpdateNotify
 */
export interface GCGBossChallengeUpdateNotify {
    /**
     * @generated from protobuf field: optional com.midnights.game.GCGBossChallengeData boss_challenge = 11;
     */
    bossChallenge?: GCGBossChallengeData;
}
/**
 * @generated from protobuf enum com.midnights.game.GCGBossChallengeUpdateNotify.CmdId
 */
export enum GCGBossChallengeUpdateNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 7073;
     */
    CMD_ID = 7073,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf enum com.midnights.game.GCGSkillHpChangeType
 */
export enum GCGSkillHpChangeType {
    /**
     * @generated from protobuf enum value: GCG_SKILL_HP_CHANGE_NONE = 0;
     */
    GCG_SKILL_HP_CHANGE_NONE = 0,
    /**
     * @generated from protobuf enum value: GCG_SKILL_HP_CHANGE_DAMAGE = 1;
     */
    GCG_SKILL_HP_CHANGE_DAMAGE = 1,
    /**
     * @generated from protobuf enum value: GCG_SKILL_HP_CHANGE_HEAL = 2;
     */
    GCG_SKILL_HP_CHANGE_HEAL = 2
}
/**
 * @generated from protobuf enum com.midnights.game.GCGSettleOption
 */
export enum GCGSettleOption {
    /**
     * @generated from protobuf enum value: GCG_SETTLE_OPT_NONE = 0;
     */
    GCG_SETTLE_OPT_NONE = 0,
    /**
     * @generated from protobuf enum value: GCG_SETTLE_OPT_EXIT = 1;
     */
    GCG_SETTLE_OPT_EXIT = 1,
    /**
     * @generated from protobuf enum value: GCG_SETTLE_OPT_CONTINUE = 2;
     */
    GCG_SETTLE_OPT_CONTINUE = 2,
    /**
     * @generated from protobuf enum value: GCG_SETTLE_OPT_RESTART = 3;
     */
    GCG_SETTLE_OPT_RESTART = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class GCGAttackCostInfo$Type extends MessageType<GCGAttackCostInfo> {
    constructor() {
        super("com.midnights.game.GCGAttackCostInfo", [
            { no: 8, name: "skill_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "cost_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } }
        ]);
    }
    create(value?: PartialMessage<GCGAttackCostInfo>): GCGAttackCostInfo {
        const message = { costMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGAttackCostInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGAttackCostInfo): GCGAttackCostInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 skill_id */ 8:
                    message.skillId = reader.uint32();
                    break;
                case /* map<uint32, uint32> cost_map */ 3:
                    this.binaryReadMap3(message.costMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: GCGAttackCostInfo["costMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GCGAttackCostInfo["costMap"] | undefined, val: GCGAttackCostInfo["costMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field com.midnights.game.GCGAttackCostInfo.cost_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: GCGAttackCostInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 skill_id = 8; */
        if (message.skillId !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.skillId);
        /* map<uint32, uint32> cost_map = 3; */
        for (let k of Object.keys(message.costMap))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.costMap[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGAttackCostInfo
 */
export const GCGAttackCostInfo = new GCGAttackCostInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGPlayCardCostInfo$Type extends MessageType<GCGPlayCardCostInfo> {
    constructor() {
        super("com.midnights.game.GCGPlayCardCostInfo", [
            { no: 14, name: "cost_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 1, name: "card_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGPlayCardCostInfo>): GCGPlayCardCostInfo {
        const message = { costMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGPlayCardCostInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGPlayCardCostInfo): GCGPlayCardCostInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, uint32> cost_map */ 14:
                    this.binaryReadMap14(message.costMap, reader, options);
                    break;
                case /* optional uint32 card_id */ 1:
                    message.cardId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap14(map: GCGPlayCardCostInfo["costMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GCGPlayCardCostInfo["costMap"] | undefined, val: GCGPlayCardCostInfo["costMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field com.midnights.game.GCGPlayCardCostInfo.cost_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: GCGPlayCardCostInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, uint32> cost_map = 14; */
        for (let k of Object.keys(message.costMap))
            writer.tag(14, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.costMap[k as any]).join();
        /* optional uint32 card_id = 1; */
        if (message.cardId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.cardId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGPlayCardCostInfo
 */
export const GCGPlayCardCostInfo = new GCGPlayCardCostInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGSelectOnStageCostInfo$Type extends MessageType<GCGSelectOnStageCostInfo> {
    constructor() {
        super("com.midnights.game.GCGSelectOnStageCostInfo", [
            { no: 8, name: "cost_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 9, name: "card_guid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGSelectOnStageCostInfo>): GCGSelectOnStageCostInfo {
        const message = { costMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGSelectOnStageCostInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGSelectOnStageCostInfo): GCGSelectOnStageCostInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, uint32> cost_map */ 8:
                    this.binaryReadMap8(message.costMap, reader, options);
                    break;
                case /* optional uint32 card_guid */ 9:
                    message.cardGuid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap8(map: GCGSelectOnStageCostInfo["costMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GCGSelectOnStageCostInfo["costMap"] | undefined, val: GCGSelectOnStageCostInfo["costMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field com.midnights.game.GCGSelectOnStageCostInfo.cost_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: GCGSelectOnStageCostInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, uint32> cost_map = 8; */
        for (let k of Object.keys(message.costMap))
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.costMap[k as any]).join();
        /* optional uint32 card_guid = 9; */
        if (message.cardGuid !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.cardGuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGSelectOnStageCostInfo
 */
export const GCGSelectOnStageCostInfo = new GCGSelectOnStageCostInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGCostReviseInfo$Type extends MessageType<GCGCostReviseInfo> {
    constructor() {
        super("com.midnights.game.GCGCostReviseInfo", [
            { no: 4, name: "is_can_attack", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "can_use_hand_card_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "play_card_cost_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GCGPlayCardCostInfo },
            { no: 10, name: "select_on_stage_cost_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GCGSelectOnStageCostInfo },
            { no: 2, name: "attack_cost_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GCGAttackCostInfo }
        ]);
    }
    create(value?: PartialMessage<GCGCostReviseInfo>): GCGCostReviseInfo {
        const message = { canUseHandCardIdList: [], playCardCostList: [], selectOnStageCostList: [], attackCostList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGCostReviseInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGCostReviseInfo): GCGCostReviseInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool is_can_attack */ 4:
                    message.isCanAttack = reader.bool();
                    break;
                case /* repeated uint32 can_use_hand_card_id_list */ 11:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.canUseHandCardIdList.push(reader.uint32());
                    else
                        message.canUseHandCardIdList.push(reader.uint32());
                    break;
                case /* repeated com.midnights.game.GCGPlayCardCostInfo play_card_cost_list */ 5:
                    message.playCardCostList.push(GCGPlayCardCostInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated com.midnights.game.GCGSelectOnStageCostInfo select_on_stage_cost_list */ 10:
                    message.selectOnStageCostList.push(GCGSelectOnStageCostInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated com.midnights.game.GCGAttackCostInfo attack_cost_list */ 2:
                    message.attackCostList.push(GCGAttackCostInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGCostReviseInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool is_can_attack = 4; */
        if (message.isCanAttack !== undefined)
            writer.tag(4, WireType.Varint).bool(message.isCanAttack);
        /* repeated uint32 can_use_hand_card_id_list = 11; */
        if (message.canUseHandCardIdList.length) {
            writer.tag(11, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.canUseHandCardIdList.length; i++)
                writer.uint32(message.canUseHandCardIdList[i]);
            writer.join();
        }
        /* repeated com.midnights.game.GCGPlayCardCostInfo play_card_cost_list = 5; */
        for (let i = 0; i < message.playCardCostList.length; i++)
            GCGPlayCardCostInfo.internalBinaryWrite(message.playCardCostList[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated com.midnights.game.GCGSelectOnStageCostInfo select_on_stage_cost_list = 10; */
        for (let i = 0; i < message.selectOnStageCostList.length; i++)
            GCGSelectOnStageCostInfo.internalBinaryWrite(message.selectOnStageCostList[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated com.midnights.game.GCGAttackCostInfo attack_cost_list = 2; */
        for (let i = 0; i < message.attackCostList.length; i++)
            GCGAttackCostInfo.internalBinaryWrite(message.attackCostList[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGCostReviseInfo
 */
export const GCGCostReviseInfo = new GCGCostReviseInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGMsgTokenChange$Type extends MessageType<GCGMsgTokenChange> {
    constructor() {
        super("com.midnights.game.GCGMsgTokenChange", [
            { no: 13, name: "before", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "token_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "card_guid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "after", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "reason", kind: "enum", opt: true, T: () => ["com.midnights.game.GCGReason", GCGReason] }
        ]);
    }
    create(value?: PartialMessage<GCGMsgTokenChange>): GCGMsgTokenChange {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGMsgTokenChange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGMsgTokenChange): GCGMsgTokenChange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 before */ 13:
                    message.before = reader.uint32();
                    break;
                case /* optional uint32 token_type */ 4:
                    message.tokenType = reader.uint32();
                    break;
                case /* optional uint32 card_guid */ 2:
                    message.cardGuid = reader.uint32();
                    break;
                case /* optional uint32 after */ 11:
                    message.after = reader.uint32();
                    break;
                case /* optional com.midnights.game.GCGReason reason */ 7:
                    message.reason = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGMsgTokenChange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 before = 13; */
        if (message.before !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.before);
        /* optional uint32 token_type = 4; */
        if (message.tokenType !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.tokenType);
        /* optional uint32 card_guid = 2; */
        if (message.cardGuid !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.cardGuid);
        /* optional uint32 after = 11; */
        if (message.after !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.after);
        /* optional com.midnights.game.GCGReason reason = 7; */
        if (message.reason !== undefined)
            writer.tag(7, WireType.Varint).int32(message.reason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGMsgTokenChange
 */
export const GCGMsgTokenChange = new GCGMsgTokenChange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGMsgPhaseChange$Type extends MessageType<GCGMsgPhaseChange> {
    constructor() {
        super("com.midnights.game.GCGMsgPhaseChange", [
            { no: 15, name: "allow_controller_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 12, name: "before_phase", kind: "enum", opt: true, T: () => ["com.midnights.game.GCGPhaseType", GCGPhaseType] },
            { no: 5, name: "after_phase", kind: "enum", opt: true, T: () => ["com.midnights.game.GCGPhaseType", GCGPhaseType] }
        ]);
    }
    create(value?: PartialMessage<GCGMsgPhaseChange>): GCGMsgPhaseChange {
        const message = { allowControllerMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGMsgPhaseChange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGMsgPhaseChange): GCGMsgPhaseChange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, uint32> allow_controller_map */ 15:
                    this.binaryReadMap15(message.allowControllerMap, reader, options);
                    break;
                case /* optional com.midnights.game.GCGPhaseType before_phase */ 12:
                    message.beforePhase = reader.int32();
                    break;
                case /* optional com.midnights.game.GCGPhaseType after_phase */ 5:
                    message.afterPhase = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap15(map: GCGMsgPhaseChange["allowControllerMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GCGMsgPhaseChange["allowControllerMap"] | undefined, val: GCGMsgPhaseChange["allowControllerMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field com.midnights.game.GCGMsgPhaseChange.allow_controller_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: GCGMsgPhaseChange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, uint32> allow_controller_map = 15; */
        for (let k of Object.keys(message.allowControllerMap))
            writer.tag(15, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.allowControllerMap[k as any]).join();
        /* optional com.midnights.game.GCGPhaseType before_phase = 12; */
        if (message.beforePhase !== undefined)
            writer.tag(12, WireType.Varint).int32(message.beforePhase);
        /* optional com.midnights.game.GCGPhaseType after_phase = 5; */
        if (message.afterPhase !== undefined)
            writer.tag(5, WireType.Varint).int32(message.afterPhase);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGMsgPhaseChange
 */
export const GCGMsgPhaseChange = new GCGMsgPhaseChange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGMsgAddCards$Type extends MessageType<GCGMsgAddCards> {
    constructor() {
        super("com.midnights.game.GCGMsgAddCards", [
            { no: 11, name: "pos", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "zone", kind: "enum", opt: true, T: () => ["com.midnights.game.GCGZoneType", GCGZoneType] },
            { no: 15, name: "reason", kind: "enum", opt: true, T: () => ["com.midnights.game.GCGReason", GCGReason] },
            { no: 13, name: "controller_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "card_guid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGMsgAddCards>): GCGMsgAddCards {
        const message = { cardGuidList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGMsgAddCards>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGMsgAddCards): GCGMsgAddCards {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 pos */ 11:
                    message.pos = reader.uint32();
                    break;
                case /* optional com.midnights.game.GCGZoneType zone */ 2:
                    message.zone = reader.int32();
                    break;
                case /* optional com.midnights.game.GCGReason reason */ 15:
                    message.reason = reader.int32();
                    break;
                case /* optional uint32 controller_id */ 13:
                    message.controllerId = reader.uint32();
                    break;
                case /* repeated uint32 card_guid_list */ 14:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.cardGuidList.push(reader.uint32());
                    else
                        message.cardGuidList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGMsgAddCards, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 pos = 11; */
        if (message.pos !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.pos);
        /* optional com.midnights.game.GCGZoneType zone = 2; */
        if (message.zone !== undefined)
            writer.tag(2, WireType.Varint).int32(message.zone);
        /* optional com.midnights.game.GCGReason reason = 15; */
        if (message.reason !== undefined)
            writer.tag(15, WireType.Varint).int32(message.reason);
        /* optional uint32 controller_id = 13; */
        if (message.controllerId !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.controllerId);
        /* repeated uint32 card_guid_list = 14; */
        if (message.cardGuidList.length) {
            writer.tag(14, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.cardGuidList.length; i++)
                writer.uint32(message.cardGuidList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGMsgAddCards
 */
export const GCGMsgAddCards = new GCGMsgAddCards$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGMsgRemoveCards$Type extends MessageType<GCGMsgRemoveCards> {
    constructor() {
        super("com.midnights.game.GCGMsgRemoveCards", [
            { no: 15, name: "controller_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "zone", kind: "enum", opt: true, T: () => ["com.midnights.game.GCGZoneType", GCGZoneType] },
            { no: 5, name: "reason", kind: "enum", opt: true, T: () => ["com.midnights.game.GCGReason", GCGReason] },
            { no: 1, name: "card_guid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGMsgRemoveCards>): GCGMsgRemoveCards {
        const message = { cardGuidList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGMsgRemoveCards>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGMsgRemoveCards): GCGMsgRemoveCards {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 controller_id */ 15:
                    message.controllerId = reader.uint32();
                    break;
                case /* optional com.midnights.game.GCGZoneType zone */ 10:
                    message.zone = reader.int32();
                    break;
                case /* optional com.midnights.game.GCGReason reason */ 5:
                    message.reason = reader.int32();
                    break;
                case /* repeated uint32 card_guid_list */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.cardGuidList.push(reader.uint32());
                    else
                        message.cardGuidList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGMsgRemoveCards, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 controller_id = 15; */
        if (message.controllerId !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.controllerId);
        /* optional com.midnights.game.GCGZoneType zone = 10; */
        if (message.zone !== undefined)
            writer.tag(10, WireType.Varint).int32(message.zone);
        /* optional com.midnights.game.GCGReason reason = 5; */
        if (message.reason !== undefined)
            writer.tag(5, WireType.Varint).int32(message.reason);
        /* repeated uint32 card_guid_list = 1; */
        if (message.cardGuidList.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.cardGuidList.length; i++)
                writer.uint32(message.cardGuidList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGMsgRemoveCards
 */
export const GCGMsgRemoveCards = new GCGMsgRemoveCards$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGMsgMoveCard$Type extends MessageType<GCGMsgMoveCard> {
    constructor() {
        super("com.midnights.game.GCGMsgMoveCard", [
            { no: 14, name: "controller_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "to", kind: "enum", opt: true, T: () => ["com.midnights.game.GCGZoneType", GCGZoneType] },
            { no: 12, name: "from", kind: "enum", opt: true, T: () => ["com.midnights.game.GCGZoneType", GCGZoneType] },
            { no: 10, name: "is_fail", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "card_guid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "reason", kind: "enum", opt: true, T: () => ["com.midnights.game.GCGReason", GCGReason] }
        ]);
    }
    create(value?: PartialMessage<GCGMsgMoveCard>): GCGMsgMoveCard {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGMsgMoveCard>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGMsgMoveCard): GCGMsgMoveCard {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 controller_id */ 14:
                    message.controllerId = reader.uint32();
                    break;
                case /* optional com.midnights.game.GCGZoneType to */ 5:
                    message.to = reader.int32();
                    break;
                case /* optional com.midnights.game.GCGZoneType from */ 12:
                    message.from = reader.int32();
                    break;
                case /* optional bool is_fail */ 10:
                    message.isFail = reader.bool();
                    break;
                case /* optional uint32 card_guid */ 7:
                    message.cardGuid = reader.uint32();
                    break;
                case /* optional com.midnights.game.GCGReason reason */ 6:
                    message.reason = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGMsgMoveCard, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 controller_id = 14; */
        if (message.controllerId !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.controllerId);
        /* optional com.midnights.game.GCGZoneType to = 5; */
        if (message.to !== undefined)
            writer.tag(5, WireType.Varint).int32(message.to);
        /* optional com.midnights.game.GCGZoneType from = 12; */
        if (message.from !== undefined)
            writer.tag(12, WireType.Varint).int32(message.from);
        /* optional bool is_fail = 10; */
        if (message.isFail !== undefined)
            writer.tag(10, WireType.Varint).bool(message.isFail);
        /* optional uint32 card_guid = 7; */
        if (message.cardGuid !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.cardGuid);
        /* optional com.midnights.game.GCGReason reason = 6; */
        if (message.reason !== undefined)
            writer.tag(6, WireType.Varint).int32(message.reason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGMsgMoveCard
 */
export const GCGMsgMoveCard = new GCGMsgMoveCard$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGMsgSelectOnStage$Type extends MessageType<GCGMsgSelectOnStage> {
    constructor() {
        super("com.midnights.game.GCGMsgSelectOnStage", [
            { no: 6, name: "controller_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "reason", kind: "enum", opt: true, T: () => ["com.midnights.game.GCGReason", GCGReason] },
            { no: 4, name: "card_guid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGMsgSelectOnStage>): GCGMsgSelectOnStage {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGMsgSelectOnStage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGMsgSelectOnStage): GCGMsgSelectOnStage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 controller_id */ 6:
                    message.controllerId = reader.uint32();
                    break;
                case /* optional com.midnights.game.GCGReason reason */ 10:
                    message.reason = reader.int32();
                    break;
                case /* optional uint32 card_guid */ 4:
                    message.cardGuid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGMsgSelectOnStage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 controller_id = 6; */
        if (message.controllerId !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.controllerId);
        /* optional com.midnights.game.GCGReason reason = 10; */
        if (message.reason !== undefined)
            writer.tag(10, WireType.Varint).int32(message.reason);
        /* optional uint32 card_guid = 4; */
        if (message.cardGuid !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.cardGuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGMsgSelectOnStage
 */
export const GCGMsgSelectOnStage = new GCGMsgSelectOnStage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGMsgSelectOnStageByEffect$Type extends MessageType<GCGMsgSelectOnStageByEffect> {
    constructor() {
        super("com.midnights.game.GCGMsgSelectOnStageByEffect", [
            { no: 12, name: "skill_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "controller_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "card_guid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGMsgSelectOnStageByEffect>): GCGMsgSelectOnStageByEffect {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGMsgSelectOnStageByEffect>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGMsgSelectOnStageByEffect): GCGMsgSelectOnStageByEffect {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 skill_id */ 12:
                    message.skillId = reader.uint32();
                    break;
                case /* optional uint32 controller_id */ 15:
                    message.controllerId = reader.uint32();
                    break;
                case /* optional uint32 card_guid */ 1:
                    message.cardGuid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGMsgSelectOnStageByEffect, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 skill_id = 12; */
        if (message.skillId !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.skillId);
        /* optional uint32 controller_id = 15; */
        if (message.controllerId !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.controllerId);
        /* optional uint32 card_guid = 1; */
        if (message.cardGuid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.cardGuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGMsgSelectOnStageByEffect
 */
export const GCGMsgSelectOnStageByEffect = new GCGMsgSelectOnStageByEffect$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGMsgDiceRoll$Type extends MessageType<GCGMsgDiceRoll> {
    constructor() {
        super("com.midnights.game.GCGMsgDiceRoll", [
            { no: 10, name: "dice_side_list", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["com.midnights.game.GCGDiceSideType", GCGDiceSideType] },
            { no: 15, name: "dice_num", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "controller_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGMsgDiceRoll>): GCGMsgDiceRoll {
        const message = { diceSideList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGMsgDiceRoll>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGMsgDiceRoll): GCGMsgDiceRoll {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated com.midnights.game.GCGDiceSideType dice_side_list */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.diceSideList.push(reader.int32());
                    else
                        message.diceSideList.push(reader.int32());
                    break;
                case /* optional uint32 dice_num */ 15:
                    message.diceNum = reader.uint32();
                    break;
                case /* optional uint32 controller_id */ 5:
                    message.controllerId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGMsgDiceRoll, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated com.midnights.game.GCGDiceSideType dice_side_list = 10; */
        if (message.diceSideList.length) {
            writer.tag(10, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.diceSideList.length; i++)
                writer.int32(message.diceSideList[i]);
            writer.join();
        }
        /* optional uint32 dice_num = 15; */
        if (message.diceNum !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.diceNum);
        /* optional uint32 controller_id = 5; */
        if (message.controllerId !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.controllerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGMsgDiceRoll
 */
export const GCGMsgDiceRoll = new GCGMsgDiceRoll$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGMsgDiceReroll$Type extends MessageType<GCGMsgDiceReroll> {
    constructor() {
        super("com.midnights.game.GCGMsgDiceReroll", [
            { no: 2, name: "controller_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "select_dice_index_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "dice_side_list", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["com.midnights.game.GCGDiceSideType", GCGDiceSideType] }
        ]);
    }
    create(value?: PartialMessage<GCGMsgDiceReroll>): GCGMsgDiceReroll {
        const message = { selectDiceIndexList: [], diceSideList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGMsgDiceReroll>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGMsgDiceReroll): GCGMsgDiceReroll {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 controller_id */ 2:
                    message.controllerId = reader.uint32();
                    break;
                case /* repeated uint32 select_dice_index_list */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.selectDiceIndexList.push(reader.uint32());
                    else
                        message.selectDiceIndexList.push(reader.uint32());
                    break;
                case /* repeated com.midnights.game.GCGDiceSideType dice_side_list */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.diceSideList.push(reader.int32());
                    else
                        message.diceSideList.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGMsgDiceReroll, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 controller_id = 2; */
        if (message.controllerId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.controllerId);
        /* repeated uint32 select_dice_index_list = 1; */
        if (message.selectDiceIndexList.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.selectDiceIndexList.length; i++)
                writer.uint32(message.selectDiceIndexList[i]);
            writer.join();
        }
        /* repeated com.midnights.game.GCGDiceSideType dice_side_list = 6; */
        if (message.diceSideList.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.diceSideList.length; i++)
                writer.int32(message.diceSideList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGMsgDiceReroll
 */
export const GCGMsgDiceReroll = new GCGMsgDiceReroll$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGMsgPass$Type extends MessageType<GCGMsgPass> {
    constructor() {
        super("com.midnights.game.GCGMsgPass", [
            { no: 14, name: "controller_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGMsgPass>): GCGMsgPass {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGMsgPass>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGMsgPass): GCGMsgPass {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 controller_id */ 14:
                    message.controllerId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGMsgPass, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 controller_id = 14; */
        if (message.controllerId !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.controllerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGMsgPass
 */
export const GCGMsgPass = new GCGMsgPass$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGMsgCharDie$Type extends MessageType<GCGMsgCharDie> {
    constructor() {
        super("com.midnights.game.GCGMsgCharDie", [
            { no: 5, name: "controller_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "card_guid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGMsgCharDie>): GCGMsgCharDie {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGMsgCharDie>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGMsgCharDie): GCGMsgCharDie {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 controller_id */ 5:
                    message.controllerId = reader.uint32();
                    break;
                case /* optional uint32 card_guid */ 11:
                    message.cardGuid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGMsgCharDie, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 controller_id = 5; */
        if (message.controllerId !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.controllerId);
        /* optional uint32 card_guid = 11; */
        if (message.cardGuid !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.cardGuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGMsgCharDie
 */
export const GCGMsgCharDie = new GCGMsgCharDie$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGMsgUseSkill$Type extends MessageType<GCGMsgUseSkill> {
    constructor() {
        super("com.midnights.game.GCGMsgUseSkill", [
            { no: 9, name: "skill_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "card_guid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGMsgUseSkill>): GCGMsgUseSkill {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGMsgUseSkill>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGMsgUseSkill): GCGMsgUseSkill {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 skill_id */ 9:
                    message.skillId = reader.uint32();
                    break;
                case /* optional uint32 card_guid */ 6:
                    message.cardGuid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGMsgUseSkill, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 skill_id = 9; */
        if (message.skillId !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.skillId);
        /* optional uint32 card_guid = 6; */
        if (message.cardGuid !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.cardGuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGMsgUseSkill
 */
export const GCGMsgUseSkill = new GCGMsgUseSkill$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGMsgUseSkillEnd$Type extends MessageType<GCGMsgUseSkillEnd> {
    constructor() {
        super("com.midnights.game.GCGMsgUseSkillEnd", [
            { no: 11, name: "card_guid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "skill_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGMsgUseSkillEnd>): GCGMsgUseSkillEnd {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGMsgUseSkillEnd>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGMsgUseSkillEnd): GCGMsgUseSkillEnd {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 card_guid */ 11:
                    message.cardGuid = reader.uint32();
                    break;
                case /* optional uint32 skill_id */ 12:
                    message.skillId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGMsgUseSkillEnd, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 card_guid = 11; */
        if (message.cardGuid !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.cardGuid);
        /* optional uint32 skill_id = 12; */
        if (message.skillId !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.skillId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGMsgUseSkillEnd
 */
export const GCGMsgUseSkillEnd = new GCGMsgUseSkillEnd$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGDamageDetail$Type extends MessageType<GCGDamageDetail> {
    constructor() {
        super("com.midnights.game.GCGDamageDetail", [
            { no: 10, name: "skill_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "card_guid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGDamageDetail>): GCGDamageDetail {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGDamageDetail>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGDamageDetail): GCGDamageDetail {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 skill_id */ 10:
                    message.skillId = reader.uint32();
                    break;
                case /* optional uint32 card_guid */ 7:
                    message.cardGuid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGDamageDetail, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 skill_id = 10; */
        if (message.skillId !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.skillId);
        /* optional uint32 card_guid = 7; */
        if (message.cardGuid !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.cardGuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGDamageDetail
 */
export const GCGDamageDetail = new GCGDamageDetail$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGMsgSkillResult$Type extends MessageType<GCGMsgSkillResult> {
    constructor() {
        super("com.midnights.game.GCGMsgSkillResult", [
            { no: 12, name: "skill_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "last_hp", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "detail_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GCGDamageDetail },
            { no: 7, name: "target_card_guid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "effect_element", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "from_result_seq", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "damage", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "result_seq", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "src_card_guid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGMsgSkillResult>): GCGMsgSkillResult {
        const message = { detailList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGMsgSkillResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGMsgSkillResult): GCGMsgSkillResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 skill_id */ 12:
                    message.skillId = reader.uint32();
                    break;
                case /* optional uint32 last_hp */ 14:
                    message.lastHp = reader.uint32();
                    break;
                case /* repeated com.midnights.game.GCGDamageDetail detail_list */ 2:
                    message.detailList.push(GCGDamageDetail.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 target_card_guid */ 7:
                    message.targetCardGuid = reader.uint32();
                    break;
                case /* optional uint32 effect_element */ 5:
                    message.effectElement = reader.uint32();
                    break;
                case /* optional uint32 from_result_seq */ 15:
                    message.fromResultSeq = reader.uint32();
                    break;
                case /* optional uint32 damage */ 6:
                    message.damage = reader.uint32();
                    break;
                case /* optional uint32 result_seq */ 4:
                    message.resultSeq = reader.uint32();
                    break;
                case /* optional uint32 src_card_guid */ 8:
                    message.srcCardGuid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGMsgSkillResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 skill_id = 12; */
        if (message.skillId !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.skillId);
        /* optional uint32 last_hp = 14; */
        if (message.lastHp !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.lastHp);
        /* repeated com.midnights.game.GCGDamageDetail detail_list = 2; */
        for (let i = 0; i < message.detailList.length; i++)
            GCGDamageDetail.internalBinaryWrite(message.detailList[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 target_card_guid = 7; */
        if (message.targetCardGuid !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.targetCardGuid);
        /* optional uint32 effect_element = 5; */
        if (message.effectElement !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.effectElement);
        /* optional uint32 from_result_seq = 15; */
        if (message.fromResultSeq !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.fromResultSeq);
        /* optional uint32 damage = 6; */
        if (message.damage !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.damage);
        /* optional uint32 result_seq = 4; */
        if (message.resultSeq !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.resultSeq);
        /* optional uint32 src_card_guid = 8; */
        if (message.srcCardGuid !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.srcCardGuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGMsgSkillResult
 */
export const GCGMsgSkillResult = new GCGMsgSkillResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGMsgCostDice$Type extends MessageType<GCGMsgCostDice> {
    constructor() {
        super("com.midnights.game.GCGMsgCostDice", [
            { no: 6, name: "controller_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "select_dice_index_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "reason", kind: "enum", opt: true, T: () => ["com.midnights.game.GCGReason", GCGReason] }
        ]);
    }
    create(value?: PartialMessage<GCGMsgCostDice>): GCGMsgCostDice {
        const message = { selectDiceIndexList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGMsgCostDice>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGMsgCostDice): GCGMsgCostDice {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 controller_id */ 6:
                    message.controllerId = reader.uint32();
                    break;
                case /* repeated uint32 select_dice_index_list */ 13:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.selectDiceIndexList.push(reader.uint32());
                    else
                        message.selectDiceIndexList.push(reader.uint32());
                    break;
                case /* optional com.midnights.game.GCGReason reason */ 9:
                    message.reason = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGMsgCostDice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 controller_id = 6; */
        if (message.controllerId !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.controllerId);
        /* repeated uint32 select_dice_index_list = 13; */
        if (message.selectDiceIndexList.length) {
            writer.tag(13, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.selectDiceIndexList.length; i++)
                writer.uint32(message.selectDiceIndexList[i]);
            writer.join();
        }
        /* optional com.midnights.game.GCGReason reason = 9; */
        if (message.reason !== undefined)
            writer.tag(9, WireType.Varint).int32(message.reason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGMsgCostDice
 */
export const GCGMsgCostDice = new GCGMsgCostDice$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGMsgAddDice$Type extends MessageType<GCGMsgAddDice> {
    constructor() {
        super("com.midnights.game.GCGMsgAddDice", [
            { no: 4, name: "reason", kind: "enum", opt: true, T: () => ["com.midnights.game.GCGReason", GCGReason] },
            { no: 10, name: "controller_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "change_count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "dice_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "enum", T: () => ["com.midnights.game.GCGDiceSideType", GCGDiceSideType] } }
        ]);
    }
    create(value?: PartialMessage<GCGMsgAddDice>): GCGMsgAddDice {
        const message = { diceMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGMsgAddDice>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGMsgAddDice): GCGMsgAddDice {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.GCGReason reason */ 4:
                    message.reason = reader.int32();
                    break;
                case /* optional uint32 controller_id */ 10:
                    message.controllerId = reader.uint32();
                    break;
                case /* optional int32 change_count */ 1:
                    message.changeCount = reader.int32();
                    break;
                case /* map<uint32, com.midnights.game.GCGDiceSideType> dice_map */ 8:
                    this.binaryReadMap8(message.diceMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap8(map: GCGMsgAddDice["diceMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GCGMsgAddDice["diceMap"] | undefined, val: GCGMsgAddDice["diceMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field com.midnights.game.GCGMsgAddDice.dice_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: GCGMsgAddDice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.GCGReason reason = 4; */
        if (message.reason !== undefined)
            writer.tag(4, WireType.Varint).int32(message.reason);
        /* optional uint32 controller_id = 10; */
        if (message.controllerId !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.controllerId);
        /* optional int32 change_count = 1; */
        if (message.changeCount !== undefined)
            writer.tag(1, WireType.Varint).int32(message.changeCount);
        /* map<uint32, com.midnights.game.GCGDiceSideType> dice_map = 8; */
        for (let k of Object.keys(message.diceMap))
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).int32(message.diceMap[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGMsgAddDice
 */
export const GCGMsgAddDice = new GCGMsgAddDice$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGMsgNewCard$Type extends MessageType<GCGMsgNewCard> {
    constructor() {
        super("com.midnights.game.GCGMsgNewCard", [
            { no: 15, name: "card", kind: "message", T: () => GCGCard }
        ]);
    }
    create(value?: PartialMessage<GCGMsgNewCard>): GCGMsgNewCard {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGMsgNewCard>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGMsgNewCard): GCGMsgNewCard {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.GCGCard card */ 15:
                    message.card = GCGCard.internalBinaryRead(reader, reader.uint32(), options, message.card);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGMsgNewCard, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.GCGCard card = 15; */
        if (message.card)
            GCGCard.internalBinaryWrite(message.card, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGMsgNewCard
 */
export const GCGMsgNewCard = new GCGMsgNewCard$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGMsgUpdateController$Type extends MessageType<GCGMsgUpdateController> {
    constructor() {
        super("com.midnights.game.GCGMsgUpdateController", [
            { no: 7, name: "allow_controller_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } }
        ]);
    }
    create(value?: PartialMessage<GCGMsgUpdateController>): GCGMsgUpdateController {
        const message = { allowControllerMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGMsgUpdateController>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGMsgUpdateController): GCGMsgUpdateController {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, uint32> allow_controller_map */ 7:
                    this.binaryReadMap7(message.allowControllerMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap7(map: GCGMsgUpdateController["allowControllerMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GCGMsgUpdateController["allowControllerMap"] | undefined, val: GCGMsgUpdateController["allowControllerMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field com.midnights.game.GCGMsgUpdateController.allow_controller_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: GCGMsgUpdateController, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, uint32> allow_controller_map = 7; */
        for (let k of Object.keys(message.allowControllerMap))
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.allowControllerMap[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGMsgUpdateController
 */
export const GCGMsgUpdateController = new GCGMsgUpdateController$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGMsgModifyAdd$Type extends MessageType<GCGMsgModifyAdd> {
    constructor() {
        super("com.midnights.game.GCGMsgModifyAdd", [
            { no: 9, name: "pos", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "owner_card_guid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "card_guid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "controller_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "reason", kind: "enum", opt: true, T: () => ["com.midnights.game.GCGReason", GCGReason] }
        ]);
    }
    create(value?: PartialMessage<GCGMsgModifyAdd>): GCGMsgModifyAdd {
        const message = { cardGuidList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGMsgModifyAdd>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGMsgModifyAdd): GCGMsgModifyAdd {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 pos */ 9:
                    message.pos = reader.uint32();
                    break;
                case /* optional uint32 owner_card_guid */ 10:
                    message.ownerCardGuid = reader.uint32();
                    break;
                case /* repeated uint32 card_guid_list */ 15:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.cardGuidList.push(reader.uint32());
                    else
                        message.cardGuidList.push(reader.uint32());
                    break;
                case /* optional uint32 controller_id */ 14:
                    message.controllerId = reader.uint32();
                    break;
                case /* optional com.midnights.game.GCGReason reason */ 11:
                    message.reason = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGMsgModifyAdd, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 pos = 9; */
        if (message.pos !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.pos);
        /* optional uint32 owner_card_guid = 10; */
        if (message.ownerCardGuid !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.ownerCardGuid);
        /* repeated uint32 card_guid_list = 15; */
        if (message.cardGuidList.length) {
            writer.tag(15, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.cardGuidList.length; i++)
                writer.uint32(message.cardGuidList[i]);
            writer.join();
        }
        /* optional uint32 controller_id = 14; */
        if (message.controllerId !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.controllerId);
        /* optional com.midnights.game.GCGReason reason = 11; */
        if (message.reason !== undefined)
            writer.tag(11, WireType.Varint).int32(message.reason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGMsgModifyAdd
 */
export const GCGMsgModifyAdd = new GCGMsgModifyAdd$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGMsgModifyRemove$Type extends MessageType<GCGMsgModifyRemove> {
    constructor() {
        super("com.midnights.game.GCGMsgModifyRemove", [
            { no: 14, name: "controller_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "reason", kind: "enum", opt: true, T: () => ["com.midnights.game.GCGReason", GCGReason] },
            { no: 5, name: "owner_card_guid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "card_guid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGMsgModifyRemove>): GCGMsgModifyRemove {
        const message = { cardGuidList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGMsgModifyRemove>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGMsgModifyRemove): GCGMsgModifyRemove {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 controller_id */ 14:
                    message.controllerId = reader.uint32();
                    break;
                case /* optional com.midnights.game.GCGReason reason */ 12:
                    message.reason = reader.int32();
                    break;
                case /* optional uint32 owner_card_guid */ 5:
                    message.ownerCardGuid = reader.uint32();
                    break;
                case /* repeated uint32 card_guid_list */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.cardGuidList.push(reader.uint32());
                    else
                        message.cardGuidList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGMsgModifyRemove, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 controller_id = 14; */
        if (message.controllerId !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.controllerId);
        /* optional com.midnights.game.GCGReason reason = 12; */
        if (message.reason !== undefined)
            writer.tag(12, WireType.Varint).int32(message.reason);
        /* optional uint32 owner_card_guid = 5; */
        if (message.ownerCardGuid !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.ownerCardGuid);
        /* repeated uint32 card_guid_list = 4; */
        if (message.cardGuidList.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.cardGuidList.length; i++)
                writer.uint32(message.cardGuidList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGMsgModifyRemove
 */
export const GCGMsgModifyRemove = new GCGMsgModifyRemove$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGMsgPVEGenCardOp$Type extends MessageType<GCGMsgPVEGenCardOp> {
    constructor() {
        super("com.midnights.game.GCGMsgPVEGenCardOp", [
            { no: 1, name: "skill_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "card_guid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGMsgPVEGenCardOp>): GCGMsgPVEGenCardOp {
        const message = { skillIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGMsgPVEGenCardOp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGMsgPVEGenCardOp): GCGMsgPVEGenCardOp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 skill_id_list */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.skillIdList.push(reader.uint32());
                    else
                        message.skillIdList.push(reader.uint32());
                    break;
                case /* optional uint32 card_guid */ 11:
                    message.cardGuid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGMsgPVEGenCardOp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 skill_id_list = 1; */
        if (message.skillIdList.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.skillIdList.length; i++)
                writer.uint32(message.skillIdList[i]);
            writer.join();
        }
        /* optional uint32 card_guid = 11; */
        if (message.cardGuid !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.cardGuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGMsgPVEGenCardOp
 */
export const GCGMsgPVEGenCardOp = new GCGMsgPVEGenCardOp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGMsgPVEDoOp$Type extends MessageType<GCGMsgPVEDoOp> {
    constructor() {
        super("com.midnights.game.GCGMsgPVEDoOp", [
            { no: 4, name: "skill_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "card_guid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGMsgPVEDoOp>): GCGMsgPVEDoOp {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGMsgPVEDoOp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGMsgPVEDoOp): GCGMsgPVEDoOp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 skill_id */ 4:
                    message.skillId = reader.uint32();
                    break;
                case /* optional uint32 card_guid */ 10:
                    message.cardGuid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGMsgPVEDoOp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 skill_id = 4; */
        if (message.skillId !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.skillId);
        /* optional uint32 card_guid = 10; */
        if (message.cardGuid !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.cardGuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGMsgPVEDoOp
 */
export const GCGMsgPVEDoOp = new GCGMsgPVEDoOp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGMsgDuelDataChange$Type extends MessageType<GCGMsgDuelDataChange> {
    constructor() {
        super("com.midnights.game.GCGMsgDuelDataChange", [
            { no: 14, name: "round", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGMsgDuelDataChange>): GCGMsgDuelDataChange {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGMsgDuelDataChange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGMsgDuelDataChange): GCGMsgDuelDataChange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 round */ 14:
                    message.round = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGMsgDuelDataChange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 round = 14; */
        if (message.round !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.round);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGMsgDuelDataChange
 */
export const GCGMsgDuelDataChange = new GCGMsgDuelDataChange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGMsgClientPerform$Type extends MessageType<GCGMsgClientPerform> {
    constructor() {
        super("com.midnights.game.GCGMsgClientPerform", [
            { no: 2, name: "param_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "perform_type", kind: "enum", opt: true, T: () => ["com.midnights.game.GCGClientPerformType", GCGClientPerformType] }
        ]);
    }
    create(value?: PartialMessage<GCGMsgClientPerform>): GCGMsgClientPerform {
        const message = { paramList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGMsgClientPerform>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGMsgClientPerform): GCGMsgClientPerform {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 param_list */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.paramList.push(reader.uint32());
                    else
                        message.paramList.push(reader.uint32());
                    break;
                case /* optional com.midnights.game.GCGClientPerformType perform_type */ 5:
                    message.performType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGMsgClientPerform, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 param_list = 2; */
        if (message.paramList.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.paramList.length; i++)
                writer.uint32(message.paramList[i]);
            writer.join();
        }
        /* optional com.midnights.game.GCGClientPerformType perform_type = 5; */
        if (message.performType !== undefined)
            writer.tag(5, WireType.Varint).int32(message.performType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGMsgClientPerform
 */
export const GCGMsgClientPerform = new GCGMsgClientPerform$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGMsgGameOver$Type extends MessageType<GCGMsgGameOver> {
    constructor() {
        super("com.midnights.game.GCGMsgGameOver", [
            { no: 13, name: "end_reason", kind: "enum", opt: true, T: () => ["com.midnights.game.GCGEndReason", GCGEndReason] },
            { no: 6, name: "win_controller_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGMsgGameOver>): GCGMsgGameOver {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGMsgGameOver>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGMsgGameOver): GCGMsgGameOver {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.GCGEndReason end_reason */ 13:
                    message.endReason = reader.int32();
                    break;
                case /* optional uint32 win_controller_id */ 6:
                    message.winControllerId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGMsgGameOver, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.GCGEndReason end_reason = 13; */
        if (message.endReason !== undefined)
            writer.tag(13, WireType.Varint).int32(message.endReason);
        /* optional uint32 win_controller_id = 6; */
        if (message.winControllerId !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.winControllerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGMsgGameOver
 */
export const GCGMsgGameOver = new GCGMsgGameOver$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGMsgOpTimer$Type extends MessageType<GCGMsgOpTimer> {
    constructor() {
        super("com.midnights.game.GCGMsgOpTimer", [
            { no: 9, name: "begin_time", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "phase", kind: "enum", opt: true, T: () => ["com.midnights.game.GCGPhaseType", GCGPhaseType] },
            { no: 13, name: "time_stamp", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "controller_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGMsgOpTimer>): GCGMsgOpTimer {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGMsgOpTimer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGMsgOpTimer): GCGMsgOpTimer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 begin_time */ 9:
                    message.beginTime = reader.fixed64().toBigInt();
                    break;
                case /* optional com.midnights.game.GCGPhaseType phase */ 3:
                    message.phase = reader.int32();
                    break;
                case /* optional fixed64 time_stamp */ 13:
                    message.timeStamp = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 controller_id */ 8:
                    message.controllerId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGMsgOpTimer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 begin_time = 9; */
        if (message.beginTime !== undefined)
            writer.tag(9, WireType.Bit64).fixed64(message.beginTime);
        /* optional com.midnights.game.GCGPhaseType phase = 3; */
        if (message.phase !== undefined)
            writer.tag(3, WireType.Varint).int32(message.phase);
        /* optional fixed64 time_stamp = 13; */
        if (message.timeStamp !== undefined)
            writer.tag(13, WireType.Bit64).fixed64(message.timeStamp);
        /* optional uint32 controller_id = 8; */
        if (message.controllerId !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.controllerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGMsgOpTimer
 */
export const GCGMsgOpTimer = new GCGMsgOpTimer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGMsgWaitingListChange$Type extends MessageType<GCGMsgWaitingListChange> {
    constructor() {
        super("com.midnights.game.GCGMsgWaitingListChange", [
            { no: 6, name: "cur_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "controller_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGMsgWaitingListChange>): GCGMsgWaitingListChange {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGMsgWaitingListChange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGMsgWaitingListChange): GCGMsgWaitingListChange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 cur_index */ 6:
                    message.curIndex = reader.uint32();
                    break;
                case /* optional uint32 controller_id */ 4:
                    message.controllerId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGMsgWaitingListChange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 cur_index = 6; */
        if (message.curIndex !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.curIndex);
        /* optional uint32 controller_id = 4; */
        if (message.controllerId !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.controllerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGMsgWaitingListChange
 */
export const GCGMsgWaitingListChange = new GCGMsgWaitingListChange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGMsgCardUpdate$Type extends MessageType<GCGMsgCardUpdate> {
    constructor() {
        super("com.midnights.game.GCGMsgCardUpdate", [
            { no: 7, name: "card", kind: "message", T: () => GCGCard }
        ]);
    }
    create(value?: PartialMessage<GCGMsgCardUpdate>): GCGMsgCardUpdate {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGMsgCardUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGMsgCardUpdate): GCGMsgCardUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.GCGCard card */ 7:
                    message.card = GCGCard.internalBinaryRead(reader, reader.uint32(), options, message.card);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGMsgCardUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.GCGCard card = 7; */
        if (message.card)
            GCGCard.internalBinaryWrite(message.card, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGMsgCardUpdate
 */
export const GCGMsgCardUpdate = new GCGMsgCardUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGMsgCostRevise$Type extends MessageType<GCGMsgCostRevise> {
    constructor() {
        super("com.midnights.game.GCGMsgCostRevise", [
            { no: 5, name: "controller_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "cost_revise", kind: "message", T: () => GCGCostReviseInfo }
        ]);
    }
    create(value?: PartialMessage<GCGMsgCostRevise>): GCGMsgCostRevise {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGMsgCostRevise>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGMsgCostRevise): GCGMsgCostRevise {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 controller_id */ 5:
                    message.controllerId = reader.uint32();
                    break;
                case /* optional com.midnights.game.GCGCostReviseInfo cost_revise */ 13:
                    message.costRevise = GCGCostReviseInfo.internalBinaryRead(reader, reader.uint32(), options, message.costRevise);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGMsgCostRevise, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 controller_id = 5; */
        if (message.controllerId !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.controllerId);
        /* optional com.midnights.game.GCGCostReviseInfo cost_revise = 13; */
        if (message.costRevise)
            GCGCostReviseInfo.internalBinaryWrite(message.costRevise, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGMsgCostRevise
 */
export const GCGMsgCostRevise = new GCGMsgCostRevise$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGMessage$Type extends MessageType<GCGMessage> {
    constructor() {
        super("com.midnights.game.GCGMessage", [
            { no: 12, name: "token_change", kind: "message", oneof: "message", T: () => GCGMsgTokenChange },
            { no: 13, name: "phase_change", kind: "message", oneof: "message", T: () => GCGMsgPhaseChange },
            { no: 10, name: "add_cards", kind: "message", oneof: "message", T: () => GCGMsgAddCards },
            { no: 14, name: "remove_cards", kind: "message", oneof: "message", T: () => GCGMsgRemoveCards },
            { no: 6, name: "select_on_stage", kind: "message", oneof: "message", T: () => GCGMsgSelectOnStage },
            { no: 9, name: "dice_roll", kind: "message", oneof: "message", T: () => GCGMsgDiceRoll },
            { no: 11, name: "dice_reroll", kind: "message", oneof: "message", T: () => GCGMsgDiceReroll },
            { no: 5, name: "pass", kind: "message", oneof: "message", T: () => GCGMsgPass },
            { no: 2, name: "char_die", kind: "message", oneof: "message", T: () => GCGMsgCharDie },
            { no: 1, name: "skill_result", kind: "message", oneof: "message", T: () => GCGMsgSkillResult },
            { no: 7, name: "cost_dice", kind: "message", oneof: "message", T: () => GCGMsgCostDice },
            { no: 3, name: "add_dice", kind: "message", oneof: "message", T: () => GCGMsgAddDice },
            { no: 15, name: "move_card", kind: "message", oneof: "message", T: () => GCGMsgMoveCard },
            { no: 4, name: "use_skill", kind: "message", oneof: "message", T: () => GCGMsgUseSkill },
            { no: 1848, name: "new_card", kind: "message", oneof: "message", T: () => GCGMsgNewCard },
            { no: 429, name: "update_controller", kind: "message", oneof: "message", T: () => GCGMsgUpdateController },
            { no: 1851, name: "modify_add", kind: "message", oneof: "message", T: () => GCGMsgModifyAdd },
            { no: 471, name: "modify_remove", kind: "message", oneof: "message", T: () => GCGMsgModifyRemove },
            { no: 1411, name: "use_skill_end", kind: "message", oneof: "message", T: () => GCGMsgUseSkillEnd },
            { no: 1741, name: "pve_gen_card_op", kind: "message", oneof: "message", T: () => GCGMsgPVEGenCardOp },
            { no: 614, name: "pve_do_op", kind: "message", oneof: "message", T: () => GCGMsgPVEDoOp },
            { no: 1008, name: "duel_data_change", kind: "message", oneof: "message", T: () => GCGMsgDuelDataChange },
            { no: 1035, name: "client_perform", kind: "message", oneof: "message", T: () => GCGMsgClientPerform },
            { no: 714, name: "game_over", kind: "message", oneof: "message", T: () => GCGMsgGameOver },
            { no: 1862, name: "op_timer", kind: "message", oneof: "message", T: () => GCGMsgOpTimer },
            { no: 1678, name: "waiting_list_change", kind: "message", oneof: "message", T: () => GCGMsgWaitingListChange },
            { no: 1879, name: "card_update", kind: "message", oneof: "message", T: () => GCGMsgCardUpdate },
            { no: 2042, name: "select_on_stage_by_effect", kind: "message", oneof: "message", T: () => GCGMsgSelectOnStageByEffect },
            { no: 1350, name: "cost_revise", kind: "message", oneof: "message", T: () => GCGMsgCostRevise }
        ]);
    }
    create(value?: PartialMessage<GCGMessage>): GCGMessage {
        const message = { message: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGMessage): GCGMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* com.midnights.game.GCGMsgTokenChange token_change */ 12:
                    message.message = {
                        oneofKind: "tokenChange",
                        tokenChange: GCGMsgTokenChange.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).tokenChange)
                    };
                    break;
                case /* com.midnights.game.GCGMsgPhaseChange phase_change */ 13:
                    message.message = {
                        oneofKind: "phaseChange",
                        phaseChange: GCGMsgPhaseChange.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).phaseChange)
                    };
                    break;
                case /* com.midnights.game.GCGMsgAddCards add_cards */ 10:
                    message.message = {
                        oneofKind: "addCards",
                        addCards: GCGMsgAddCards.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).addCards)
                    };
                    break;
                case /* com.midnights.game.GCGMsgRemoveCards remove_cards */ 14:
                    message.message = {
                        oneofKind: "removeCards",
                        removeCards: GCGMsgRemoveCards.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).removeCards)
                    };
                    break;
                case /* com.midnights.game.GCGMsgSelectOnStage select_on_stage */ 6:
                    message.message = {
                        oneofKind: "selectOnStage",
                        selectOnStage: GCGMsgSelectOnStage.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).selectOnStage)
                    };
                    break;
                case /* com.midnights.game.GCGMsgDiceRoll dice_roll */ 9:
                    message.message = {
                        oneofKind: "diceRoll",
                        diceRoll: GCGMsgDiceRoll.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).diceRoll)
                    };
                    break;
                case /* com.midnights.game.GCGMsgDiceReroll dice_reroll */ 11:
                    message.message = {
                        oneofKind: "diceReroll",
                        diceReroll: GCGMsgDiceReroll.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).diceReroll)
                    };
                    break;
                case /* com.midnights.game.GCGMsgPass pass */ 5:
                    message.message = {
                        oneofKind: "pass",
                        pass: GCGMsgPass.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).pass)
                    };
                    break;
                case /* com.midnights.game.GCGMsgCharDie char_die */ 2:
                    message.message = {
                        oneofKind: "charDie",
                        charDie: GCGMsgCharDie.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).charDie)
                    };
                    break;
                case /* com.midnights.game.GCGMsgSkillResult skill_result */ 1:
                    message.message = {
                        oneofKind: "skillResult",
                        skillResult: GCGMsgSkillResult.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).skillResult)
                    };
                    break;
                case /* com.midnights.game.GCGMsgCostDice cost_dice */ 7:
                    message.message = {
                        oneofKind: "costDice",
                        costDice: GCGMsgCostDice.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).costDice)
                    };
                    break;
                case /* com.midnights.game.GCGMsgAddDice add_dice */ 3:
                    message.message = {
                        oneofKind: "addDice",
                        addDice: GCGMsgAddDice.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).addDice)
                    };
                    break;
                case /* com.midnights.game.GCGMsgMoveCard move_card */ 15:
                    message.message = {
                        oneofKind: "moveCard",
                        moveCard: GCGMsgMoveCard.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).moveCard)
                    };
                    break;
                case /* com.midnights.game.GCGMsgUseSkill use_skill */ 4:
                    message.message = {
                        oneofKind: "useSkill",
                        useSkill: GCGMsgUseSkill.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).useSkill)
                    };
                    break;
                case /* com.midnights.game.GCGMsgNewCard new_card */ 1848:
                    message.message = {
                        oneofKind: "newCard",
                        newCard: GCGMsgNewCard.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).newCard)
                    };
                    break;
                case /* com.midnights.game.GCGMsgUpdateController update_controller */ 429:
                    message.message = {
                        oneofKind: "updateController",
                        updateController: GCGMsgUpdateController.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).updateController)
                    };
                    break;
                case /* com.midnights.game.GCGMsgModifyAdd modify_add */ 1851:
                    message.message = {
                        oneofKind: "modifyAdd",
                        modifyAdd: GCGMsgModifyAdd.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).modifyAdd)
                    };
                    break;
                case /* com.midnights.game.GCGMsgModifyRemove modify_remove */ 471:
                    message.message = {
                        oneofKind: "modifyRemove",
                        modifyRemove: GCGMsgModifyRemove.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).modifyRemove)
                    };
                    break;
                case /* com.midnights.game.GCGMsgUseSkillEnd use_skill_end */ 1411:
                    message.message = {
                        oneofKind: "useSkillEnd",
                        useSkillEnd: GCGMsgUseSkillEnd.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).useSkillEnd)
                    };
                    break;
                case /* com.midnights.game.GCGMsgPVEGenCardOp pve_gen_card_op */ 1741:
                    message.message = {
                        oneofKind: "pveGenCardOp",
                        pveGenCardOp: GCGMsgPVEGenCardOp.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).pveGenCardOp)
                    };
                    break;
                case /* com.midnights.game.GCGMsgPVEDoOp pve_do_op */ 614:
                    message.message = {
                        oneofKind: "pveDoOp",
                        pveDoOp: GCGMsgPVEDoOp.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).pveDoOp)
                    };
                    break;
                case /* com.midnights.game.GCGMsgDuelDataChange duel_data_change */ 1008:
                    message.message = {
                        oneofKind: "duelDataChange",
                        duelDataChange: GCGMsgDuelDataChange.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).duelDataChange)
                    };
                    break;
                case /* com.midnights.game.GCGMsgClientPerform client_perform */ 1035:
                    message.message = {
                        oneofKind: "clientPerform",
                        clientPerform: GCGMsgClientPerform.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).clientPerform)
                    };
                    break;
                case /* com.midnights.game.GCGMsgGameOver game_over */ 714:
                    message.message = {
                        oneofKind: "gameOver",
                        gameOver: GCGMsgGameOver.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).gameOver)
                    };
                    break;
                case /* com.midnights.game.GCGMsgOpTimer op_timer */ 1862:
                    message.message = {
                        oneofKind: "opTimer",
                        opTimer: GCGMsgOpTimer.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).opTimer)
                    };
                    break;
                case /* com.midnights.game.GCGMsgWaitingListChange waiting_list_change */ 1678:
                    message.message = {
                        oneofKind: "waitingListChange",
                        waitingListChange: GCGMsgWaitingListChange.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).waitingListChange)
                    };
                    break;
                case /* com.midnights.game.GCGMsgCardUpdate card_update */ 1879:
                    message.message = {
                        oneofKind: "cardUpdate",
                        cardUpdate: GCGMsgCardUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).cardUpdate)
                    };
                    break;
                case /* com.midnights.game.GCGMsgSelectOnStageByEffect select_on_stage_by_effect */ 2042:
                    message.message = {
                        oneofKind: "selectOnStageByEffect",
                        selectOnStageByEffect: GCGMsgSelectOnStageByEffect.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).selectOnStageByEffect)
                    };
                    break;
                case /* com.midnights.game.GCGMsgCostRevise cost_revise */ 1350:
                    message.message = {
                        oneofKind: "costRevise",
                        costRevise: GCGMsgCostRevise.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).costRevise)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* com.midnights.game.GCGMsgTokenChange token_change = 12; */
        if (message.message.oneofKind === "tokenChange")
            GCGMsgTokenChange.internalBinaryWrite(message.message.tokenChange, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGMsgPhaseChange phase_change = 13; */
        if (message.message.oneofKind === "phaseChange")
            GCGMsgPhaseChange.internalBinaryWrite(message.message.phaseChange, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGMsgAddCards add_cards = 10; */
        if (message.message.oneofKind === "addCards")
            GCGMsgAddCards.internalBinaryWrite(message.message.addCards, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGMsgRemoveCards remove_cards = 14; */
        if (message.message.oneofKind === "removeCards")
            GCGMsgRemoveCards.internalBinaryWrite(message.message.removeCards, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGMsgSelectOnStage select_on_stage = 6; */
        if (message.message.oneofKind === "selectOnStage")
            GCGMsgSelectOnStage.internalBinaryWrite(message.message.selectOnStage, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGMsgDiceRoll dice_roll = 9; */
        if (message.message.oneofKind === "diceRoll")
            GCGMsgDiceRoll.internalBinaryWrite(message.message.diceRoll, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGMsgDiceReroll dice_reroll = 11; */
        if (message.message.oneofKind === "diceReroll")
            GCGMsgDiceReroll.internalBinaryWrite(message.message.diceReroll, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGMsgPass pass = 5; */
        if (message.message.oneofKind === "pass")
            GCGMsgPass.internalBinaryWrite(message.message.pass, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGMsgCharDie char_die = 2; */
        if (message.message.oneofKind === "charDie")
            GCGMsgCharDie.internalBinaryWrite(message.message.charDie, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGMsgSkillResult skill_result = 1; */
        if (message.message.oneofKind === "skillResult")
            GCGMsgSkillResult.internalBinaryWrite(message.message.skillResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGMsgCostDice cost_dice = 7; */
        if (message.message.oneofKind === "costDice")
            GCGMsgCostDice.internalBinaryWrite(message.message.costDice, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGMsgAddDice add_dice = 3; */
        if (message.message.oneofKind === "addDice")
            GCGMsgAddDice.internalBinaryWrite(message.message.addDice, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGMsgMoveCard move_card = 15; */
        if (message.message.oneofKind === "moveCard")
            GCGMsgMoveCard.internalBinaryWrite(message.message.moveCard, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGMsgUseSkill use_skill = 4; */
        if (message.message.oneofKind === "useSkill")
            GCGMsgUseSkill.internalBinaryWrite(message.message.useSkill, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGMsgNewCard new_card = 1848; */
        if (message.message.oneofKind === "newCard")
            GCGMsgNewCard.internalBinaryWrite(message.message.newCard, writer.tag(1848, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGMsgUpdateController update_controller = 429; */
        if (message.message.oneofKind === "updateController")
            GCGMsgUpdateController.internalBinaryWrite(message.message.updateController, writer.tag(429, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGMsgModifyAdd modify_add = 1851; */
        if (message.message.oneofKind === "modifyAdd")
            GCGMsgModifyAdd.internalBinaryWrite(message.message.modifyAdd, writer.tag(1851, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGMsgModifyRemove modify_remove = 471; */
        if (message.message.oneofKind === "modifyRemove")
            GCGMsgModifyRemove.internalBinaryWrite(message.message.modifyRemove, writer.tag(471, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGMsgUseSkillEnd use_skill_end = 1411; */
        if (message.message.oneofKind === "useSkillEnd")
            GCGMsgUseSkillEnd.internalBinaryWrite(message.message.useSkillEnd, writer.tag(1411, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGMsgPVEGenCardOp pve_gen_card_op = 1741; */
        if (message.message.oneofKind === "pveGenCardOp")
            GCGMsgPVEGenCardOp.internalBinaryWrite(message.message.pveGenCardOp, writer.tag(1741, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGMsgPVEDoOp pve_do_op = 614; */
        if (message.message.oneofKind === "pveDoOp")
            GCGMsgPVEDoOp.internalBinaryWrite(message.message.pveDoOp, writer.tag(614, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGMsgDuelDataChange duel_data_change = 1008; */
        if (message.message.oneofKind === "duelDataChange")
            GCGMsgDuelDataChange.internalBinaryWrite(message.message.duelDataChange, writer.tag(1008, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGMsgClientPerform client_perform = 1035; */
        if (message.message.oneofKind === "clientPerform")
            GCGMsgClientPerform.internalBinaryWrite(message.message.clientPerform, writer.tag(1035, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGMsgGameOver game_over = 714; */
        if (message.message.oneofKind === "gameOver")
            GCGMsgGameOver.internalBinaryWrite(message.message.gameOver, writer.tag(714, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGMsgOpTimer op_timer = 1862; */
        if (message.message.oneofKind === "opTimer")
            GCGMsgOpTimer.internalBinaryWrite(message.message.opTimer, writer.tag(1862, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGMsgWaitingListChange waiting_list_change = 1678; */
        if (message.message.oneofKind === "waitingListChange")
            GCGMsgWaitingListChange.internalBinaryWrite(message.message.waitingListChange, writer.tag(1678, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGMsgCardUpdate card_update = 1879; */
        if (message.message.oneofKind === "cardUpdate")
            GCGMsgCardUpdate.internalBinaryWrite(message.message.cardUpdate, writer.tag(1879, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGMsgSelectOnStageByEffect select_on_stage_by_effect = 2042; */
        if (message.message.oneofKind === "selectOnStageByEffect")
            GCGMsgSelectOnStageByEffect.internalBinaryWrite(message.message.selectOnStageByEffect, writer.tag(2042, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGMsgCostRevise cost_revise = 1350; */
        if (message.message.oneofKind === "costRevise")
            GCGMsgCostRevise.internalBinaryWrite(message.message.costRevise, writer.tag(1350, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGMessage
 */
export const GCGMessage = new GCGMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGMessagePack$Type extends MessageType<GCGMessagePack> {
    constructor() {
        super("com.midnights.game.GCGMessagePack", [
            { no: 10, name: "msg_seq", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "msg_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GCGMessage }
        ]);
    }
    create(value?: PartialMessage<GCGMessagePack>): GCGMessagePack {
        const message = { msgList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGMessagePack>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGMessagePack): GCGMessagePack {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 msg_seq */ 10:
                    message.msgSeq = reader.uint32();
                    break;
                case /* repeated com.midnights.game.GCGMessage msg_list */ 13:
                    message.msgList.push(GCGMessage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGMessagePack, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 msg_seq = 10; */
        if (message.msgSeq !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.msgSeq);
        /* repeated com.midnights.game.GCGMessage msg_list = 13; */
        for (let i = 0; i < message.msgList.length; i++)
            GCGMessage.internalBinaryWrite(message.msgList[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGMessagePack
 */
export const GCGMessagePack = new GCGMessagePack$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGOperationRedraw$Type extends MessageType<GCGOperationRedraw> {
    constructor() {
        super("com.midnights.game.GCGOperationRedraw", [
            { no: 2, name: "card_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGOperationRedraw>): GCGOperationRedraw {
        const message = { cardList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGOperationRedraw>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGOperationRedraw): GCGOperationRedraw {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 card_list */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.cardList.push(reader.uint32());
                    else
                        message.cardList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGOperationRedraw, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 card_list = 2; */
        if (message.cardList.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.cardList.length; i++)
                writer.uint32(message.cardList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGOperationRedraw
 */
export const GCGOperationRedraw = new GCGOperationRedraw$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGOperationOnStageSelect$Type extends MessageType<GCGOperationOnStageSelect> {
    constructor() {
        super("com.midnights.game.GCGOperationOnStageSelect", [
            { no: 5, name: "card_guid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "cost_dice_index_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGOperationOnStageSelect>): GCGOperationOnStageSelect {
        const message = { costDiceIndexList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGOperationOnStageSelect>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGOperationOnStageSelect): GCGOperationOnStageSelect {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 card_guid */ 5:
                    message.cardGuid = reader.uint32();
                    break;
                case /* repeated uint32 cost_dice_index_list */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.costDiceIndexList.push(reader.uint32());
                    else
                        message.costDiceIndexList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGOperationOnStageSelect, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 card_guid = 5; */
        if (message.cardGuid !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.cardGuid);
        /* repeated uint32 cost_dice_index_list = 4; */
        if (message.costDiceIndexList.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.costDiceIndexList.length; i++)
                writer.uint32(message.costDiceIndexList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGOperationOnStageSelect
 */
export const GCGOperationOnStageSelect = new GCGOperationOnStageSelect$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGOperationReroll$Type extends MessageType<GCGOperationReroll> {
    constructor() {
        super("com.midnights.game.GCGOperationReroll", [
            { no: 12, name: "dice_index_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGOperationReroll>): GCGOperationReroll {
        const message = { diceIndexList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGOperationReroll>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGOperationReroll): GCGOperationReroll {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 dice_index_list */ 12:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.diceIndexList.push(reader.uint32());
                    else
                        message.diceIndexList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGOperationReroll, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 dice_index_list = 12; */
        if (message.diceIndexList.length) {
            writer.tag(12, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.diceIndexList.length; i++)
                writer.uint32(message.diceIndexList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGOperationReroll
 */
export const GCGOperationReroll = new GCGOperationReroll$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGOperationAttack$Type extends MessageType<GCGOperationAttack> {
    constructor() {
        super("com.midnights.game.GCGOperationAttack", [
            { no: 8, name: "cost_dice_index_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "skill_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGOperationAttack>): GCGOperationAttack {
        const message = { costDiceIndexList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGOperationAttack>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGOperationAttack): GCGOperationAttack {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 cost_dice_index_list */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.costDiceIndexList.push(reader.uint32());
                    else
                        message.costDiceIndexList.push(reader.uint32());
                    break;
                case /* optional uint32 skill_id */ 2:
                    message.skillId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGOperationAttack, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 cost_dice_index_list = 8; */
        if (message.costDiceIndexList.length) {
            writer.tag(8, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.costDiceIndexList.length; i++)
                writer.uint32(message.costDiceIndexList[i]);
            writer.join();
        }
        /* optional uint32 skill_id = 2; */
        if (message.skillId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.skillId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGOperationAttack
 */
export const GCGOperationAttack = new GCGOperationAttack$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGOperationPass$Type extends MessageType<GCGOperationPass> {
    constructor() {
        super("com.midnights.game.GCGOperationPass", []);
    }
    create(value?: PartialMessage<GCGOperationPass>): GCGOperationPass {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGOperationPass>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGOperationPass): GCGOperationPass {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GCGOperationPass, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGOperationPass
 */
export const GCGOperationPass = new GCGOperationPass$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGOperationPlayCard$Type extends MessageType<GCGOperationPlayCard> {
    constructor() {
        super("com.midnights.game.GCGOperationPlayCard", [
            { no: 12, name: "card_guid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "cost_dice_index_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "target_card_guid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGOperationPlayCard>): GCGOperationPlayCard {
        const message = { costDiceIndexList: [], targetCardGuidList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGOperationPlayCard>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGOperationPlayCard): GCGOperationPlayCard {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 card_guid */ 12:
                    message.cardGuid = reader.uint32();
                    break;
                case /* repeated uint32 cost_dice_index_list */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.costDiceIndexList.push(reader.uint32());
                    else
                        message.costDiceIndexList.push(reader.uint32());
                    break;
                case /* repeated uint32 target_card_guid_list */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.targetCardGuidList.push(reader.uint32());
                    else
                        message.targetCardGuidList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGOperationPlayCard, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 card_guid = 12; */
        if (message.cardGuid !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.cardGuid);
        /* repeated uint32 cost_dice_index_list = 4; */
        if (message.costDiceIndexList.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.costDiceIndexList.length; i++)
                writer.uint32(message.costDiceIndexList[i]);
            writer.join();
        }
        /* repeated uint32 target_card_guid_list = 10; */
        if (message.targetCardGuidList.length) {
            writer.tag(10, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.targetCardGuidList.length; i++)
                writer.uint32(message.targetCardGuidList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGOperationPlayCard
 */
export const GCGOperationPlayCard = new GCGOperationPlayCard$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGOperationReboot$Type extends MessageType<GCGOperationReboot> {
    constructor() {
        super("com.midnights.game.GCGOperationReboot", [
            { no: 7, name: "cost_card_guid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "dice_index_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGOperationReboot>): GCGOperationReboot {
        const message = { costCardGuidList: [], diceIndexList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGOperationReboot>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGOperationReboot): GCGOperationReboot {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 cost_card_guid_list */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.costCardGuidList.push(reader.uint32());
                    else
                        message.costCardGuidList.push(reader.uint32());
                    break;
                case /* repeated uint32 dice_index_list */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.diceIndexList.push(reader.uint32());
                    else
                        message.diceIndexList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGOperationReboot, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 cost_card_guid_list = 7; */
        if (message.costCardGuidList.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.costCardGuidList.length; i++)
                writer.uint32(message.costCardGuidList[i]);
            writer.join();
        }
        /* repeated uint32 dice_index_list = 6; */
        if (message.diceIndexList.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.diceIndexList.length; i++)
                writer.uint32(message.diceIndexList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGOperationReboot
 */
export const GCGOperationReboot = new GCGOperationReboot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGOperationSurrender$Type extends MessageType<GCGOperationSurrender> {
    constructor() {
        super("com.midnights.game.GCGOperationSurrender", []);
    }
    create(value?: PartialMessage<GCGOperationSurrender>): GCGOperationSurrender {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGOperationSurrender>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGOperationSurrender): GCGOperationSurrender {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GCGOperationSurrender, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGOperationSurrender
 */
export const GCGOperationSurrender = new GCGOperationSurrender$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGOperation$Type extends MessageType<GCGOperation> {
    constructor() {
        super("com.midnights.game.GCGOperation", [
            { no: 10, name: "op_redraw", kind: "message", oneof: "op", T: () => GCGOperationRedraw },
            { no: 4, name: "op_select_on_stage", kind: "message", oneof: "op", T: () => GCGOperationOnStageSelect },
            { no: 9, name: "op_reroll", kind: "message", oneof: "op", T: () => GCGOperationReroll },
            { no: 11, name: "op_attack", kind: "message", oneof: "op", T: () => GCGOperationAttack },
            { no: 15, name: "op_pass", kind: "message", oneof: "op", T: () => GCGOperationPass },
            { no: 2, name: "op_play_card", kind: "message", oneof: "op", T: () => GCGOperationPlayCard },
            { no: 5, name: "op_reboot", kind: "message", oneof: "op", T: () => GCGOperationReboot },
            { no: 1, name: "op_surrender", kind: "message", oneof: "op", T: () => GCGOperationSurrender }
        ]);
    }
    create(value?: PartialMessage<GCGOperation>): GCGOperation {
        const message = { op: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGOperation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGOperation): GCGOperation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* com.midnights.game.GCGOperationRedraw op_redraw */ 10:
                    message.op = {
                        oneofKind: "opRedraw",
                        opRedraw: GCGOperationRedraw.internalBinaryRead(reader, reader.uint32(), options, (message.op as any).opRedraw)
                    };
                    break;
                case /* com.midnights.game.GCGOperationOnStageSelect op_select_on_stage */ 4:
                    message.op = {
                        oneofKind: "opSelectOnStage",
                        opSelectOnStage: GCGOperationOnStageSelect.internalBinaryRead(reader, reader.uint32(), options, (message.op as any).opSelectOnStage)
                    };
                    break;
                case /* com.midnights.game.GCGOperationReroll op_reroll */ 9:
                    message.op = {
                        oneofKind: "opReroll",
                        opReroll: GCGOperationReroll.internalBinaryRead(reader, reader.uint32(), options, (message.op as any).opReroll)
                    };
                    break;
                case /* com.midnights.game.GCGOperationAttack op_attack */ 11:
                    message.op = {
                        oneofKind: "opAttack",
                        opAttack: GCGOperationAttack.internalBinaryRead(reader, reader.uint32(), options, (message.op as any).opAttack)
                    };
                    break;
                case /* com.midnights.game.GCGOperationPass op_pass */ 15:
                    message.op = {
                        oneofKind: "opPass",
                        opPass: GCGOperationPass.internalBinaryRead(reader, reader.uint32(), options, (message.op as any).opPass)
                    };
                    break;
                case /* com.midnights.game.GCGOperationPlayCard op_play_card */ 2:
                    message.op = {
                        oneofKind: "opPlayCard",
                        opPlayCard: GCGOperationPlayCard.internalBinaryRead(reader, reader.uint32(), options, (message.op as any).opPlayCard)
                    };
                    break;
                case /* com.midnights.game.GCGOperationReboot op_reboot */ 5:
                    message.op = {
                        oneofKind: "opReboot",
                        opReboot: GCGOperationReboot.internalBinaryRead(reader, reader.uint32(), options, (message.op as any).opReboot)
                    };
                    break;
                case /* com.midnights.game.GCGOperationSurrender op_surrender */ 1:
                    message.op = {
                        oneofKind: "opSurrender",
                        opSurrender: GCGOperationSurrender.internalBinaryRead(reader, reader.uint32(), options, (message.op as any).opSurrender)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGOperation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* com.midnights.game.GCGOperationRedraw op_redraw = 10; */
        if (message.op.oneofKind === "opRedraw")
            GCGOperationRedraw.internalBinaryWrite(message.op.opRedraw, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGOperationOnStageSelect op_select_on_stage = 4; */
        if (message.op.oneofKind === "opSelectOnStage")
            GCGOperationOnStageSelect.internalBinaryWrite(message.op.opSelectOnStage, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGOperationReroll op_reroll = 9; */
        if (message.op.oneofKind === "opReroll")
            GCGOperationReroll.internalBinaryWrite(message.op.opReroll, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGOperationAttack op_attack = 11; */
        if (message.op.oneofKind === "opAttack")
            GCGOperationAttack.internalBinaryWrite(message.op.opAttack, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGOperationPass op_pass = 15; */
        if (message.op.oneofKind === "opPass")
            GCGOperationPass.internalBinaryWrite(message.op.opPass, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGOperationPlayCard op_play_card = 2; */
        if (message.op.oneofKind === "opPlayCard")
            GCGOperationPlayCard.internalBinaryWrite(message.op.opPlayCard, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGOperationReboot op_reboot = 5; */
        if (message.op.oneofKind === "opReboot")
            GCGOperationReboot.internalBinaryWrite(message.op.opReboot, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.GCGOperationSurrender op_surrender = 1; */
        if (message.op.oneofKind === "opSurrender")
            GCGOperationSurrender.internalBinaryWrite(message.op.opSurrender, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGOperation
 */
export const GCGOperation = new GCGOperation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGOperationData$Type extends MessageType<GCGOperationData> {
    constructor() {
        super("com.midnights.game.GCGOperationData", [
            { no: 2, name: "controller_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "op", kind: "message", T: () => GCGOperation }
        ]);
    }
    create(value?: PartialMessage<GCGOperationData>): GCGOperationData {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGOperationData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGOperationData): GCGOperationData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 controller_id */ 2:
                    message.controllerId = reader.uint32();
                    break;
                case /* optional com.midnights.game.GCGOperation op */ 12:
                    message.op = GCGOperation.internalBinaryRead(reader, reader.uint32(), options, message.op);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGOperationData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 controller_id = 2; */
        if (message.controllerId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.controllerId);
        /* optional com.midnights.game.GCGOperation op = 12; */
        if (message.op)
            GCGOperation.internalBinaryWrite(message.op, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGOperationData
 */
export const GCGOperationData = new GCGOperationData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGOperationReplay$Type extends MessageType<GCGOperationReplay> {
    constructor() {
        super("com.midnights.game.GCGOperationReplay", [
            { no: 1, name: "game_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "seed", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "operation_data_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GCGOperationData }
        ]);
    }
    create(value?: PartialMessage<GCGOperationReplay>): GCGOperationReplay {
        const message = { operationDataList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGOperationReplay>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGOperationReplay): GCGOperationReplay {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 game_id */ 1:
                    message.gameId = reader.uint32();
                    break;
                case /* optional uint32 seed */ 11:
                    message.seed = reader.uint32();
                    break;
                case /* repeated com.midnights.game.GCGOperationData operation_data_list */ 9:
                    message.operationDataList.push(GCGOperationData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGOperationReplay, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 game_id = 1; */
        if (message.gameId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.gameId);
        /* optional uint32 seed = 11; */
        if (message.seed !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.seed);
        /* repeated com.midnights.game.GCGOperationData operation_data_list = 9; */
        for (let i = 0; i < message.operationDataList.length; i++)
            GCGOperationData.internalBinaryWrite(message.operationDataList[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGOperationReplay
 */
export const GCGOperationReplay = new GCGOperationReplay$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGToken$Type extends MessageType<GCGToken> {
    constructor() {
        super("com.midnights.game.GCGToken", [
            { no: 11, name: "value", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "key", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGToken>): GCGToken {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGToken>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGToken): GCGToken {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 value */ 11:
                    message.value = reader.uint32();
                    break;
                case /* optional uint32 key */ 4:
                    message.key = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGToken, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 value = 11; */
        if (message.value !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.value);
        /* optional uint32 key = 4; */
        if (message.key !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.key);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGToken
 */
export const GCGToken = new GCGToken$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGCard$Type extends MessageType<GCGCard> {
    constructor() {
        super("com.midnights.game.GCGCard", [
            { no: 15, name: "guid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "token_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GCGToken },
            { no: 14, name: "is_show", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "controller_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "tag_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "face_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGCard>): GCGCard {
        const message = { tokenList: [], tagList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGCard>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGCard): GCGCard {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 guid */ 15:
                    message.guid = reader.uint32();
                    break;
                case /* repeated com.midnights.game.GCGToken token_list */ 2:
                    message.tokenList.push(GCGToken.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool is_show */ 14:
                    message.isShow = reader.bool();
                    break;
                case /* optional uint32 controller_id */ 7:
                    message.controllerId = reader.uint32();
                    break;
                case /* optional uint32 id */ 6:
                    message.id = reader.uint32();
                    break;
                case /* repeated uint32 tag_list */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.tagList.push(reader.uint32());
                    else
                        message.tagList.push(reader.uint32());
                    break;
                case /* optional uint32 face_type */ 5:
                    message.faceType = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGCard, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 guid = 15; */
        if (message.guid !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.guid);
        /* repeated com.midnights.game.GCGToken token_list = 2; */
        for (let i = 0; i < message.tokenList.length; i++)
            GCGToken.internalBinaryWrite(message.tokenList[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional bool is_show = 14; */
        if (message.isShow !== undefined)
            writer.tag(14, WireType.Varint).bool(message.isShow);
        /* optional uint32 controller_id = 7; */
        if (message.controllerId !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.controllerId);
        /* optional uint32 id = 6; */
        if (message.id !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.id);
        /* repeated uint32 tag_list = 3; */
        if (message.tagList.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.tagList.length; i++)
                writer.uint32(message.tagList[i]);
            writer.join();
        }
        /* optional uint32 face_type = 5; */
        if (message.faceType !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.faceType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGCard
 */
export const GCGCard = new GCGCard$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGZone$Type extends MessageType<GCGZone> {
    constructor() {
        super("com.midnights.game.GCGZone", [
            { no: 4, name: "card_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGZone>): GCGZone {
        const message = { cardList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGZone>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGZone): GCGZone {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 card_list */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.cardList.push(reader.uint32());
                    else
                        message.cardList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGZone, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 card_list = 4; */
        if (message.cardList.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.cardList.length; i++)
                writer.uint32(message.cardList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGZone
 */
export const GCGZone = new GCGZone$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGWaitingCharacter$Type extends MessageType<GCGWaitingCharacter> {
    constructor() {
        super("com.midnights.game.GCGWaitingCharacter", [
            { no: 2, name: "card_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "cond_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGWaitingCharacter>): GCGWaitingCharacter {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGWaitingCharacter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGWaitingCharacter): GCGWaitingCharacter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 card_id */ 2:
                    message.cardId = reader.uint32();
                    break;
                case /* optional uint32 cond_count */ 14:
                    message.condCount = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGWaitingCharacter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 card_id = 2; */
        if (message.cardId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.cardId);
        /* optional uint32 cond_count = 14; */
        if (message.condCount !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.condCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGWaitingCharacter
 */
export const GCGWaitingCharacter = new GCGWaitingCharacter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGPlayerField$Type extends MessageType<GCGPlayerField> {
    constructor() {
        super("com.midnights.game.GCGPlayerField", [
            { no: 2, name: "modify_zone_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => GCGZone } },
            { no: 383, name: "cur_waiting_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "summon_zone", kind: "message", T: () => GCGZone },
            { no: 8, name: "field_show_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "card_back_show_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "dice_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "controller_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "on_stage_zone", kind: "message", T: () => GCGZone },
            { no: 7, name: "is_passed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "character_zone", kind: "message", T: () => GCGZone },
            { no: 6, name: "on_stage_character_guid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "assist_zone", kind: "message", T: () => GCGZone },
            { no: 13, name: "deck_card_num", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "dice_side_list", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["com.midnights.game.GCGDiceSideType", GCGDiceSideType] },
            { no: 9, name: "hand_zone", kind: "message", T: () => GCGZone },
            { no: 1192, name: "intention_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GCGPVEIntention },
            { no: 4, name: "waiting_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GCGWaitingCharacter }
        ]);
    }
    create(value?: PartialMessage<GCGPlayerField>): GCGPlayerField {
        const message = { modifyZoneMap: {}, diceSideList: [], intentionList: [], waitingList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGPlayerField>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGPlayerField): GCGPlayerField {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, com.midnights.game.GCGZone> modify_zone_map */ 2:
                    this.binaryReadMap2(message.modifyZoneMap, reader, options);
                    break;
                case /* optional uint32 cur_waiting_index */ 383:
                    message.curWaitingIndex = reader.uint32();
                    break;
                case /* optional com.midnights.game.GCGZone summon_zone */ 1:
                    message.summonZone = GCGZone.internalBinaryRead(reader, reader.uint32(), options, message.summonZone);
                    break;
                case /* optional uint32 field_show_id */ 8:
                    message.fieldShowId = reader.uint32();
                    break;
                case /* optional uint32 card_back_show_id */ 12:
                    message.cardBackShowId = reader.uint32();
                    break;
                case /* optional uint32 dice_count */ 3:
                    message.diceCount = reader.uint32();
                    break;
                case /* optional uint32 controller_id */ 10:
                    message.controllerId = reader.uint32();
                    break;
                case /* optional com.midnights.game.GCGZone on_stage_zone */ 14:
                    message.onStageZone = GCGZone.internalBinaryRead(reader, reader.uint32(), options, message.onStageZone);
                    break;
                case /* optional bool is_passed */ 7:
                    message.isPassed = reader.bool();
                    break;
                case /* optional com.midnights.game.GCGZone character_zone */ 5:
                    message.characterZone = GCGZone.internalBinaryRead(reader, reader.uint32(), options, message.characterZone);
                    break;
                case /* optional uint32 on_stage_character_guid */ 6:
                    message.onStageCharacterGuid = reader.uint32();
                    break;
                case /* optional com.midnights.game.GCGZone assist_zone */ 15:
                    message.assistZone = GCGZone.internalBinaryRead(reader, reader.uint32(), options, message.assistZone);
                    break;
                case /* optional uint32 deck_card_num */ 13:
                    message.deckCardNum = reader.uint32();
                    break;
                case /* repeated com.midnights.game.GCGDiceSideType dice_side_list */ 11:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.diceSideList.push(reader.int32());
                    else
                        message.diceSideList.push(reader.int32());
                    break;
                case /* optional com.midnights.game.GCGZone hand_zone */ 9:
                    message.handZone = GCGZone.internalBinaryRead(reader, reader.uint32(), options, message.handZone);
                    break;
                case /* repeated com.midnights.game.GCGPVEIntention intention_list */ 1192:
                    message.intentionList.push(GCGPVEIntention.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated com.midnights.game.GCGWaitingCharacter waiting_list */ 4:
                    message.waitingList.push(GCGWaitingCharacter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: GCGPlayerField["modifyZoneMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GCGPlayerField["modifyZoneMap"] | undefined, val: GCGPlayerField["modifyZoneMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = GCGZone.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field com.midnights.game.GCGPlayerField.modify_zone_map");
            }
        }
        map[key ?? 0] = val ?? GCGZone.create();
    }
    internalBinaryWrite(message: GCGPlayerField, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, com.midnights.game.GCGZone> modify_zone_map = 2; */
        for (let k of Object.keys(message.modifyZoneMap)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            GCGZone.internalBinaryWrite(message.modifyZoneMap[k as any], writer, options);
            writer.join().join();
        }
        /* optional uint32 cur_waiting_index = 383; */
        if (message.curWaitingIndex !== undefined)
            writer.tag(383, WireType.Varint).uint32(message.curWaitingIndex);
        /* optional com.midnights.game.GCGZone summon_zone = 1; */
        if (message.summonZone)
            GCGZone.internalBinaryWrite(message.summonZone, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 field_show_id = 8; */
        if (message.fieldShowId !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.fieldShowId);
        /* optional uint32 card_back_show_id = 12; */
        if (message.cardBackShowId !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.cardBackShowId);
        /* optional uint32 dice_count = 3; */
        if (message.diceCount !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.diceCount);
        /* optional uint32 controller_id = 10; */
        if (message.controllerId !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.controllerId);
        /* optional com.midnights.game.GCGZone on_stage_zone = 14; */
        if (message.onStageZone)
            GCGZone.internalBinaryWrite(message.onStageZone, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* optional bool is_passed = 7; */
        if (message.isPassed !== undefined)
            writer.tag(7, WireType.Varint).bool(message.isPassed);
        /* optional com.midnights.game.GCGZone character_zone = 5; */
        if (message.characterZone)
            GCGZone.internalBinaryWrite(message.characterZone, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 on_stage_character_guid = 6; */
        if (message.onStageCharacterGuid !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.onStageCharacterGuid);
        /* optional com.midnights.game.GCGZone assist_zone = 15; */
        if (message.assistZone)
            GCGZone.internalBinaryWrite(message.assistZone, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 deck_card_num = 13; */
        if (message.deckCardNum !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.deckCardNum);
        /* repeated com.midnights.game.GCGDiceSideType dice_side_list = 11; */
        if (message.diceSideList.length) {
            writer.tag(11, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.diceSideList.length; i++)
                writer.int32(message.diceSideList[i]);
            writer.join();
        }
        /* optional com.midnights.game.GCGZone hand_zone = 9; */
        if (message.handZone)
            GCGZone.internalBinaryWrite(message.handZone, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated com.midnights.game.GCGPVEIntention intention_list = 1192; */
        for (let i = 0; i < message.intentionList.length; i++)
            GCGPVEIntention.internalBinaryWrite(message.intentionList[i], writer.tag(1192, WireType.LengthDelimited).fork(), options).join();
        /* repeated com.midnights.game.GCGWaitingCharacter waiting_list = 4; */
        for (let i = 0; i < message.waitingList.length; i++)
            GCGWaitingCharacter.internalBinaryWrite(message.waitingList[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGPlayerField
 */
export const GCGPlayerField = new GCGPlayerField$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGPhase$Type extends MessageType<GCGPhase> {
    constructor() {
        super("com.midnights.game.GCGPhase", [
            { no: 5, name: "phase_type", kind: "enum", opt: true, T: () => ["com.midnights.game.GCGPhaseType", GCGPhaseType] },
            { no: 6, name: "allow_controller_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } }
        ]);
    }
    create(value?: PartialMessage<GCGPhase>): GCGPhase {
        const message = { allowControllerMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGPhase>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGPhase): GCGPhase {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.GCGPhaseType phase_type */ 5:
                    message.phaseType = reader.int32();
                    break;
                case /* map<uint32, uint32> allow_controller_map */ 6:
                    this.binaryReadMap6(message.allowControllerMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap6(map: GCGPhase["allowControllerMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GCGPhase["allowControllerMap"] | undefined, val: GCGPhase["allowControllerMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field com.midnights.game.GCGPhase.allow_controller_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: GCGPhase, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.GCGPhaseType phase_type = 5; */
        if (message.phaseType !== undefined)
            writer.tag(5, WireType.Varint).int32(message.phaseType);
        /* map<uint32, uint32> allow_controller_map = 6; */
        for (let k of Object.keys(message.allowControllerMap))
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.allowControllerMap[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGPhase
 */
export const GCGPhase = new GCGPhase$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGControllerShowInfo$Type extends MessageType<GCGControllerShowInfo> {
    constructor() {
        super("com.midnights.game.GCGControllerShowInfo", [
            { no: 11, name: "profile_picture", kind: "message", T: () => ProfilePicture },
            { no: 14, name: "nick_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "controller_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGControllerShowInfo>): GCGControllerShowInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGControllerShowInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGControllerShowInfo): GCGControllerShowInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.ProfilePicture profile_picture */ 11:
                    message.profilePicture = ProfilePicture.internalBinaryRead(reader, reader.uint32(), options, message.profilePicture);
                    break;
                case /* optional string nick_name */ 14:
                    message.nickName = reader.string();
                    break;
                case /* optional uint32 controller_id */ 9:
                    message.controllerId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGControllerShowInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.ProfilePicture profile_picture = 11; */
        if (message.profilePicture)
            ProfilePicture.internalBinaryWrite(message.profilePicture, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* optional string nick_name = 14; */
        if (message.nickName !== undefined)
            writer.tag(14, WireType.LengthDelimited).string(message.nickName);
        /* optional uint32 controller_id = 9; */
        if (message.controllerId !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.controllerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGControllerShowInfo
 */
export const GCGControllerShowInfo = new GCGControllerShowInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGPVEIntention$Type extends MessageType<GCGPVEIntention> {
    constructor() {
        super("com.midnights.game.GCGPVEIntention", [
            { no: 9, name: "card_guid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "skill_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGPVEIntention>): GCGPVEIntention {
        const message = { skillIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGPVEIntention>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGPVEIntention): GCGPVEIntention {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 card_guid */ 9:
                    message.cardGuid = reader.uint32();
                    break;
                case /* repeated uint32 skill_id_list */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.skillIdList.push(reader.uint32());
                    else
                        message.skillIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGPVEIntention, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 card_guid = 9; */
        if (message.cardGuid !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.cardGuid);
        /* repeated uint32 skill_id_list = 7; */
        if (message.skillIdList.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.skillIdList.length; i++)
                writer.uint32(message.skillIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGPVEIntention
 */
export const GCGPVEIntention = new GCGPVEIntention$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGDuelChallenge$Type extends MessageType<GCGDuelChallenge> {
    constructor() {
        super("com.midnights.game.GCGDuelChallenge", [
            { no: 7, name: "total_progress", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "challenge_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "cur_progress", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGDuelChallenge>): GCGDuelChallenge {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGDuelChallenge>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGDuelChallenge): GCGDuelChallenge {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 total_progress */ 7:
                    message.totalProgress = reader.uint32();
                    break;
                case /* optional uint32 challenge_id */ 10:
                    message.challengeId = reader.uint32();
                    break;
                case /* optional uint32 cur_progress */ 12:
                    message.curProgress = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGDuelChallenge, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 total_progress = 7; */
        if (message.totalProgress !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.totalProgress);
        /* optional uint32 challenge_id = 10; */
        if (message.challengeId !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.challengeId);
        /* optional uint32 cur_progress = 12; */
        if (message.curProgress !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.curProgress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGDuelChallenge
 */
export const GCGDuelChallenge = new GCGDuelChallenge$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGDuel$Type extends MessageType<GCGDuel> {
    constructor() {
        super("com.midnights.game.GCGDuel", [
            { no: 3, name: "server_seq", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "field_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GCGPlayerField },
            { no: 14, name: "business_type", kind: "enum", opt: true, T: () => ["com.midnights.game.GCGGameBusinessType", GCGGameBusinessType] },
            { no: 5, name: "challenge_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GCGDuelChallenge },
            { no: 11, name: "game_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "controller_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "round", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "cur_controller_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "intetion_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GCGPVEIntention },
            { no: 10, name: "cost_revise", kind: "message", T: () => GCGCostReviseInfo },
            { no: 4, name: "card_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "card_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GCGCard },
            { no: 6, name: "show_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GCGControllerShowInfo },
            { no: 2, name: "game_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "phase", kind: "message", T: () => GCGPhase }
        ]);
    }
    create(value?: PartialMessage<GCGDuel>): GCGDuel {
        const message = { fieldList: [], challengeList: [], intetionList: [], cardIdList: [], cardList: [], showInfoList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGDuel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGDuel): GCGDuel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 server_seq */ 3:
                    message.serverSeq = reader.uint32();
                    break;
                case /* repeated com.midnights.game.GCGPlayerField field_list */ 7:
                    message.fieldList.push(GCGPlayerField.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional com.midnights.game.GCGGameBusinessType business_type */ 14:
                    message.businessType = reader.int32();
                    break;
                case /* repeated com.midnights.game.GCGDuelChallenge challenge_list */ 5:
                    message.challengeList.push(GCGDuelChallenge.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 game_id */ 11:
                    message.gameId = reader.uint32();
                    break;
                case /* optional uint32 controller_id */ 13:
                    message.controllerId = reader.uint32();
                    break;
                case /* optional uint32 round */ 15:
                    message.round = reader.uint32();
                    break;
                case /* optional uint32 cur_controller_id */ 12:
                    message.curControllerId = reader.uint32();
                    break;
                case /* repeated com.midnights.game.GCGPVEIntention intetion_list */ 1:
                    message.intetionList.push(GCGPVEIntention.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional com.midnights.game.GCGCostReviseInfo cost_revise */ 10:
                    message.costRevise = GCGCostReviseInfo.internalBinaryRead(reader, reader.uint32(), options, message.costRevise);
                    break;
                case /* repeated uint32 card_id_list */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.cardIdList.push(reader.uint32());
                    else
                        message.cardIdList.push(reader.uint32());
                    break;
                case /* repeated com.midnights.game.GCGCard card_list */ 9:
                    message.cardList.push(GCGCard.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated com.midnights.game.GCGControllerShowInfo show_info_list */ 6:
                    message.showInfoList.push(GCGControllerShowInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 game_type */ 2:
                    message.gameType = reader.uint32();
                    break;
                case /* optional com.midnights.game.GCGPhase phase */ 8:
                    message.phase = GCGPhase.internalBinaryRead(reader, reader.uint32(), options, message.phase);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGDuel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 server_seq = 3; */
        if (message.serverSeq !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.serverSeq);
        /* repeated com.midnights.game.GCGPlayerField field_list = 7; */
        for (let i = 0; i < message.fieldList.length; i++)
            GCGPlayerField.internalBinaryWrite(message.fieldList[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* optional com.midnights.game.GCGGameBusinessType business_type = 14; */
        if (message.businessType !== undefined)
            writer.tag(14, WireType.Varint).int32(message.businessType);
        /* repeated com.midnights.game.GCGDuelChallenge challenge_list = 5; */
        for (let i = 0; i < message.challengeList.length; i++)
            GCGDuelChallenge.internalBinaryWrite(message.challengeList[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 game_id = 11; */
        if (message.gameId !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.gameId);
        /* optional uint32 controller_id = 13; */
        if (message.controllerId !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.controllerId);
        /* optional uint32 round = 15; */
        if (message.round !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.round);
        /* optional uint32 cur_controller_id = 12; */
        if (message.curControllerId !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.curControllerId);
        /* repeated com.midnights.game.GCGPVEIntention intetion_list = 1; */
        for (let i = 0; i < message.intetionList.length; i++)
            GCGPVEIntention.internalBinaryWrite(message.intetionList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional com.midnights.game.GCGCostReviseInfo cost_revise = 10; */
        if (message.costRevise)
            GCGCostReviseInfo.internalBinaryWrite(message.costRevise, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 card_id_list = 4; */
        if (message.cardIdList.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.cardIdList.length; i++)
                writer.uint32(message.cardIdList[i]);
            writer.join();
        }
        /* repeated com.midnights.game.GCGCard card_list = 9; */
        for (let i = 0; i < message.cardList.length; i++)
            GCGCard.internalBinaryWrite(message.cardList[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated com.midnights.game.GCGControllerShowInfo show_info_list = 6; */
        for (let i = 0; i < message.showInfoList.length; i++)
            GCGControllerShowInfo.internalBinaryWrite(message.showInfoList[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 game_type = 2; */
        if (message.gameType !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.gameType);
        /* optional com.midnights.game.GCGPhase phase = 8; */
        if (message.phase)
            GCGPhase.internalBinaryWrite(message.phase, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGDuel
 */
export const GCGDuel = new GCGDuel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGNewCardInfoNotify$Type extends MessageType<GCGNewCardInfoNotify> {
    constructor() {
        super("com.midnights.game.GCGNewCardInfoNotify", [
            { no: 1, name: "card", kind: "message", T: () => GCGCard }
        ]);
    }
    create(value?: PartialMessage<GCGNewCardInfoNotify>): GCGNewCardInfoNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGNewCardInfoNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGNewCardInfoNotify): GCGNewCardInfoNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.GCGCard card */ 1:
                    message.card = GCGCard.internalBinaryRead(reader, reader.uint32(), options, message.card);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGNewCardInfoNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.GCGCard card = 1; */
        if (message.card)
            GCGCard.internalBinaryWrite(message.card, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGNewCardInfoNotify
 */
export const GCGNewCardInfoNotify = new GCGNewCardInfoNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGOperationReq$Type extends MessageType<GCGOperationReq> {
    constructor() {
        super("com.midnights.game.GCGOperationReq", [
            { no: 2, name: "op_seq", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "redirect_uid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "op", kind: "message", T: () => GCGOperation }
        ]);
    }
    create(value?: PartialMessage<GCGOperationReq>): GCGOperationReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGOperationReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGOperationReq): GCGOperationReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 op_seq */ 2:
                    message.opSeq = reader.uint32();
                    break;
                case /* optional uint32 redirect_uid */ 7:
                    message.redirectUid = reader.uint32();
                    break;
                case /* optional com.midnights.game.GCGOperation op */ 15:
                    message.op = GCGOperation.internalBinaryRead(reader, reader.uint32(), options, message.op);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGOperationReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 op_seq = 2; */
        if (message.opSeq !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.opSeq);
        /* optional uint32 redirect_uid = 7; */
        if (message.redirectUid !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.redirectUid);
        /* optional com.midnights.game.GCGOperation op = 15; */
        if (message.op)
            GCGOperation.internalBinaryWrite(message.op, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGOperationReq
 */
export const GCGOperationReq = new GCGOperationReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGOperationRsp$Type extends MessageType<GCGOperationRsp> {
    constructor() {
        super("com.midnights.game.GCGOperationRsp", [
            { no: 8, name: "retcode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "op_seq", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGOperationRsp>): GCGOperationRsp {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGOperationRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGOperationRsp): GCGOperationRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 retcode */ 8:
                    message.retcode = reader.int32();
                    break;
                case /* optional uint32 op_seq */ 4:
                    message.opSeq = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGOperationRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 retcode = 8; */
        if (message.retcode !== undefined)
            writer.tag(8, WireType.Varint).int32(message.retcode);
        /* optional uint32 op_seq = 4; */
        if (message.opSeq !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.opSeq);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGOperationRsp
 */
export const GCGOperationRsp = new GCGOperationRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGMessagePackNotify$Type extends MessageType<GCGMessagePackNotify> {
    constructor() {
        super("com.midnights.game.GCGMessagePackNotify", [
            { no: 5, name: "server_seq", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "message_pack", kind: "message", T: () => GCGMessagePack }
        ]);
    }
    create(value?: PartialMessage<GCGMessagePackNotify>): GCGMessagePackNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGMessagePackNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGMessagePackNotify): GCGMessagePackNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 server_seq */ 5:
                    message.serverSeq = reader.uint32();
                    break;
                case /* optional com.midnights.game.GCGMessagePack message_pack */ 8:
                    message.messagePack = GCGMessagePack.internalBinaryRead(reader, reader.uint32(), options, message.messagePack);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGMessagePackNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 server_seq = 5; */
        if (message.serverSeq !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.serverSeq);
        /* optional com.midnights.game.GCGMessagePack message_pack = 8; */
        if (message.messagePack)
            GCGMessagePack.internalBinaryWrite(message.messagePack, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGMessagePackNotify
 */
export const GCGMessagePackNotify = new GCGMessagePackNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGAskDuelReq$Type extends MessageType<GCGAskDuelReq> {
    constructor() {
        super("com.midnights.game.GCGAskDuelReq", []);
    }
    create(value?: PartialMessage<GCGAskDuelReq>): GCGAskDuelReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGAskDuelReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGAskDuelReq): GCGAskDuelReq {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GCGAskDuelReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGAskDuelReq
 */
export const GCGAskDuelReq = new GCGAskDuelReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGAskDuelRsp$Type extends MessageType<GCGAskDuelRsp> {
    constructor() {
        super("com.midnights.game.GCGAskDuelRsp", [
            { no: 3, name: "retcode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "duel", kind: "message", T: () => GCGDuel }
        ]);
    }
    create(value?: PartialMessage<GCGAskDuelRsp>): GCGAskDuelRsp {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGAskDuelRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGAskDuelRsp): GCGAskDuelRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 retcode */ 3:
                    message.retcode = reader.int32();
                    break;
                case /* optional com.midnights.game.GCGDuel duel */ 13:
                    message.duel = GCGDuel.internalBinaryRead(reader, reader.uint32(), options, message.duel);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGAskDuelRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 retcode = 3; */
        if (message.retcode !== undefined)
            writer.tag(3, WireType.Varint).int32(message.retcode);
        /* optional com.midnights.game.GCGDuel duel = 13; */
        if (message.duel)
            GCGDuel.internalBinaryWrite(message.duel, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGAskDuelRsp
 */
export const GCGAskDuelRsp = new GCGAskDuelRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGPlayerBriefData$Type extends MessageType<GCGPlayerBriefData> {
    constructor() {
        super("com.midnights.game.GCGPlayerBriefData", [
            { no: 8, name: "card_face_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 9, name: "nick_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "profile_picture", kind: "message", T: () => ProfilePicture },
            { no: 3, name: "card_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "controller_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "uid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGPlayerBriefData>): GCGPlayerBriefData {
        const message = { cardFaceMap: {}, cardIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGPlayerBriefData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGPlayerBriefData): GCGPlayerBriefData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, uint32> card_face_map */ 8:
                    this.binaryReadMap8(message.cardFaceMap, reader, options);
                    break;
                case /* optional string nick_name */ 9:
                    message.nickName = reader.string();
                    break;
                case /* optional com.midnights.game.ProfilePicture profile_picture */ 12:
                    message.profilePicture = ProfilePicture.internalBinaryRead(reader, reader.uint32(), options, message.profilePicture);
                    break;
                case /* repeated uint32 card_id_list */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.cardIdList.push(reader.uint32());
                    else
                        message.cardIdList.push(reader.uint32());
                    break;
                case /* optional uint32 controller_id */ 5:
                    message.controllerId = reader.uint32();
                    break;
                case /* optional uint32 uid */ 10:
                    message.uid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap8(map: GCGPlayerBriefData["cardFaceMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GCGPlayerBriefData["cardFaceMap"] | undefined, val: GCGPlayerBriefData["cardFaceMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field com.midnights.game.GCGPlayerBriefData.card_face_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: GCGPlayerBriefData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, uint32> card_face_map = 8; */
        for (let k of Object.keys(message.cardFaceMap))
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.cardFaceMap[k as any]).join();
        /* optional string nick_name = 9; */
        if (message.nickName !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.nickName);
        /* optional com.midnights.game.ProfilePicture profile_picture = 12; */
        if (message.profilePicture)
            ProfilePicture.internalBinaryWrite(message.profilePicture, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 card_id_list = 3; */
        if (message.cardIdList.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.cardIdList.length; i++)
                writer.uint32(message.cardIdList[i]);
            writer.join();
        }
        /* optional uint32 controller_id = 5; */
        if (message.controllerId !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.controllerId);
        /* optional uint32 uid = 10; */
        if (message.uid !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.uid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGPlayerBriefData
 */
export const GCGPlayerBriefData = new GCGPlayerBriefData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGGameBriefData$Type extends MessageType<GCGGameBriefData> {
    constructor() {
        super("com.midnights.game.GCGGameBriefData", [
            { no: 14, name: "game_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "game_uid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "business_type", kind: "enum", opt: true, T: () => ["com.midnights.game.GCGGameBusinessType", GCGGameBusinessType] },
            { no: 5, name: "verify_code", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "player_brief_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GCGPlayerBriefData }
        ]);
    }
    create(value?: PartialMessage<GCGGameBriefData>): GCGGameBriefData {
        const message = { playerBriefList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGGameBriefData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGGameBriefData): GCGGameBriefData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 game_id */ 14:
                    message.gameId = reader.uint32();
                    break;
                case /* optional uint32 game_uid */ 9:
                    message.gameUid = reader.uint32();
                    break;
                case /* optional com.midnights.game.GCGGameBusinessType business_type */ 13:
                    message.businessType = reader.int32();
                    break;
                case /* optional uint32 verify_code */ 5:
                    message.verifyCode = reader.uint32();
                    break;
                case /* repeated com.midnights.game.GCGPlayerBriefData player_brief_list */ 12:
                    message.playerBriefList.push(GCGPlayerBriefData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGGameBriefData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 game_id = 14; */
        if (message.gameId !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.gameId);
        /* optional uint32 game_uid = 9; */
        if (message.gameUid !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.gameUid);
        /* optional com.midnights.game.GCGGameBusinessType business_type = 13; */
        if (message.businessType !== undefined)
            writer.tag(13, WireType.Varint).int32(message.businessType);
        /* optional uint32 verify_code = 5; */
        if (message.verifyCode !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.verifyCode);
        /* repeated com.midnights.game.GCGPlayerBriefData player_brief_list = 12; */
        for (let i = 0; i < message.playerBriefList.length; i++)
            GCGPlayerBriefData.internalBinaryWrite(message.playerBriefList[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGGameBriefData
 */
export const GCGGameBriefData = new GCGGameBriefData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGGameBriefDataNotify$Type extends MessageType<GCGGameBriefDataNotify> {
    constructor() {
        super("com.midnights.game.GCGGameBriefDataNotify", [
            { no: 10, name: "gcg_brief_data", kind: "message", T: () => GCGGameBriefData }
        ]);
    }
    create(value?: PartialMessage<GCGGameBriefDataNotify>): GCGGameBriefDataNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGGameBriefDataNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGGameBriefDataNotify): GCGGameBriefDataNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.GCGGameBriefData gcg_brief_data */ 10:
                    message.gcgBriefData = GCGGameBriefData.internalBinaryRead(reader, reader.uint32(), options, message.gcgBriefData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGGameBriefDataNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.GCGGameBriefData gcg_brief_data = 10; */
        if (message.gcgBriefData)
            GCGGameBriefData.internalBinaryWrite(message.gcgBriefData, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGGameBriefDataNotify
 */
export const GCGGameBriefDataNotify = new GCGGameBriefDataNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGInitFinishReq$Type extends MessageType<GCGInitFinishReq> {
    constructor() {
        super("com.midnights.game.GCGInitFinishReq", []);
    }
    create(value?: PartialMessage<GCGInitFinishReq>): GCGInitFinishReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGInitFinishReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGInitFinishReq): GCGInitFinishReq {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GCGInitFinishReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGInitFinishReq
 */
export const GCGInitFinishReq = new GCGInitFinishReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGInitFinishRsp$Type extends MessageType<GCGInitFinishRsp> {
    constructor() {
        super("com.midnights.game.GCGInitFinishRsp", [
            { no: 2, name: "retcode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGInitFinishRsp>): GCGInitFinishRsp {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGInitFinishRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGInitFinishRsp): GCGInitFinishRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 retcode */ 2:
                    message.retcode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGInitFinishRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 retcode = 2; */
        if (message.retcode !== undefined)
            writer.tag(2, WireType.Varint).int32(message.retcode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGInitFinishRsp
 */
export const GCGInitFinishRsp = new GCGInitFinishRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGHeartBeatNotify$Type extends MessageType<GCGHeartBeatNotify> {
    constructor() {
        super("com.midnights.game.GCGHeartBeatNotify", [
            { no: 6, name: "server_seq", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGHeartBeatNotify>): GCGHeartBeatNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGHeartBeatNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGHeartBeatNotify): GCGHeartBeatNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 server_seq */ 6:
                    message.serverSeq = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGHeartBeatNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 server_seq = 6; */
        if (message.serverSeq !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.serverSeq);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGHeartBeatNotify
 */
export const GCGHeartBeatNotify = new GCGHeartBeatNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGSkillPreviewHpInfo$Type extends MessageType<GCGSkillPreviewHpInfo> {
    constructor() {
        super("com.midnights.game.GCGSkillPreviewHpInfo", [
            { no: 4, name: "change_type", kind: "enum", opt: true, T: () => ["com.midnights.game.GCGSkillHpChangeType", GCGSkillHpChangeType] },
            { no: 13, name: "hp_change_value", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGSkillPreviewHpInfo>): GCGSkillPreviewHpInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGSkillPreviewHpInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGSkillPreviewHpInfo): GCGSkillPreviewHpInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.GCGSkillHpChangeType change_type */ 4:
                    message.changeType = reader.int32();
                    break;
                case /* optional uint32 hp_change_value */ 13:
                    message.hpChangeValue = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGSkillPreviewHpInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.GCGSkillHpChangeType change_type = 4; */
        if (message.changeType !== undefined)
            writer.tag(4, WireType.Varint).int32(message.changeType);
        /* optional uint32 hp_change_value = 13; */
        if (message.hpChangeValue !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.hpChangeValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGSkillPreviewHpInfo
 */
export const GCGSkillPreviewHpInfo = new GCGSkillPreviewHpInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGSkillPreviewReactionInfo$Type extends MessageType<GCGSkillPreviewReactionInfo> {
    constructor() {
        super("com.midnights.game.GCGSkillPreviewReactionInfo", [
            { no: 13, name: "source_element", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "target_element", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGSkillPreviewReactionInfo>): GCGSkillPreviewReactionInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGSkillPreviewReactionInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGSkillPreviewReactionInfo): GCGSkillPreviewReactionInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 source_element */ 13:
                    message.sourceElement = reader.uint32();
                    break;
                case /* optional uint32 target_element */ 1:
                    message.targetElement = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGSkillPreviewReactionInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 source_element = 13; */
        if (message.sourceElement !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.sourceElement);
        /* optional uint32 target_element = 1; */
        if (message.targetElement !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.targetElement);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGSkillPreviewReactionInfo
 */
export const GCGSkillPreviewReactionInfo = new GCGSkillPreviewReactionInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGSkillPreviewElementReactionInfo$Type extends MessageType<GCGSkillPreviewElementReactionInfo> {
    constructor() {
        super("com.midnights.game.GCGSkillPreviewElementReactionInfo", [
            { no: 8, name: "fresh_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "source_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "reaction_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GCGSkillPreviewReactionInfo }
        ]);
    }
    create(value?: PartialMessage<GCGSkillPreviewElementReactionInfo>): GCGSkillPreviewElementReactionInfo {
        const message = { freshList: [], sourceList: [], reactionList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGSkillPreviewElementReactionInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGSkillPreviewElementReactionInfo): GCGSkillPreviewElementReactionInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 fresh_list */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.freshList.push(reader.uint32());
                    else
                        message.freshList.push(reader.uint32());
                    break;
                case /* repeated uint32 source_list */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.sourceList.push(reader.uint32());
                    else
                        message.sourceList.push(reader.uint32());
                    break;
                case /* repeated com.midnights.game.GCGSkillPreviewReactionInfo reaction_list */ 14:
                    message.reactionList.push(GCGSkillPreviewReactionInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGSkillPreviewElementReactionInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 fresh_list = 8; */
        if (message.freshList.length) {
            writer.tag(8, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.freshList.length; i++)
                writer.uint32(message.freshList[i]);
            writer.join();
        }
        /* repeated uint32 source_list = 2; */
        if (message.sourceList.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.sourceList.length; i++)
                writer.uint32(message.sourceList[i]);
            writer.join();
        }
        /* repeated com.midnights.game.GCGSkillPreviewReactionInfo reaction_list = 14; */
        for (let i = 0; i < message.reactionList.length; i++)
            GCGSkillPreviewReactionInfo.internalBinaryWrite(message.reactionList[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGSkillPreviewElementReactionInfo
 */
export const GCGSkillPreviewElementReactionInfo = new GCGSkillPreviewElementReactionInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGSkillPreviewCardInfo$Type extends MessageType<GCGSkillPreviewCardInfo> {
    constructor() {
        super("com.midnights.game.GCGSkillPreviewCardInfo", [
            { no: 3, name: "controller_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "owner_card_guid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "zone_type", kind: "enum", opt: true, T: () => ["com.midnights.game.GCGZoneType", GCGZoneType] },
            { no: 13, name: "card_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "card_guid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGSkillPreviewCardInfo>): GCGSkillPreviewCardInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGSkillPreviewCardInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGSkillPreviewCardInfo): GCGSkillPreviewCardInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 controller_id */ 3:
                    message.controllerId = reader.uint32();
                    break;
                case /* optional uint32 owner_card_guid */ 11:
                    message.ownerCardGuid = reader.uint32();
                    break;
                case /* optional com.midnights.game.GCGZoneType zone_type */ 14:
                    message.zoneType = reader.int32();
                    break;
                case /* optional uint32 card_id */ 13:
                    message.cardId = reader.uint32();
                    break;
                case /* optional uint32 card_guid */ 6:
                    message.cardGuid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGSkillPreviewCardInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 controller_id = 3; */
        if (message.controllerId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.controllerId);
        /* optional uint32 owner_card_guid = 11; */
        if (message.ownerCardGuid !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.ownerCardGuid);
        /* optional com.midnights.game.GCGZoneType zone_type = 14; */
        if (message.zoneType !== undefined)
            writer.tag(14, WireType.Varint).int32(message.zoneType);
        /* optional uint32 card_id = 13; */
        if (message.cardId !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.cardId);
        /* optional uint32 card_guid = 6; */
        if (message.cardGuid !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.cardGuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGSkillPreviewCardInfo
 */
export const GCGSkillPreviewCardInfo = new GCGSkillPreviewCardInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGSkillPreviewOnstageChangeInfo$Type extends MessageType<GCGSkillPreviewOnstageChangeInfo> {
    constructor() {
        super("com.midnights.game.GCGSkillPreviewOnstageChangeInfo", [
            { no: 6, name: "target_onstage_card_guid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "source_onstage_card_guid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGSkillPreviewOnstageChangeInfo>): GCGSkillPreviewOnstageChangeInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGSkillPreviewOnstageChangeInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGSkillPreviewOnstageChangeInfo): GCGSkillPreviewOnstageChangeInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 target_onstage_card_guid */ 6:
                    message.targetOnstageCardGuid = reader.uint32();
                    break;
                case /* optional uint32 source_onstage_card_guid */ 15:
                    message.sourceOnstageCardGuid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGSkillPreviewOnstageChangeInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 target_onstage_card_guid = 6; */
        if (message.targetOnstageCardGuid !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.targetOnstageCardGuid);
        /* optional uint32 source_onstage_card_guid = 15; */
        if (message.sourceOnstageCardGuid !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.sourceOnstageCardGuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGSkillPreviewOnstageChangeInfo
 */
export const GCGSkillPreviewOnstageChangeInfo = new GCGSkillPreviewOnstageChangeInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGSkillPreviewTokenInfo$Type extends MessageType<GCGSkillPreviewTokenInfo> {
    constructor() {
        super("com.midnights.game.GCGSkillPreviewTokenInfo", [
            { no: 3, name: "token_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "after_value", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "before_value", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGSkillPreviewTokenInfo>): GCGSkillPreviewTokenInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGSkillPreviewTokenInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGSkillPreviewTokenInfo): GCGSkillPreviewTokenInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 token_type */ 3:
                    message.tokenType = reader.uint32();
                    break;
                case /* optional uint32 after_value */ 12:
                    message.afterValue = reader.uint32();
                    break;
                case /* optional uint32 before_value */ 15:
                    message.beforeValue = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGSkillPreviewTokenInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 token_type = 3; */
        if (message.tokenType !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.tokenType);
        /* optional uint32 after_value = 12; */
        if (message.afterValue !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.afterValue);
        /* optional uint32 before_value = 15; */
        if (message.beforeValue !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.beforeValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGSkillPreviewTokenInfo
 */
export const GCGSkillPreviewTokenInfo = new GCGSkillPreviewTokenInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGSkillPreviewTokenChangeInfo$Type extends MessageType<GCGSkillPreviewTokenChangeInfo> {
    constructor() {
        super("com.midnights.game.GCGSkillPreviewTokenChangeInfo", [
            { no: 14, name: "token_change_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GCGSkillPreviewTokenInfo }
        ]);
    }
    create(value?: PartialMessage<GCGSkillPreviewTokenChangeInfo>): GCGSkillPreviewTokenChangeInfo {
        const message = { tokenChangeList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGSkillPreviewTokenChangeInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGSkillPreviewTokenChangeInfo): GCGSkillPreviewTokenChangeInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated com.midnights.game.GCGSkillPreviewTokenInfo token_change_list */ 14:
                    message.tokenChangeList.push(GCGSkillPreviewTokenInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGSkillPreviewTokenChangeInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated com.midnights.game.GCGSkillPreviewTokenInfo token_change_list = 14; */
        for (let i = 0; i < message.tokenChangeList.length; i++)
            GCGSkillPreviewTokenInfo.internalBinaryWrite(message.tokenChangeList[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGSkillPreviewTokenChangeInfo
 */
export const GCGSkillPreviewTokenChangeInfo = new GCGSkillPreviewTokenChangeInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGSkillPreviewInfo$Type extends MessageType<GCGSkillPreviewInfo> {
    constructor() {
        super("com.midnights.game.GCGSkillPreviewInfo", [
            { no: 12, name: "rm_card_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GCGSkillPreviewCardInfo },
            { no: 8, name: "hp_info_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => GCGSkillPreviewHpInfo } },
            { no: 5, name: "reaction_info_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => GCGSkillPreviewElementReactionInfo } },
            { no: 9, name: "change_onstage_character_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GCGSkillPreviewOnstageChangeInfo },
            { no: 6, name: "skill_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "card_token_change_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => GCGSkillPreviewTokenChangeInfo } },
            { no: 11, name: "add_card_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GCGSkillPreviewCardInfo }
        ]);
    }
    create(value?: PartialMessage<GCGSkillPreviewInfo>): GCGSkillPreviewInfo {
        const message = { rmCardList: [], hpInfoMap: {}, reactionInfoMap: {}, changeOnstageCharacterList: [], cardTokenChangeMap: {}, addCardList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGSkillPreviewInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGSkillPreviewInfo): GCGSkillPreviewInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated com.midnights.game.GCGSkillPreviewCardInfo rm_card_list */ 12:
                    message.rmCardList.push(GCGSkillPreviewCardInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* map<uint32, com.midnights.game.GCGSkillPreviewHpInfo> hp_info_map */ 8:
                    this.binaryReadMap8(message.hpInfoMap, reader, options);
                    break;
                case /* map<uint32, com.midnights.game.GCGSkillPreviewElementReactionInfo> reaction_info_map */ 5:
                    this.binaryReadMap5(message.reactionInfoMap, reader, options);
                    break;
                case /* repeated com.midnights.game.GCGSkillPreviewOnstageChangeInfo change_onstage_character_list */ 9:
                    message.changeOnstageCharacterList.push(GCGSkillPreviewOnstageChangeInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 skill_id */ 6:
                    message.skillId = reader.uint32();
                    break;
                case /* map<uint32, com.midnights.game.GCGSkillPreviewTokenChangeInfo> card_token_change_map */ 3:
                    this.binaryReadMap3(message.cardTokenChangeMap, reader, options);
                    break;
                case /* repeated com.midnights.game.GCGSkillPreviewCardInfo add_card_list */ 11:
                    message.addCardList.push(GCGSkillPreviewCardInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap8(map: GCGSkillPreviewInfo["hpInfoMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GCGSkillPreviewInfo["hpInfoMap"] | undefined, val: GCGSkillPreviewInfo["hpInfoMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = GCGSkillPreviewHpInfo.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field com.midnights.game.GCGSkillPreviewInfo.hp_info_map");
            }
        }
        map[key ?? 0] = val ?? GCGSkillPreviewHpInfo.create();
    }
    private binaryReadMap5(map: GCGSkillPreviewInfo["reactionInfoMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GCGSkillPreviewInfo["reactionInfoMap"] | undefined, val: GCGSkillPreviewInfo["reactionInfoMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = GCGSkillPreviewElementReactionInfo.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field com.midnights.game.GCGSkillPreviewInfo.reaction_info_map");
            }
        }
        map[key ?? 0] = val ?? GCGSkillPreviewElementReactionInfo.create();
    }
    private binaryReadMap3(map: GCGSkillPreviewInfo["cardTokenChangeMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GCGSkillPreviewInfo["cardTokenChangeMap"] | undefined, val: GCGSkillPreviewInfo["cardTokenChangeMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = GCGSkillPreviewTokenChangeInfo.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field com.midnights.game.GCGSkillPreviewInfo.card_token_change_map");
            }
        }
        map[key ?? 0] = val ?? GCGSkillPreviewTokenChangeInfo.create();
    }
    internalBinaryWrite(message: GCGSkillPreviewInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated com.midnights.game.GCGSkillPreviewCardInfo rm_card_list = 12; */
        for (let i = 0; i < message.rmCardList.length; i++)
            GCGSkillPreviewCardInfo.internalBinaryWrite(message.rmCardList[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* map<uint32, com.midnights.game.GCGSkillPreviewHpInfo> hp_info_map = 8; */
        for (let k of Object.keys(message.hpInfoMap)) {
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            GCGSkillPreviewHpInfo.internalBinaryWrite(message.hpInfoMap[k as any], writer, options);
            writer.join().join();
        }
        /* map<uint32, com.midnights.game.GCGSkillPreviewElementReactionInfo> reaction_info_map = 5; */
        for (let k of Object.keys(message.reactionInfoMap)) {
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            GCGSkillPreviewElementReactionInfo.internalBinaryWrite(message.reactionInfoMap[k as any], writer, options);
            writer.join().join();
        }
        /* repeated com.midnights.game.GCGSkillPreviewOnstageChangeInfo change_onstage_character_list = 9; */
        for (let i = 0; i < message.changeOnstageCharacterList.length; i++)
            GCGSkillPreviewOnstageChangeInfo.internalBinaryWrite(message.changeOnstageCharacterList[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 skill_id = 6; */
        if (message.skillId !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.skillId);
        /* map<uint32, com.midnights.game.GCGSkillPreviewTokenChangeInfo> card_token_change_map = 3; */
        for (let k of Object.keys(message.cardTokenChangeMap)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            GCGSkillPreviewTokenChangeInfo.internalBinaryWrite(message.cardTokenChangeMap[k as any], writer, options);
            writer.join().join();
        }
        /* repeated com.midnights.game.GCGSkillPreviewCardInfo add_card_list = 11; */
        for (let i = 0; i < message.addCardList.length; i++)
            GCGSkillPreviewCardInfo.internalBinaryWrite(message.addCardList[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGSkillPreviewInfo
 */
export const GCGSkillPreviewInfo = new GCGSkillPreviewInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGSkillPreviewNotify$Type extends MessageType<GCGSkillPreviewNotify> {
    constructor() {
        super("com.midnights.game.GCGSkillPreviewNotify", [
            { no: 9, name: "skill_preview_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GCGSkillPreviewInfo },
            { no: 5, name: "onstage_card_guid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "controller_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGSkillPreviewNotify>): GCGSkillPreviewNotify {
        const message = { skillPreviewList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGSkillPreviewNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGSkillPreviewNotify): GCGSkillPreviewNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated com.midnights.game.GCGSkillPreviewInfo skill_preview_list */ 9:
                    message.skillPreviewList.push(GCGSkillPreviewInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 onstage_card_guid */ 5:
                    message.onstageCardGuid = reader.uint32();
                    break;
                case /* optional uint32 controller_id */ 15:
                    message.controllerId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGSkillPreviewNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated com.midnights.game.GCGSkillPreviewInfo skill_preview_list = 9; */
        for (let i = 0; i < message.skillPreviewList.length; i++)
            GCGSkillPreviewInfo.internalBinaryWrite(message.skillPreviewList[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 onstage_card_guid = 5; */
        if (message.onstageCardGuid !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.onstageCardGuid);
        /* optional uint32 controller_id = 15; */
        if (message.controllerId !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.controllerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGSkillPreviewNotify
 */
export const GCGSkillPreviewNotify = new GCGSkillPreviewNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGSkillPreviewAskReq$Type extends MessageType<GCGSkillPreviewAskReq> {
    constructor() {
        super("com.midnights.game.GCGSkillPreviewAskReq", []);
    }
    create(value?: PartialMessage<GCGSkillPreviewAskReq>): GCGSkillPreviewAskReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGSkillPreviewAskReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGSkillPreviewAskReq): GCGSkillPreviewAskReq {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GCGSkillPreviewAskReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGSkillPreviewAskReq
 */
export const GCGSkillPreviewAskReq = new GCGSkillPreviewAskReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGSkillPreviewAskRsp$Type extends MessageType<GCGSkillPreviewAskRsp> {
    constructor() {
        super("com.midnights.game.GCGSkillPreviewAskRsp", [
            { no: 1, name: "retcode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGSkillPreviewAskRsp>): GCGSkillPreviewAskRsp {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGSkillPreviewAskRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGSkillPreviewAskRsp): GCGSkillPreviewAskRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 retcode */ 1:
                    message.retcode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGSkillPreviewAskRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 retcode = 1; */
        if (message.retcode !== undefined)
            writer.tag(1, WireType.Varint).int32(message.retcode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGSkillPreviewAskRsp
 */
export const GCGSkillPreviewAskRsp = new GCGSkillPreviewAskRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGChallengeUpdateNotify$Type extends MessageType<GCGChallengeUpdateNotify> {
    constructor() {
        super("com.midnights.game.GCGChallengeUpdateNotify", [
            { no: 12, name: "server_seq", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "challenge", kind: "message", T: () => GCGDuelChallenge }
        ]);
    }
    create(value?: PartialMessage<GCGChallengeUpdateNotify>): GCGChallengeUpdateNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGChallengeUpdateNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGChallengeUpdateNotify): GCGChallengeUpdateNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 server_seq */ 12:
                    message.serverSeq = reader.uint32();
                    break;
                case /* optional com.midnights.game.GCGDuelChallenge challenge */ 13:
                    message.challenge = GCGDuelChallenge.internalBinaryRead(reader, reader.uint32(), options, message.challenge);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGChallengeUpdateNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 server_seq = 12; */
        if (message.serverSeq !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.serverSeq);
        /* optional com.midnights.game.GCGDuelChallenge challenge = 13; */
        if (message.challenge)
            GCGDuelChallenge.internalBinaryWrite(message.challenge, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGChallengeUpdateNotify
 */
export const GCGChallengeUpdateNotify = new GCGChallengeUpdateNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGDSDeckData$Type extends MessageType<GCGDSDeckData> {
    constructor() {
        super("com.midnights.game.GCGDSDeckData", [
            { no: 1, name: "card_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "card_back_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "character_card_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "create_time", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 4, name: "is_valid", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "field_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGDSDeckData>): GCGDSDeckData {
        const message = { cardList: [], characterCardList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGDSDeckData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGDSDeckData): GCGDSDeckData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 card_list */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.cardList.push(reader.uint32());
                    else
                        message.cardList.push(reader.uint32());
                    break;
                case /* optional uint32 card_back_id */ 15:
                    message.cardBackId = reader.uint32();
                    break;
                case /* repeated uint32 character_card_list */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.characterCardList.push(reader.uint32());
                    else
                        message.characterCardList.push(reader.uint32());
                    break;
                case /* optional string name */ 5:
                    message.name = reader.string();
                    break;
                case /* optional uint32 id */ 3:
                    message.id = reader.uint32();
                    break;
                case /* optional fixed32 create_time */ 13:
                    message.createTime = reader.fixed32();
                    break;
                case /* optional bool is_valid */ 4:
                    message.isValid = reader.bool();
                    break;
                case /* optional uint32 field_id */ 7:
                    message.fieldId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGDSDeckData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 card_list = 1; */
        if (message.cardList.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.cardList.length; i++)
                writer.uint32(message.cardList[i]);
            writer.join();
        }
        /* optional uint32 card_back_id = 15; */
        if (message.cardBackId !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.cardBackId);
        /* repeated uint32 character_card_list = 10; */
        if (message.characterCardList.length) {
            writer.tag(10, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.characterCardList.length; i++)
                writer.uint32(message.characterCardList[i]);
            writer.join();
        }
        /* optional string name = 5; */
        if (message.name !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.name);
        /* optional uint32 id = 3; */
        if (message.id !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.id);
        /* optional fixed32 create_time = 13; */
        if (message.createTime !== undefined)
            writer.tag(13, WireType.Bit32).fixed32(message.createTime);
        /* optional bool is_valid = 4; */
        if (message.isValid !== undefined)
            writer.tag(4, WireType.Varint).bool(message.isValid);
        /* optional uint32 field_id = 7; */
        if (message.fieldId !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.fieldId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGDSDeckData
 */
export const GCGDSDeckData = new GCGDSDeckData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGDSCardData$Type extends MessageType<GCGDSCardData> {
    constructor() {
        super("com.midnights.game.GCGDSCardData", [
            { no: 14, name: "card_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "unlock_face_type_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "num", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "proficiency", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "face_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGDSCardData>): GCGDSCardData {
        const message = { unlockFaceTypeList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGDSCardData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGDSCardData): GCGDSCardData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 card_id */ 14:
                    message.cardId = reader.uint32();
                    break;
                case /* repeated uint32 unlock_face_type_list */ 9:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unlockFaceTypeList.push(reader.uint32());
                    else
                        message.unlockFaceTypeList.push(reader.uint32());
                    break;
                case /* optional uint32 num */ 12:
                    message.num = reader.uint32();
                    break;
                case /* optional uint32 proficiency */ 8:
                    message.proficiency = reader.uint32();
                    break;
                case /* optional uint32 face_type */ 6:
                    message.faceType = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGDSCardData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 card_id = 14; */
        if (message.cardId !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.cardId);
        /* repeated uint32 unlock_face_type_list = 9; */
        if (message.unlockFaceTypeList.length) {
            writer.tag(9, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.unlockFaceTypeList.length; i++)
                writer.uint32(message.unlockFaceTypeList[i]);
            writer.join();
        }
        /* optional uint32 num = 12; */
        if (message.num !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.num);
        /* optional uint32 proficiency = 8; */
        if (message.proficiency !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.proficiency);
        /* optional uint32 face_type = 6; */
        if (message.faceType !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.faceType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGDSCardData
 */
export const GCGDSCardData = new GCGDSCardData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGDSDataNotify$Type extends MessageType<GCGDSDataNotify> {
    constructor() {
        super("com.midnights.game.GCGDSDataNotify", [
            { no: 4, name: "deck_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GCGDSDeckData },
            { no: 5, name: "unlock_card_back_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "unlock_field_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "cur_deck_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "card_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GCGDSCardData },
            { no: 1, name: "unlock_deck_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGDSDataNotify>): GCGDSDataNotify {
        const message = { deckList: [], unlockCardBackIdList: [], unlockFieldIdList: [], cardList: [], unlockDeckIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGDSDataNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGDSDataNotify): GCGDSDataNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated com.midnights.game.GCGDSDeckData deck_list */ 4:
                    message.deckList.push(GCGDSDeckData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 unlock_card_back_id_list */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unlockCardBackIdList.push(reader.uint32());
                    else
                        message.unlockCardBackIdList.push(reader.uint32());
                    break;
                case /* repeated uint32 unlock_field_id_list */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unlockFieldIdList.push(reader.uint32());
                    else
                        message.unlockFieldIdList.push(reader.uint32());
                    break;
                case /* optional uint32 cur_deck_id */ 10:
                    message.curDeckId = reader.uint32();
                    break;
                case /* repeated com.midnights.game.GCGDSCardData card_list */ 3:
                    message.cardList.push(GCGDSCardData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 unlock_deck_id_list */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unlockDeckIdList.push(reader.uint32());
                    else
                        message.unlockDeckIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGDSDataNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated com.midnights.game.GCGDSDeckData deck_list = 4; */
        for (let i = 0; i < message.deckList.length; i++)
            GCGDSDeckData.internalBinaryWrite(message.deckList[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 unlock_card_back_id_list = 5; */
        if (message.unlockCardBackIdList.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.unlockCardBackIdList.length; i++)
                writer.uint32(message.unlockCardBackIdList[i]);
            writer.join();
        }
        /* repeated uint32 unlock_field_id_list = 6; */
        if (message.unlockFieldIdList.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.unlockFieldIdList.length; i++)
                writer.uint32(message.unlockFieldIdList[i]);
            writer.join();
        }
        /* optional uint32 cur_deck_id = 10; */
        if (message.curDeckId !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.curDeckId);
        /* repeated com.midnights.game.GCGDSCardData card_list = 3; */
        for (let i = 0; i < message.cardList.length; i++)
            GCGDSCardData.internalBinaryWrite(message.cardList[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 unlock_deck_id_list = 1; */
        if (message.unlockDeckIdList.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.unlockDeckIdList.length; i++)
                writer.uint32(message.unlockDeckIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGDSDataNotify
 */
export const GCGDSDataNotify = new GCGDSDataNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGDSCardBackUnlockNotify$Type extends MessageType<GCGDSCardBackUnlockNotify> {
    constructor() {
        super("com.midnights.game.GCGDSCardBackUnlockNotify", [
            { no: 6, name: "card_back_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGDSCardBackUnlockNotify>): GCGDSCardBackUnlockNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGDSCardBackUnlockNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGDSCardBackUnlockNotify): GCGDSCardBackUnlockNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 card_back_id */ 6:
                    message.cardBackId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGDSCardBackUnlockNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 card_back_id = 6; */
        if (message.cardBackId !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.cardBackId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGDSCardBackUnlockNotify
 */
export const GCGDSCardBackUnlockNotify = new GCGDSCardBackUnlockNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGDSFieldUnlockNotify$Type extends MessageType<GCGDSFieldUnlockNotify> {
    constructor() {
        super("com.midnights.game.GCGDSFieldUnlockNotify", [
            { no: 1, name: "field_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGDSFieldUnlockNotify>): GCGDSFieldUnlockNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGDSFieldUnlockNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGDSFieldUnlockNotify): GCGDSFieldUnlockNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 field_id */ 1:
                    message.fieldId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGDSFieldUnlockNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 field_id = 1; */
        if (message.fieldId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.fieldId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGDSFieldUnlockNotify
 */
export const GCGDSFieldUnlockNotify = new GCGDSFieldUnlockNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGDSCardFaceUnlockNotify$Type extends MessageType<GCGDSCardFaceUnlockNotify> {
    constructor() {
        super("com.midnights.game.GCGDSCardFaceUnlockNotify", [
            { no: 13, name: "card_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "face_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGDSCardFaceUnlockNotify>): GCGDSCardFaceUnlockNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGDSCardFaceUnlockNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGDSCardFaceUnlockNotify): GCGDSCardFaceUnlockNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 card_id */ 13:
                    message.cardId = reader.uint32();
                    break;
                case /* optional uint32 face_type */ 1:
                    message.faceType = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGDSCardFaceUnlockNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 card_id = 13; */
        if (message.cardId !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.cardId);
        /* optional uint32 face_type = 1; */
        if (message.faceType !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.faceType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGDSCardFaceUnlockNotify
 */
export const GCGDSCardFaceUnlockNotify = new GCGDSCardFaceUnlockNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGDSCardNumChangeNotify$Type extends MessageType<GCGDSCardNumChangeNotify> {
    constructor() {
        super("com.midnights.game.GCGDSCardNumChangeNotify", [
            { no: 4, name: "card_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "num", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGDSCardNumChangeNotify>): GCGDSCardNumChangeNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGDSCardNumChangeNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGDSCardNumChangeNotify): GCGDSCardNumChangeNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 card_id */ 4:
                    message.cardId = reader.uint32();
                    break;
                case /* optional uint32 num */ 10:
                    message.num = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGDSCardNumChangeNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 card_id = 4; */
        if (message.cardId !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.cardId);
        /* optional uint32 num = 10; */
        if (message.num !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.num);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGDSCardNumChangeNotify
 */
export const GCGDSCardNumChangeNotify = new GCGDSCardNumChangeNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGDSChangeCardFaceReq$Type extends MessageType<GCGDSChangeCardFaceReq> {
    constructor() {
        super("com.midnights.game.GCGDSChangeCardFaceReq", [
            { no: 6, name: "face_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "card_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGDSChangeCardFaceReq>): GCGDSChangeCardFaceReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGDSChangeCardFaceReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGDSChangeCardFaceReq): GCGDSChangeCardFaceReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 face_type */ 6:
                    message.faceType = reader.uint32();
                    break;
                case /* optional uint32 card_id */ 3:
                    message.cardId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGDSChangeCardFaceReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 face_type = 6; */
        if (message.faceType !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.faceType);
        /* optional uint32 card_id = 3; */
        if (message.cardId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.cardId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGDSChangeCardFaceReq
 */
export const GCGDSChangeCardFaceReq = new GCGDSChangeCardFaceReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGDSChangeCardFaceRsp$Type extends MessageType<GCGDSChangeCardFaceRsp> {
    constructor() {
        super("com.midnights.game.GCGDSChangeCardFaceRsp", [
            { no: 8, name: "face_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "card_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "retcode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGDSChangeCardFaceRsp>): GCGDSChangeCardFaceRsp {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGDSChangeCardFaceRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGDSChangeCardFaceRsp): GCGDSChangeCardFaceRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 face_type */ 8:
                    message.faceType = reader.uint32();
                    break;
                case /* optional uint32 card_id */ 4:
                    message.cardId = reader.uint32();
                    break;
                case /* optional int32 retcode */ 9:
                    message.retcode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGDSChangeCardFaceRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 face_type = 8; */
        if (message.faceType !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.faceType);
        /* optional uint32 card_id = 4; */
        if (message.cardId !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.cardId);
        /* optional int32 retcode = 9; */
        if (message.retcode !== undefined)
            writer.tag(9, WireType.Varint).int32(message.retcode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGDSChangeCardFaceRsp
 */
export const GCGDSChangeCardFaceRsp = new GCGDSChangeCardFaceRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGDSChangeCardBackReq$Type extends MessageType<GCGDSChangeCardBackReq> {
    constructor() {
        super("com.midnights.game.GCGDSChangeCardBackReq", [
            { no: 10, name: "deck_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "card_back_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGDSChangeCardBackReq>): GCGDSChangeCardBackReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGDSChangeCardBackReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGDSChangeCardBackReq): GCGDSChangeCardBackReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 deck_id */ 10:
                    message.deckId = reader.uint32();
                    break;
                case /* optional uint32 card_back_id */ 12:
                    message.cardBackId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGDSChangeCardBackReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 deck_id = 10; */
        if (message.deckId !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.deckId);
        /* optional uint32 card_back_id = 12; */
        if (message.cardBackId !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.cardBackId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGDSChangeCardBackReq
 */
export const GCGDSChangeCardBackReq = new GCGDSChangeCardBackReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGDSChangeCardBackRsp$Type extends MessageType<GCGDSChangeCardBackRsp> {
    constructor() {
        super("com.midnights.game.GCGDSChangeCardBackRsp", [
            { no: 15, name: "retcode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "card_back_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "deck_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGDSChangeCardBackRsp>): GCGDSChangeCardBackRsp {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGDSChangeCardBackRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGDSChangeCardBackRsp): GCGDSChangeCardBackRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 retcode */ 15:
                    message.retcode = reader.int32();
                    break;
                case /* optional uint32 card_back_id */ 6:
                    message.cardBackId = reader.uint32();
                    break;
                case /* optional uint32 deck_id */ 5:
                    message.deckId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGDSChangeCardBackRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 retcode = 15; */
        if (message.retcode !== undefined)
            writer.tag(15, WireType.Varint).int32(message.retcode);
        /* optional uint32 card_back_id = 6; */
        if (message.cardBackId !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.cardBackId);
        /* optional uint32 deck_id = 5; */
        if (message.deckId !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.deckId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGDSChangeCardBackRsp
 */
export const GCGDSChangeCardBackRsp = new GCGDSChangeCardBackRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGDSChangeFieldReq$Type extends MessageType<GCGDSChangeFieldReq> {
    constructor() {
        super("com.midnights.game.GCGDSChangeFieldReq", [
            { no: 6, name: "field_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "deck_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGDSChangeFieldReq>): GCGDSChangeFieldReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGDSChangeFieldReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGDSChangeFieldReq): GCGDSChangeFieldReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 field_id */ 6:
                    message.fieldId = reader.uint32();
                    break;
                case /* optional uint32 deck_id */ 11:
                    message.deckId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGDSChangeFieldReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 field_id = 6; */
        if (message.fieldId !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.fieldId);
        /* optional uint32 deck_id = 11; */
        if (message.deckId !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.deckId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGDSChangeFieldReq
 */
export const GCGDSChangeFieldReq = new GCGDSChangeFieldReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGDSChangeFieldRsp$Type extends MessageType<GCGDSChangeFieldRsp> {
    constructor() {
        super("com.midnights.game.GCGDSChangeFieldRsp", [
            { no: 1, name: "retcode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "field_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "deck_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGDSChangeFieldRsp>): GCGDSChangeFieldRsp {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGDSChangeFieldRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGDSChangeFieldRsp): GCGDSChangeFieldRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 retcode */ 1:
                    message.retcode = reader.int32();
                    break;
                case /* optional uint32 field_id */ 3:
                    message.fieldId = reader.uint32();
                    break;
                case /* optional uint32 deck_id */ 2:
                    message.deckId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGDSChangeFieldRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 retcode = 1; */
        if (message.retcode !== undefined)
            writer.tag(1, WireType.Varint).int32(message.retcode);
        /* optional uint32 field_id = 3; */
        if (message.fieldId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.fieldId);
        /* optional uint32 deck_id = 2; */
        if (message.deckId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.deckId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGDSChangeFieldRsp
 */
export const GCGDSChangeFieldRsp = new GCGDSChangeFieldRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGDSChangeDeckNameReq$Type extends MessageType<GCGDSChangeDeckNameReq> {
    constructor() {
        super("com.midnights.game.GCGDSChangeDeckNameReq", [
            { no: 13, name: "deck_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GCGDSChangeDeckNameReq>): GCGDSChangeDeckNameReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGDSChangeDeckNameReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGDSChangeDeckNameReq): GCGDSChangeDeckNameReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 deck_id */ 13:
                    message.deckId = reader.uint32();
                    break;
                case /* optional string name */ 7:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGDSChangeDeckNameReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 deck_id = 13; */
        if (message.deckId !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.deckId);
        /* optional string name = 7; */
        if (message.name !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGDSChangeDeckNameReq
 */
export const GCGDSChangeDeckNameReq = new GCGDSChangeDeckNameReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGDSChangeDeckNameRsp$Type extends MessageType<GCGDSChangeDeckNameRsp> {
    constructor() {
        super("com.midnights.game.GCGDSChangeDeckNameRsp", [
            { no: 13, name: "deck_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "retcode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GCGDSChangeDeckNameRsp>): GCGDSChangeDeckNameRsp {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGDSChangeDeckNameRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGDSChangeDeckNameRsp): GCGDSChangeDeckNameRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 deck_id */ 13:
                    message.deckId = reader.uint32();
                    break;
                case /* optional int32 retcode */ 14:
                    message.retcode = reader.int32();
                    break;
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGDSChangeDeckNameRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 deck_id = 13; */
        if (message.deckId !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.deckId);
        /* optional int32 retcode = 14; */
        if (message.retcode !== undefined)
            writer.tag(14, WireType.Varint).int32(message.retcode);
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGDSChangeDeckNameRsp
 */
export const GCGDSChangeDeckNameRsp = new GCGDSChangeDeckNameRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGDSDeckSaveReq$Type extends MessageType<GCGDSDeckSaveReq> {
    constructor() {
        super("com.midnights.game.GCGDSDeckSaveReq", [
            { no: 1, name: "deck_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "card_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "character_card_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GCGDSDeckSaveReq>): GCGDSDeckSaveReq {
        const message = { cardList: [], characterCardList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGDSDeckSaveReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGDSDeckSaveReq): GCGDSDeckSaveReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 deck_id */ 1:
                    message.deckId = reader.uint32();
                    break;
                case /* repeated uint32 card_list */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.cardList.push(reader.uint32());
                    else
                        message.cardList.push(reader.uint32());
                    break;
                case /* repeated uint32 character_card_list */ 9:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.characterCardList.push(reader.uint32());
                    else
                        message.characterCardList.push(reader.uint32());
                    break;
                case /* optional string name */ 14:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGDSDeckSaveReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 deck_id = 1; */
        if (message.deckId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.deckId);
        /* repeated uint32 card_list = 4; */
        if (message.cardList.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.cardList.length; i++)
                writer.uint32(message.cardList[i]);
            writer.join();
        }
        /* repeated uint32 character_card_list = 9; */
        if (message.characterCardList.length) {
            writer.tag(9, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.characterCardList.length; i++)
                writer.uint32(message.characterCardList[i]);
            writer.join();
        }
        /* optional string name = 14; */
        if (message.name !== undefined)
            writer.tag(14, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGDSDeckSaveReq
 */
export const GCGDSDeckSaveReq = new GCGDSDeckSaveReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGDSDeckSaveRsp$Type extends MessageType<GCGDSDeckSaveRsp> {
    constructor() {
        super("com.midnights.game.GCGDSDeckSaveRsp", [
            { no: 14, name: "create_time", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 11, name: "deck_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "retcode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "is_valid", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GCGDSDeckSaveRsp>): GCGDSDeckSaveRsp {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGDSDeckSaveRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGDSDeckSaveRsp): GCGDSDeckSaveRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 create_time */ 14:
                    message.createTime = reader.fixed32();
                    break;
                case /* optional uint32 deck_id */ 11:
                    message.deckId = reader.uint32();
                    break;
                case /* optional int32 retcode */ 8:
                    message.retcode = reader.int32();
                    break;
                case /* optional bool is_valid */ 4:
                    message.isValid = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGDSDeckSaveRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 create_time = 14; */
        if (message.createTime !== undefined)
            writer.tag(14, WireType.Bit32).fixed32(message.createTime);
        /* optional uint32 deck_id = 11; */
        if (message.deckId !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.deckId);
        /* optional int32 retcode = 8; */
        if (message.retcode !== undefined)
            writer.tag(8, WireType.Varint).int32(message.retcode);
        /* optional bool is_valid = 4; */
        if (message.isValid !== undefined)
            writer.tag(4, WireType.Varint).bool(message.isValid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGDSDeckSaveRsp
 */
export const GCGDSDeckSaveRsp = new GCGDSDeckSaveRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGDSChangeCurDeckReq$Type extends MessageType<GCGDSChangeCurDeckReq> {
    constructor() {
        super("com.midnights.game.GCGDSChangeCurDeckReq", [
            { no: 3, name: "deck_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGDSChangeCurDeckReq>): GCGDSChangeCurDeckReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGDSChangeCurDeckReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGDSChangeCurDeckReq): GCGDSChangeCurDeckReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 deck_id */ 3:
                    message.deckId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGDSChangeCurDeckReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 deck_id = 3; */
        if (message.deckId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.deckId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGDSChangeCurDeckReq
 */
export const GCGDSChangeCurDeckReq = new GCGDSChangeCurDeckReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGDSChangeCurDeckRsp$Type extends MessageType<GCGDSChangeCurDeckRsp> {
    constructor() {
        super("com.midnights.game.GCGDSChangeCurDeckRsp", [
            { no: 8, name: "retcode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "deck_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGDSChangeCurDeckRsp>): GCGDSChangeCurDeckRsp {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGDSChangeCurDeckRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGDSChangeCurDeckRsp): GCGDSChangeCurDeckRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 retcode */ 8:
                    message.retcode = reader.int32();
                    break;
                case /* optional uint32 deck_id */ 14:
                    message.deckId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGDSChangeCurDeckRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 retcode = 8; */
        if (message.retcode !== undefined)
            writer.tag(8, WireType.Varint).int32(message.retcode);
        /* optional uint32 deck_id = 14; */
        if (message.deckId !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.deckId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGDSChangeCurDeckRsp
 */
export const GCGDSChangeCurDeckRsp = new GCGDSChangeCurDeckRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGDSCurDeckChangeNotify$Type extends MessageType<GCGDSCurDeckChangeNotify> {
    constructor() {
        super("com.midnights.game.GCGDSCurDeckChangeNotify", [
            { no: 6, name: "deck_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGDSCurDeckChangeNotify>): GCGDSCurDeckChangeNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGDSCurDeckChangeNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGDSCurDeckChangeNotify): GCGDSCurDeckChangeNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 deck_id */ 6:
                    message.deckId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGDSCurDeckChangeNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 deck_id = 6; */
        if (message.deckId !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.deckId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGDSCurDeckChangeNotify
 */
export const GCGDSCurDeckChangeNotify = new GCGDSCurDeckChangeNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGDSDeleteDeckReq$Type extends MessageType<GCGDSDeleteDeckReq> {
    constructor() {
        super("com.midnights.game.GCGDSDeleteDeckReq", [
            { no: 15, name: "deck_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGDSDeleteDeckReq>): GCGDSDeleteDeckReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGDSDeleteDeckReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGDSDeleteDeckReq): GCGDSDeleteDeckReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 deck_id */ 15:
                    message.deckId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGDSDeleteDeckReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 deck_id = 15; */
        if (message.deckId !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.deckId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGDSDeleteDeckReq
 */
export const GCGDSDeleteDeckReq = new GCGDSDeleteDeckReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGDSDeleteDeckRsp$Type extends MessageType<GCGDSDeleteDeckRsp> {
    constructor() {
        super("com.midnights.game.GCGDSDeleteDeckRsp", [
            { no: 14, name: "retcode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "deck_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGDSDeleteDeckRsp>): GCGDSDeleteDeckRsp {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGDSDeleteDeckRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGDSDeleteDeckRsp): GCGDSDeleteDeckRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 retcode */ 14:
                    message.retcode = reader.int32();
                    break;
                case /* optional uint32 deck_id */ 7:
                    message.deckId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGDSDeleteDeckRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 retcode = 14; */
        if (message.retcode !== undefined)
            writer.tag(14, WireType.Varint).int32(message.retcode);
        /* optional uint32 deck_id = 7; */
        if (message.deckId !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.deckId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGDSDeleteDeckRsp
 */
export const GCGDSDeleteDeckRsp = new GCGDSDeleteDeckRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGDSDeckUnlockNotify$Type extends MessageType<GCGDSDeckUnlockNotify> {
    constructor() {
        super("com.midnights.game.GCGDSDeckUnlockNotify", [
            { no: 15, name: "deck_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGDSDeckUnlockNotify>): GCGDSDeckUnlockNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGDSDeckUnlockNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGDSDeckUnlockNotify): GCGDSDeckUnlockNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 deck_id */ 15:
                    message.deckId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGDSDeckUnlockNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 deck_id = 15; */
        if (message.deckId !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.deckId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGDSDeckUnlockNotify
 */
export const GCGDSDeckUnlockNotify = new GCGDSDeckUnlockNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGDSCardProficiencyNotify$Type extends MessageType<GCGDSCardProficiencyNotify> {
    constructor() {
        super("com.midnights.game.GCGDSCardProficiencyNotify", [
            { no: 2, name: "proficiency", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "card_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGDSCardProficiencyNotify>): GCGDSCardProficiencyNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGDSCardProficiencyNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGDSCardProficiencyNotify): GCGDSCardProficiencyNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 proficiency */ 2:
                    message.proficiency = reader.uint32();
                    break;
                case /* optional uint32 card_id */ 12:
                    message.cardId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGDSCardProficiencyNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 proficiency = 2; */
        if (message.proficiency !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.proficiency);
        /* optional uint32 card_id = 12; */
        if (message.cardId !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.cardId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGDSCardProficiencyNotify
 */
export const GCGDSCardProficiencyNotify = new GCGDSCardProficiencyNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGTCTavernInfoNotify$Type extends MessageType<GCGTCTavernInfoNotify> {
    constructor() {
        super("com.midnights.game.GCGTCTavernInfoNotify", [
            { no: 14, name: "is_last_duel_win", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "level_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "is_owner_in_duel", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "point_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "avatar_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "character_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "element_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGTCTavernInfoNotify>): GCGTCTavernInfoNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGTCTavernInfoNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGTCTavernInfoNotify): GCGTCTavernInfoNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool is_last_duel_win */ 14:
                    message.isLastDuelWin = reader.bool();
                    break;
                case /* optional uint32 level_id */ 11:
                    message.levelId = reader.uint32();
                    break;
                case /* optional bool is_owner_in_duel */ 5:
                    message.isOwnerInDuel = reader.bool();
                    break;
                case /* optional uint32 point_id */ 3:
                    message.pointId = reader.uint32();
                    break;
                case /* optional uint32 avatar_id */ 12:
                    message.avatarId = reader.uint32();
                    break;
                case /* optional uint32 character_id */ 7:
                    message.characterId = reader.uint32();
                    break;
                case /* optional uint32 element_type */ 10:
                    message.elementType = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGTCTavernInfoNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool is_last_duel_win = 14; */
        if (message.isLastDuelWin !== undefined)
            writer.tag(14, WireType.Varint).bool(message.isLastDuelWin);
        /* optional uint32 level_id = 11; */
        if (message.levelId !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.levelId);
        /* optional bool is_owner_in_duel = 5; */
        if (message.isOwnerInDuel !== undefined)
            writer.tag(5, WireType.Varint).bool(message.isOwnerInDuel);
        /* optional uint32 point_id = 3; */
        if (message.pointId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.pointId);
        /* optional uint32 avatar_id = 12; */
        if (message.avatarId !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.avatarId);
        /* optional uint32 character_id = 7; */
        if (message.characterId !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.characterId);
        /* optional uint32 element_type = 10; */
        if (message.elementType !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.elementType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGTCTavernInfoNotify
 */
export const GCGTCTavernInfoNotify = new GCGTCTavernInfoNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGTCInviteReq$Type extends MessageType<GCGTCInviteReq> {
    constructor() {
        super("com.midnights.game.GCGTCInviteReq", [
            { no: 3, name: "level_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "character_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGTCInviteReq>): GCGTCInviteReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGTCInviteReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGTCInviteReq): GCGTCInviteReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 level_id */ 3:
                    message.levelId = reader.uint32();
                    break;
                case /* optional uint32 character_id */ 6:
                    message.characterId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGTCInviteReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 level_id = 3; */
        if (message.levelId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.levelId);
        /* optional uint32 character_id = 6; */
        if (message.characterId !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.characterId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGTCInviteReq
 */
export const GCGTCInviteReq = new GCGTCInviteReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGTCInviteRsp$Type extends MessageType<GCGTCInviteRsp> {
    constructor() {
        super("com.midnights.game.GCGTCInviteRsp", [
            { no: 12, name: "character_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "retcode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGTCInviteRsp>): GCGTCInviteRsp {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGTCInviteRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGTCInviteRsp): GCGTCInviteRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 character_id */ 12:
                    message.characterId = reader.uint32();
                    break;
                case /* optional int32 retcode */ 5:
                    message.retcode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGTCInviteRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 character_id = 12; */
        if (message.characterId !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.characterId);
        /* optional int32 retcode = 5; */
        if (message.retcode !== undefined)
            writer.tag(5, WireType.Varint).int32(message.retcode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGTCInviteRsp
 */
export const GCGTCInviteRsp = new GCGTCInviteRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGTCTavernChallengeData$Type extends MessageType<GCGTCTavernChallengeData> {
    constructor() {
        super("com.midnights.game.GCGTCTavernChallengeData", [
            { no: 1, name: "unlock_level_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "character_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGTCTavernChallengeData>): GCGTCTavernChallengeData {
        const message = { unlockLevelIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGTCTavernChallengeData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGTCTavernChallengeData): GCGTCTavernChallengeData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 unlock_level_id_list */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unlockLevelIdList.push(reader.uint32());
                    else
                        message.unlockLevelIdList.push(reader.uint32());
                    break;
                case /* optional uint32 character_id */ 8:
                    message.characterId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGTCTavernChallengeData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 unlock_level_id_list = 1; */
        if (message.unlockLevelIdList.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.unlockLevelIdList.length; i++)
                writer.uint32(message.unlockLevelIdList[i]);
            writer.join();
        }
        /* optional uint32 character_id = 8; */
        if (message.characterId !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.characterId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGTCTavernChallengeData
 */
export const GCGTCTavernChallengeData = new GCGTCTavernChallengeData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGTCTavernChallengeDataNotify$Type extends MessageType<GCGTCTavernChallengeDataNotify> {
    constructor() {
        super("com.midnights.game.GCGTCTavernChallengeDataNotify", [
            { no: 13, name: "tavern_challenge_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GCGTCTavernChallengeData }
        ]);
    }
    create(value?: PartialMessage<GCGTCTavernChallengeDataNotify>): GCGTCTavernChallengeDataNotify {
        const message = { tavernChallengeList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGTCTavernChallengeDataNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGTCTavernChallengeDataNotify): GCGTCTavernChallengeDataNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated com.midnights.game.GCGTCTavernChallengeData tavern_challenge_list */ 13:
                    message.tavernChallengeList.push(GCGTCTavernChallengeData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGTCTavernChallengeDataNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated com.midnights.game.GCGTCTavernChallengeData tavern_challenge_list = 13; */
        for (let i = 0; i < message.tavernChallengeList.length; i++)
            GCGTCTavernChallengeData.internalBinaryWrite(message.tavernChallengeList[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGTCTavernChallengeDataNotify
 */
export const GCGTCTavernChallengeDataNotify = new GCGTCTavernChallengeDataNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGTCTavernChallengeUpdateNotify$Type extends MessageType<GCGTCTavernChallengeUpdateNotify> {
    constructor() {
        super("com.midnights.game.GCGTCTavernChallengeUpdateNotify", [
            { no: 5, name: "tavern_challenge", kind: "message", T: () => GCGTCTavernChallengeData }
        ]);
    }
    create(value?: PartialMessage<GCGTCTavernChallengeUpdateNotify>): GCGTCTavernChallengeUpdateNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGTCTavernChallengeUpdateNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGTCTavernChallengeUpdateNotify): GCGTCTavernChallengeUpdateNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.GCGTCTavernChallengeData tavern_challenge */ 5:
                    message.tavernChallenge = GCGTCTavernChallengeData.internalBinaryRead(reader, reader.uint32(), options, message.tavernChallenge);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGTCTavernChallengeUpdateNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.GCGTCTavernChallengeData tavern_challenge = 5; */
        if (message.tavernChallenge)
            GCGTCTavernChallengeData.internalBinaryWrite(message.tavernChallenge, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGTCTavernChallengeUpdateNotify
 */
export const GCGTCTavernChallengeUpdateNotify = new GCGTCTavernChallengeUpdateNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGGrowthLevelNotify$Type extends MessageType<GCGGrowthLevelNotify> {
    constructor() {
        super("com.midnights.game.GCGGrowthLevelNotify", [
            { no: 7, name: "exp", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "level", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGGrowthLevelNotify>): GCGGrowthLevelNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGGrowthLevelNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGGrowthLevelNotify): GCGGrowthLevelNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 exp */ 7:
                    message.exp = reader.uint32();
                    break;
                case /* optional uint32 level */ 11:
                    message.level = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGGrowthLevelNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 exp = 7; */
        if (message.exp !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.exp);
        /* optional uint32 level = 11; */
        if (message.level !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.level);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGGrowthLevelNotify
 */
export const GCGGrowthLevelNotify = new GCGGrowthLevelNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGGrowthLevelRewardNotify$Type extends MessageType<GCGGrowthLevelRewardNotify> {
    constructor() {
        super("com.midnights.game.GCGGrowthLevelRewardNotify", [
            { no: 8, name: "level_reward_taken_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGGrowthLevelRewardNotify>): GCGGrowthLevelRewardNotify {
        const message = { levelRewardTakenList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGGrowthLevelRewardNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGGrowthLevelRewardNotify): GCGGrowthLevelRewardNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 level_reward_taken_list */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.levelRewardTakenList.push(reader.uint32());
                    else
                        message.levelRewardTakenList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGGrowthLevelRewardNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 level_reward_taken_list = 8; */
        if (message.levelRewardTakenList.length) {
            writer.tag(8, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.levelRewardTakenList.length; i++)
                writer.uint32(message.levelRewardTakenList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGGrowthLevelRewardNotify
 */
export const GCGGrowthLevelRewardNotify = new GCGGrowthLevelRewardNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGGrowthLevelTakeRewardReq$Type extends MessageType<GCGGrowthLevelTakeRewardReq> {
    constructor() {
        super("com.midnights.game.GCGGrowthLevelTakeRewardReq", [
            { no: 4, name: "level", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGGrowthLevelTakeRewardReq>): GCGGrowthLevelTakeRewardReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGGrowthLevelTakeRewardReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGGrowthLevelTakeRewardReq): GCGGrowthLevelTakeRewardReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 level */ 4:
                    message.level = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGGrowthLevelTakeRewardReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 level = 4; */
        if (message.level !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.level);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGGrowthLevelTakeRewardReq
 */
export const GCGGrowthLevelTakeRewardReq = new GCGGrowthLevelTakeRewardReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGGrowthLevelTakeRewardRsp$Type extends MessageType<GCGGrowthLevelTakeRewardRsp> {
    constructor() {
        super("com.midnights.game.GCGGrowthLevelTakeRewardRsp", [
            { no: 1, name: "level", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "retcode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGGrowthLevelTakeRewardRsp>): GCGGrowthLevelTakeRewardRsp {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGGrowthLevelTakeRewardRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGGrowthLevelTakeRewardRsp): GCGGrowthLevelTakeRewardRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 level */ 1:
                    message.level = reader.uint32();
                    break;
                case /* optional int32 retcode */ 13:
                    message.retcode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGGrowthLevelTakeRewardRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 level = 1; */
        if (message.level !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.level);
        /* optional int32 retcode = 13; */
        if (message.retcode !== undefined)
            writer.tag(13, WireType.Varint).int32(message.retcode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGGrowthLevelTakeRewardRsp
 */
export const GCGGrowthLevelTakeRewardRsp = new GCGGrowthLevelTakeRewardRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGInviteGuestBattleReq$Type extends MessageType<GCGInviteGuestBattleReq> {
    constructor() {
        super("com.midnights.game.GCGInviteGuestBattleReq", [
            { no: 11, name: "uid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGInviteGuestBattleReq>): GCGInviteGuestBattleReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGInviteGuestBattleReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGInviteGuestBattleReq): GCGInviteGuestBattleReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 uid */ 11:
                    message.uid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGInviteGuestBattleReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 uid = 11; */
        if (message.uid !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.uid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGInviteGuestBattleReq
 */
export const GCGInviteGuestBattleReq = new GCGInviteGuestBattleReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGInviteGuestBattleRsp$Type extends MessageType<GCGInviteGuestBattleRsp> {
    constructor() {
        super("com.midnights.game.GCGInviteGuestBattleRsp", [
            { no: 3, name: "retcode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "uid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGInviteGuestBattleRsp>): GCGInviteGuestBattleRsp {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGInviteGuestBattleRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGInviteGuestBattleRsp): GCGInviteGuestBattleRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 retcode */ 3:
                    message.retcode = reader.int32();
                    break;
                case /* optional uint32 uid */ 11:
                    message.uid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGInviteGuestBattleRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 retcode = 3; */
        if (message.retcode !== undefined)
            writer.tag(3, WireType.Varint).int32(message.retcode);
        /* optional uint32 uid = 11; */
        if (message.uid !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.uid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGInviteGuestBattleRsp
 */
export const GCGInviteGuestBattleRsp = new GCGInviteGuestBattleRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGInviteBattleNotify$Type extends MessageType<GCGInviteBattleNotify> {
    constructor() {
        super("com.midnights.game.GCGInviteBattleNotify", []);
    }
    create(value?: PartialMessage<GCGInviteBattleNotify>): GCGInviteBattleNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGInviteBattleNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGInviteBattleNotify): GCGInviteBattleNotify {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GCGInviteBattleNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGInviteBattleNotify
 */
export const GCGInviteBattleNotify = new GCGInviteBattleNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGApplyInviteBattleReq$Type extends MessageType<GCGApplyInviteBattleReq> {
    constructor() {
        super("com.midnights.game.GCGApplyInviteBattleReq", [
            { no: 9, name: "is_agree", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GCGApplyInviteBattleReq>): GCGApplyInviteBattleReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGApplyInviteBattleReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGApplyInviteBattleReq): GCGApplyInviteBattleReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool is_agree */ 9:
                    message.isAgree = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGApplyInviteBattleReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool is_agree = 9; */
        if (message.isAgree !== undefined)
            writer.tag(9, WireType.Varint).bool(message.isAgree);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGApplyInviteBattleReq
 */
export const GCGApplyInviteBattleReq = new GCGApplyInviteBattleReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGApplyInviteBattleRsp$Type extends MessageType<GCGApplyInviteBattleRsp> {
    constructor() {
        super("com.midnights.game.GCGApplyInviteBattleRsp", [
            { no: 5, name: "retcode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGApplyInviteBattleRsp>): GCGApplyInviteBattleRsp {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGApplyInviteBattleRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGApplyInviteBattleRsp): GCGApplyInviteBattleRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 retcode */ 5:
                    message.retcode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGApplyInviteBattleRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 retcode = 5; */
        if (message.retcode !== undefined)
            writer.tag(5, WireType.Varint).int32(message.retcode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGApplyInviteBattleRsp
 */
export const GCGApplyInviteBattleRsp = new GCGApplyInviteBattleRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGApplyInviteBattleNotify$Type extends MessageType<GCGApplyInviteBattleNotify> {
    constructor() {
        super("com.midnights.game.GCGApplyInviteBattleNotify", [
            { no: 14, name: "is_agree", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "retcode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGApplyInviteBattleNotify>): GCGApplyInviteBattleNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGApplyInviteBattleNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGApplyInviteBattleNotify): GCGApplyInviteBattleNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool is_agree */ 14:
                    message.isAgree = reader.bool();
                    break;
                case /* optional int32 retcode */ 6:
                    message.retcode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGApplyInviteBattleNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool is_agree = 14; */
        if (message.isAgree !== undefined)
            writer.tag(14, WireType.Varint).bool(message.isAgree);
        /* optional int32 retcode = 6; */
        if (message.retcode !== undefined)
            writer.tag(6, WireType.Varint).int32(message.retcode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGApplyInviteBattleNotify
 */
export const GCGApplyInviteBattleNotify = new GCGApplyInviteBattleNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGSettleNotify$Type extends MessageType<GCGSettleNotify> {
    constructor() {
        super("com.midnights.game.GCGSettleNotify", [
            { no: 7, name: "game_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "business_type", kind: "enum", opt: true, T: () => ["com.midnights.game.GCGGameBusinessType", GCGGameBusinessType] },
            { no: 13, name: "is_win", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "reward_item_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ItemParam },
            { no: 6, name: "finished_challenge_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "reason", kind: "enum", opt: true, T: () => ["com.midnights.game.GCGEndReason", GCGEndReason] }
        ]);
    }
    create(value?: PartialMessage<GCGSettleNotify>): GCGSettleNotify {
        const message = { rewardItemList: [], finishedChallengeIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGSettleNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGSettleNotify): GCGSettleNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 game_id */ 7:
                    message.gameId = reader.uint32();
                    break;
                case /* optional com.midnights.game.GCGGameBusinessType business_type */ 2:
                    message.businessType = reader.int32();
                    break;
                case /* optional bool is_win */ 13:
                    message.isWin = reader.bool();
                    break;
                case /* repeated com.midnights.game.ItemParam reward_item_list */ 9:
                    message.rewardItemList.push(ItemParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 finished_challenge_id_list */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.finishedChallengeIdList.push(reader.uint32());
                    else
                        message.finishedChallengeIdList.push(reader.uint32());
                    break;
                case /* optional com.midnights.game.GCGEndReason reason */ 3:
                    message.reason = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGSettleNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 game_id = 7; */
        if (message.gameId !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.gameId);
        /* optional com.midnights.game.GCGGameBusinessType business_type = 2; */
        if (message.businessType !== undefined)
            writer.tag(2, WireType.Varint).int32(message.businessType);
        /* optional bool is_win = 13; */
        if (message.isWin !== undefined)
            writer.tag(13, WireType.Varint).bool(message.isWin);
        /* repeated com.midnights.game.ItemParam reward_item_list = 9; */
        for (let i = 0; i < message.rewardItemList.length; i++)
            ItemParam.internalBinaryWrite(message.rewardItemList[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 finished_challenge_id_list = 6; */
        if (message.finishedChallengeIdList.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.finishedChallengeIdList.length; i++)
                writer.uint32(message.finishedChallengeIdList[i]);
            writer.join();
        }
        /* optional com.midnights.game.GCGEndReason reason = 3; */
        if (message.reason !== undefined)
            writer.tag(3, WireType.Varint).int32(message.reason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGSettleNotify
 */
export const GCGSettleNotify = new GCGSettleNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGResourceStateNotify$Type extends MessageType<GCGResourceStateNotify> {
    constructor() {
        super("com.midnights.game.GCGResourceStateNotify", [
            { no: 5, name: "is_complete", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GCGResourceStateNotify>): GCGResourceStateNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGResourceStateNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGResourceStateNotify): GCGResourceStateNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool is_complete */ 5:
                    message.isComplete = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGResourceStateNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool is_complete = 5; */
        if (message.isComplete !== undefined)
            writer.tag(5, WireType.Varint).bool(message.isComplete);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGResourceStateNotify
 */
export const GCGResourceStateNotify = new GCGResourceStateNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGClientSettleReq$Type extends MessageType<GCGClientSettleReq> {
    constructor() {
        super("com.midnights.game.GCGClientSettleReq", []);
    }
    create(value?: PartialMessage<GCGClientSettleReq>): GCGClientSettleReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGClientSettleReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGClientSettleReq): GCGClientSettleReq {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GCGClientSettleReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGClientSettleReq
 */
export const GCGClientSettleReq = new GCGClientSettleReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGClientSettleRsp$Type extends MessageType<GCGClientSettleRsp> {
    constructor() {
        super("com.midnights.game.GCGClientSettleRsp", [
            { no: 4, name: "close_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "retcode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGClientSettleRsp>): GCGClientSettleRsp {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGClientSettleRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGClientSettleRsp): GCGClientSettleRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 close_time */ 4:
                    message.closeTime = reader.uint32();
                    break;
                case /* optional int32 retcode */ 1:
                    message.retcode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGClientSettleRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 close_time = 4; */
        if (message.closeTime !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.closeTime);
        /* optional int32 retcode = 1; */
        if (message.retcode !== undefined)
            writer.tag(1, WireType.Varint).int32(message.retcode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGClientSettleRsp
 */
export const GCGClientSettleRsp = new GCGClientSettleRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGSettleOptionReq$Type extends MessageType<GCGSettleOptionReq> {
    constructor() {
        super("com.midnights.game.GCGSettleOptionReq", [
            { no: 5, name: "option", kind: "enum", opt: true, T: () => ["com.midnights.game.GCGSettleOption", GCGSettleOption] }
        ]);
    }
    create(value?: PartialMessage<GCGSettleOptionReq>): GCGSettleOptionReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGSettleOptionReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGSettleOptionReq): GCGSettleOptionReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.GCGSettleOption option */ 5:
                    message.option = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGSettleOptionReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.GCGSettleOption option = 5; */
        if (message.option !== undefined)
            writer.tag(5, WireType.Varint).int32(message.option);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGSettleOptionReq
 */
export const GCGSettleOptionReq = new GCGSettleOptionReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGSettleOptionRsp$Type extends MessageType<GCGSettleOptionRsp> {
    constructor() {
        super("com.midnights.game.GCGSettleOptionRsp", [
            { no: 13, name: "option", kind: "enum", opt: true, T: () => ["com.midnights.game.GCGSettleOption", GCGSettleOption] },
            { no: 14, name: "retcode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGSettleOptionRsp>): GCGSettleOptionRsp {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGSettleOptionRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGSettleOptionRsp): GCGSettleOptionRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.GCGSettleOption option */ 13:
                    message.option = reader.int32();
                    break;
                case /* optional int32 retcode */ 14:
                    message.retcode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGSettleOptionRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.GCGSettleOption option = 13; */
        if (message.option !== undefined)
            writer.tag(13, WireType.Varint).int32(message.option);
        /* optional int32 retcode = 14; */
        if (message.retcode !== undefined)
            writer.tag(14, WireType.Varint).int32(message.retcode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGSettleOptionRsp
 */
export const GCGSettleOptionRsp = new GCGSettleOptionRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGBasicDataNotify$Type extends MessageType<GCGBasicDataNotify> {
    constructor() {
        super("com.midnights.game.GCGBasicDataNotify", [
            { no: 9, name: "level", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "exp", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "level_reward_taken_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGBasicDataNotify>): GCGBasicDataNotify {
        const message = { levelRewardTakenList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGBasicDataNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGBasicDataNotify): GCGBasicDataNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 level */ 9:
                    message.level = reader.uint32();
                    break;
                case /* optional uint32 exp */ 4:
                    message.exp = reader.uint32();
                    break;
                case /* repeated uint32 level_reward_taken_list */ 12:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.levelRewardTakenList.push(reader.uint32());
                    else
                        message.levelRewardTakenList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGBasicDataNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 level = 9; */
        if (message.level !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.level);
        /* optional uint32 exp = 4; */
        if (message.exp !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.exp);
        /* repeated uint32 level_reward_taken_list = 12; */
        if (message.levelRewardTakenList.length) {
            writer.tag(12, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.levelRewardTakenList.length; i++)
                writer.uint32(message.levelRewardTakenList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGBasicDataNotify
 */
export const GCGBasicDataNotify = new GCGBasicDataNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGTavernNpcInfo$Type extends MessageType<GCGTavernNpcInfo> {
    constructor() {
        super("com.midnights.game.GCGTavernNpcInfo", [
            { no: 6, name: "id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "level_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "scene_point_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGTavernNpcInfo>): GCGTavernNpcInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGTavernNpcInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGTavernNpcInfo): GCGTavernNpcInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 id */ 6:
                    message.id = reader.uint32();
                    break;
                case /* optional uint32 level_id */ 10:
                    message.levelId = reader.uint32();
                    break;
                case /* optional uint32 scene_point_id */ 3:
                    message.scenePointId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGTavernNpcInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 id = 6; */
        if (message.id !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.id);
        /* optional uint32 level_id = 10; */
        if (message.levelId !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.levelId);
        /* optional uint32 scene_point_id = 3; */
        if (message.scenePointId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.scenePointId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGTavernNpcInfo
 */
export const GCGTavernNpcInfo = new GCGTavernNpcInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGTavernNpcInfoNotify$Type extends MessageType<GCGTavernNpcInfoNotify> {
    constructor() {
        super("com.midnights.game.GCGTavernNpcInfoNotify", [
            { no: 1, name: "week_npc_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GCGTavernNpcInfo },
            { no: 5, name: "character_npc", kind: "message", T: () => GCGTavernNpcInfo },
            { no: 15, name: "const_npc_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GCGTavernNpcInfo }
        ]);
    }
    create(value?: PartialMessage<GCGTavernNpcInfoNotify>): GCGTavernNpcInfoNotify {
        const message = { weekNpcList: [], constNpcList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGTavernNpcInfoNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGTavernNpcInfoNotify): GCGTavernNpcInfoNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated com.midnights.game.GCGTavernNpcInfo week_npc_list */ 1:
                    message.weekNpcList.push(GCGTavernNpcInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional com.midnights.game.GCGTavernNpcInfo character_npc */ 5:
                    message.characterNpc = GCGTavernNpcInfo.internalBinaryRead(reader, reader.uint32(), options, message.characterNpc);
                    break;
                case /* repeated com.midnights.game.GCGTavernNpcInfo const_npc_list */ 15:
                    message.constNpcList.push(GCGTavernNpcInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGTavernNpcInfoNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated com.midnights.game.GCGTavernNpcInfo week_npc_list = 1; */
        for (let i = 0; i < message.weekNpcList.length; i++)
            GCGTavernNpcInfo.internalBinaryWrite(message.weekNpcList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional com.midnights.game.GCGTavernNpcInfo character_npc = 5; */
        if (message.characterNpc)
            GCGTavernNpcInfo.internalBinaryWrite(message.characterNpc, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated com.midnights.game.GCGTavernNpcInfo const_npc_list = 15; */
        for (let i = 0; i < message.constNpcList.length; i++)
            GCGTavernNpcInfo.internalBinaryWrite(message.constNpcList[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGTavernNpcInfoNotify
 */
export const GCGTavernNpcInfoNotify = new GCGTavernNpcInfoNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGStartChallengeReq$Type extends MessageType<GCGStartChallengeReq> {
    constructor() {
        super("com.midnights.game.GCGStartChallengeReq", [
            { no: 5, name: "level_type", kind: "enum", opt: true, T: () => ["com.midnights.game.GCGLevelType", GCGLevelType] },
            { no: 13, name: "config_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "level_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGStartChallengeReq>): GCGStartChallengeReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGStartChallengeReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGStartChallengeReq): GCGStartChallengeReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.GCGLevelType level_type */ 5:
                    message.levelType = reader.int32();
                    break;
                case /* optional uint32 config_id */ 13:
                    message.configId = reader.uint32();
                    break;
                case /* optional uint32 level_id */ 12:
                    message.levelId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGStartChallengeReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.GCGLevelType level_type = 5; */
        if (message.levelType !== undefined)
            writer.tag(5, WireType.Varint).int32(message.levelType);
        /* optional uint32 config_id = 13; */
        if (message.configId !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.configId);
        /* optional uint32 level_id = 12; */
        if (message.levelId !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.levelId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGStartChallengeReq
 */
export const GCGStartChallengeReq = new GCGStartChallengeReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGStartChallengeRsp$Type extends MessageType<GCGStartChallengeRsp> {
    constructor() {
        super("com.midnights.game.GCGStartChallengeRsp", [
            { no: 12, name: "level_type", kind: "enum", opt: true, T: () => ["com.midnights.game.GCGLevelType", GCGLevelType] },
            { no: 15, name: "retcode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "config_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "level_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGStartChallengeRsp>): GCGStartChallengeRsp {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGStartChallengeRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGStartChallengeRsp): GCGStartChallengeRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.GCGLevelType level_type */ 12:
                    message.levelType = reader.int32();
                    break;
                case /* optional int32 retcode */ 15:
                    message.retcode = reader.int32();
                    break;
                case /* optional uint32 config_id */ 6:
                    message.configId = reader.uint32();
                    break;
                case /* optional uint32 level_id */ 1:
                    message.levelId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGStartChallengeRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.GCGLevelType level_type = 12; */
        if (message.levelType !== undefined)
            writer.tag(12, WireType.Varint).int32(message.levelType);
        /* optional int32 retcode = 15; */
        if (message.retcode !== undefined)
            writer.tag(15, WireType.Varint).int32(message.retcode);
        /* optional uint32 config_id = 6; */
        if (message.configId !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.configId);
        /* optional uint32 level_id = 1; */
        if (message.levelId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.levelId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGStartChallengeRsp
 */
export const GCGStartChallengeRsp = new GCGStartChallengeRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGWeekChallengeInfo$Type extends MessageType<GCGWeekChallengeInfo> {
    constructor() {
        super("com.midnights.game.GCGWeekChallengeInfo", [
            { no: 4, name: "npc_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "is_finished", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 1, name: "unlock_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGWeekChallengeInfo>): GCGWeekChallengeInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGWeekChallengeInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGWeekChallengeInfo): GCGWeekChallengeInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 npc_id */ 4:
                    message.npcId = reader.uint32();
                    break;
                case /* optional bool is_finished */ 7:
                    message.isFinished = reader.bool();
                    break;
                case /* optional uint32 unlock_time */ 1:
                    message.unlockTime = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGWeekChallengeInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 npc_id = 4; */
        if (message.npcId !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.npcId);
        /* optional bool is_finished = 7; */
        if (message.isFinished !== undefined)
            writer.tag(7, WireType.Varint).bool(message.isFinished);
        /* optional uint32 unlock_time = 1; */
        if (message.unlockTime !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.unlockTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGWeekChallengeInfo
 */
export const GCGWeekChallengeInfo = new GCGWeekChallengeInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGWeekChallengeInfoNotify$Type extends MessageType<GCGWeekChallengeInfoNotify> {
    constructor() {
        super("com.midnights.game.GCGWeekChallengeInfoNotify", [
            { no: 15, name: "challenge_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GCGWeekChallengeInfo },
            { no: 7, name: "next_refresh_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGWeekChallengeInfoNotify>): GCGWeekChallengeInfoNotify {
        const message = { challengeInfoList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGWeekChallengeInfoNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGWeekChallengeInfoNotify): GCGWeekChallengeInfoNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated com.midnights.game.GCGWeekChallengeInfo challenge_info_list */ 15:
                    message.challengeInfoList.push(GCGWeekChallengeInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 next_refresh_time */ 7:
                    message.nextRefreshTime = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGWeekChallengeInfoNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated com.midnights.game.GCGWeekChallengeInfo challenge_info_list = 15; */
        for (let i = 0; i < message.challengeInfoList.length; i++)
            GCGWeekChallengeInfo.internalBinaryWrite(message.challengeInfoList[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 next_refresh_time = 7; */
        if (message.nextRefreshTime !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.nextRefreshTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGWeekChallengeInfoNotify
 */
export const GCGWeekChallengeInfoNotify = new GCGWeekChallengeInfoNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGLevelData$Type extends MessageType<GCGLevelData> {
    constructor() {
        super("com.midnights.game.GCGLevelData", [
            { no: 10, name: "finished_challenge_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "level_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGLevelData>): GCGLevelData {
        const message = { finishedChallengeIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGLevelData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGLevelData): GCGLevelData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 finished_challenge_id_list */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.finishedChallengeIdList.push(reader.uint32());
                    else
                        message.finishedChallengeIdList.push(reader.uint32());
                    break;
                case /* optional uint32 level_id */ 9:
                    message.levelId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGLevelData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 finished_challenge_id_list = 10; */
        if (message.finishedChallengeIdList.length) {
            writer.tag(10, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.finishedChallengeIdList.length; i++)
                writer.uint32(message.finishedChallengeIdList[i]);
            writer.join();
        }
        /* optional uint32 level_id = 9; */
        if (message.levelId !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.levelId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGLevelData
 */
export const GCGLevelData = new GCGLevelData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGBossChallengeData$Type extends MessageType<GCGBossChallengeData> {
    constructor() {
        super("com.midnights.game.GCGBossChallengeData", [
            { no: 9, name: "id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "unlock_level_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGBossChallengeData>): GCGBossChallengeData {
        const message = { unlockLevelIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGBossChallengeData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGBossChallengeData): GCGBossChallengeData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 id */ 9:
                    message.id = reader.uint32();
                    break;
                case /* repeated uint32 unlock_level_id_list */ 14:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unlockLevelIdList.push(reader.uint32());
                    else
                        message.unlockLevelIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGBossChallengeData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 id = 9; */
        if (message.id !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.id);
        /* repeated uint32 unlock_level_id_list = 14; */
        if (message.unlockLevelIdList.length) {
            writer.tag(14, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.unlockLevelIdList.length; i++)
                writer.uint32(message.unlockLevelIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGBossChallengeData
 */
export const GCGBossChallengeData = new GCGBossChallengeData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGLevelChallengeNotify$Type extends MessageType<GCGLevelChallengeNotify> {
    constructor() {
        super("com.midnights.game.GCGLevelChallengeNotify", [
            { no: 3, name: "unlock_boss_challenge_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GCGBossChallengeData },
            { no: 8, name: "unlock_world_challenge_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "level_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GCGLevelData }
        ]);
    }
    create(value?: PartialMessage<GCGLevelChallengeNotify>): GCGLevelChallengeNotify {
        const message = { unlockBossChallengeList: [], unlockWorldChallengeList: [], levelList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGLevelChallengeNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGLevelChallengeNotify): GCGLevelChallengeNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated com.midnights.game.GCGBossChallengeData unlock_boss_challenge_list */ 3:
                    message.unlockBossChallengeList.push(GCGBossChallengeData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 unlock_world_challenge_list */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unlockWorldChallengeList.push(reader.uint32());
                    else
                        message.unlockWorldChallengeList.push(reader.uint32());
                    break;
                case /* repeated com.midnights.game.GCGLevelData level_list */ 10:
                    message.levelList.push(GCGLevelData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGLevelChallengeNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated com.midnights.game.GCGBossChallengeData unlock_boss_challenge_list = 3; */
        for (let i = 0; i < message.unlockBossChallengeList.length; i++)
            GCGBossChallengeData.internalBinaryWrite(message.unlockBossChallengeList[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 unlock_world_challenge_list = 8; */
        if (message.unlockWorldChallengeList.length) {
            writer.tag(8, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.unlockWorldChallengeList.length; i++)
                writer.uint32(message.unlockWorldChallengeList[i]);
            writer.join();
        }
        /* repeated com.midnights.game.GCGLevelData level_list = 10; */
        for (let i = 0; i < message.levelList.length; i++)
            GCGLevelData.internalBinaryWrite(message.levelList[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGLevelChallengeNotify
 */
export const GCGLevelChallengeNotify = new GCGLevelChallengeNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGLevelChallengeFinishNotify$Type extends MessageType<GCGLevelChallengeFinishNotify> {
    constructor() {
        super("com.midnights.game.GCGLevelChallengeFinishNotify", [
            { no: 10, name: "finished_challenge_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "level_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGLevelChallengeFinishNotify>): GCGLevelChallengeFinishNotify {
        const message = { finishedChallengeIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGLevelChallengeFinishNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGLevelChallengeFinishNotify): GCGLevelChallengeFinishNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 finished_challenge_id_list */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.finishedChallengeIdList.push(reader.uint32());
                    else
                        message.finishedChallengeIdList.push(reader.uint32());
                    break;
                case /* optional uint32 level_id */ 15:
                    message.levelId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGLevelChallengeFinishNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 finished_challenge_id_list = 10; */
        if (message.finishedChallengeIdList.length) {
            writer.tag(10, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.finishedChallengeIdList.length; i++)
                writer.uint32(message.finishedChallengeIdList[i]);
            writer.join();
        }
        /* optional uint32 level_id = 15; */
        if (message.levelId !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.levelId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGLevelChallengeFinishNotify
 */
export const GCGLevelChallengeFinishNotify = new GCGLevelChallengeFinishNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGWorldChallengeUnlockNotify$Type extends MessageType<GCGWorldChallengeUnlockNotify> {
    constructor() {
        super("com.midnights.game.GCGWorldChallengeUnlockNotify", [
            { no: 8, name: "unlock_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GCGWorldChallengeUnlockNotify>): GCGWorldChallengeUnlockNotify {
        const message = { unlockIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGWorldChallengeUnlockNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGWorldChallengeUnlockNotify): GCGWorldChallengeUnlockNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 unlock_id_list */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unlockIdList.push(reader.uint32());
                    else
                        message.unlockIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGWorldChallengeUnlockNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 unlock_id_list = 8; */
        if (message.unlockIdList.length) {
            writer.tag(8, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.unlockIdList.length; i++)
                writer.uint32(message.unlockIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGWorldChallengeUnlockNotify
 */
export const GCGWorldChallengeUnlockNotify = new GCGWorldChallengeUnlockNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GCGBossChallengeUpdateNotify$Type extends MessageType<GCGBossChallengeUpdateNotify> {
    constructor() {
        super("com.midnights.game.GCGBossChallengeUpdateNotify", [
            { no: 11, name: "boss_challenge", kind: "message", T: () => GCGBossChallengeData }
        ]);
    }
    create(value?: PartialMessage<GCGBossChallengeUpdateNotify>): GCGBossChallengeUpdateNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GCGBossChallengeUpdateNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GCGBossChallengeUpdateNotify): GCGBossChallengeUpdateNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.GCGBossChallengeData boss_challenge */ 11:
                    message.bossChallenge = GCGBossChallengeData.internalBinaryRead(reader, reader.uint32(), options, message.bossChallenge);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GCGBossChallengeUpdateNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.GCGBossChallengeData boss_challenge = 11; */
        if (message.bossChallenge)
            GCGBossChallengeData.internalBinaryWrite(message.bossChallenge, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.GCGBossChallengeUpdateNotify
 */
export const GCGBossChallengeUpdateNotify = new GCGBossChallengeUpdateNotify$Type();
