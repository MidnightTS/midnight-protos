// @generated by protobuf-ts 2.8.1 with parameter output_typescript
// @generated from protobuf file "cmd_fight.proto" (package "com.midnights.game", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { ShapeBox } from "./define";
import { ShapeSphere } from "./define";
import { ServerBuff } from "./define";
import { AbilitySyncStateInfo } from "./define";
import { MassiveEntityState } from "./define";
import { ServerMassiveEntity } from "./define";
import { ClientMassiveEntity } from "./define";
import { EntityRendererChangedInfo } from "./define";
import { EntityAuthorityInfo } from "./define";
import { AnimatorParameterValueInfo } from "./define";
import { Vector } from "./define";
/**
 * @generated from protobuf message com.midnights.game.HitCollision
 */
export interface HitCollision {
    /**
     * @generated from protobuf field: optional com.midnights.game.HitColliderType hit_collider_type = 8;
     */
    hitColliderType?: HitColliderType;
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector hit_point = 7;
     */
    hitPoint?: Vector;
    /**
     * @generated from protobuf field: optional float attackee_hit_force_angle = 2;
     */
    attackeeHitForceAngle?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector hit_dir = 13;
     */
    hitDir?: Vector;
    /**
     * @generated from protobuf field: optional float attackee_hit_entity_angle = 15;
     */
    attackeeHitEntityAngle?: number;
    /**
     * @generated from protobuf field: optional int32 hit_box_index = 4;
     */
    hitBoxIndex?: number;
}
/**
 * @generated from protobuf message com.midnights.game.AttackHitEffectResult
 */
export interface AttackHitEffectResult {
    /**
     * @generated from protobuf field: optional float hit_halt_time_scale = 8;
     */
    hitHaltTimeScale?: number;
    /**
     * @generated from protobuf field: optional uint32 original_hit_eff_level = 12;
     */
    originalHitEffLevel?: number;
    /**
     * @generated from protobuf field: optional float air_strength = 15;
     */
    airStrength?: number;
    /**
     * @generated from protobuf field: optional uint32 hit_eff_level = 2;
     */
    hitEffLevel?: number;
    /**
     * @generated from protobuf field: optional float hit_halt_time = 13;
     */
    hitHaltTime?: number;
    /**
     * @generated from protobuf field: optional float retreat_strength = 7;
     */
    retreatStrength?: number;
}
/**
 * @generated from protobuf message com.midnights.game.AbilityIdentifier
 */
export interface AbilityIdentifier {
    /**
     * @generated from protobuf field: optional uint32 modifier_owner_id = 2;
     */
    modifierOwnerId?: number;
    /**
     * @generated from protobuf field: optional uint32 instanced_modifier_id = 9;
     */
    instancedModifierId?: number;
    /**
     * @generated from protobuf field: optional uint32 instanced_ability_id = 10;
     */
    instancedAbilityId?: number;
    /**
     * @generated from protobuf field: optional bool is_serverbuff_modifier = 6;
     */
    isServerbuffModifier?: boolean;
    /**
     * @generated from protobuf field: optional uint32 ability_caster_id = 15;
     */
    abilityCasterId?: number;
    /**
     * @generated from protobuf field: optional int32 local_id = 3;
     */
    localId?: number;
}
/**
 * @generated from protobuf message com.midnights.game.AttackResult
 */
export interface AttackResult {
    /**
     * @generated from protobuf field: optional bool is_resist_text = 1858;
     */
    isResistText?: boolean;
    /**
     * @generated from protobuf field: optional uint32 create_count_sync_to_server = 1011;
     */
    createCountSyncToServer?: number;
    /**
     * @generated from protobuf field: optional uint32 amplify_reaction_type = 2005;
     */
    amplifyReactionType?: number;
    /**
     * @generated from protobuf field: optional uint32 endure_break = 7;
     */
    endureBreak?: number;
    /**
     * @generated from protobuf field: optional uint32 element_type = 5;
     */
    elementType?: number;
    /**
     * @generated from protobuf field: optional float element_durability_attenuation = 425;
     */
    elementDurabilityAttenuation?: number;
    /**
     * @generated from protobuf field: optional uint32 defense_id = 15;
     */
    defenseId?: number;
    /**
     * @generated from protobuf field: optional uint32 attack_timestamp_ms = 1188;
     */
    attackTimestampMs?: number;
    /**
     * @generated from protobuf field: optional uint32 bullet_fly_time_ms = 91;
     */
    bulletFlyTimeMs?: number;
    /**
     * @generated from protobuf field: optional bool is_crit = 13;
     */
    isCrit?: boolean;
    /**
     * @generated from protobuf field: optional float element_amplify_rate = 900;
     */
    elementAmplifyRate?: number;
    /**
     * @generated from protobuf field: optional uint32 attack_count = 1564;
     */
    attackCount?: number;
    /**
     * @generated from protobuf field: optional uint32 critical_rand = 1664;
     */
    criticalRand?: number;
    /**
     * @generated from protobuf field: optional uint32 hit_pos_type = 2;
     */
    hitPosType?: number;
    /**
     * @generated from protobuf field: optional string anim_event_id = 4;
     */
    animEventId?: string;
    /**
     * @generated from protobuf field: optional com.midnights.game.AttackHitEffectResult hit_eff_result = 8;
     */
    hitEffResult?: AttackHitEffectResult;
    /**
     * @generated from protobuf field: optional float damage_shield = 1202;
     */
    damageShield?: number;
    /**
     * @generated from protobuf field: optional float endure_delta = 430;
     */
    endureDelta?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector resolved_dir = 1;
     */
    resolvedDir?: Vector;
    /**
     * @generated from protobuf field: optional float damage = 6;
     */
    damage?: number;
    /**
     * @generated from protobuf field: optional uint32 addhurt_reaction_type = 1887;
     */
    addhurtReactionType?: number;
    /**
     * @generated from protobuf field: optional uint32 hashed_anim_event_id = 278;
     */
    hashedAnimEventId?: number;
    /**
     * @generated from protobuf field: optional bool use_gadget_damage_action = 1418;
     */
    useGadgetDamageAction?: boolean;
    /**
     * @generated from protobuf field: optional int32 hit_retreat_angle_compat = 9;
     */
    hitRetreatAngleCompat?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.AbilityIdentifier ability_identifier = 14;
     */
    abilityIdentifier?: AbilityIdentifier;
    /**
     * @generated from protobuf field: optional uint32 attacker_id = 11;
     */
    attackerId?: number;
    /**
     * @generated from protobuf field: optional bool mute_element_hurt = 1530;
     */
    muteElementHurt?: boolean;
    /**
     * @generated from protobuf field: optional uint32 target_type = 1366;
     */
    targetType?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.HitCollision hit_collision = 10;
     */
    hitCollision?: HitCollision;
    /**
     * @generated from protobuf field: optional uint32 gadget_damage_action_idx = 1110;
     */
    gadgetDamageActionIdx?: number;
}
/**
 * @generated from protobuf message com.midnights.game.EvtBeingHitInfo
 */
export interface EvtBeingHitInfo {
    /**
     * @generated from protobuf field: optional uint32 peer_id = 6;
     */
    peerId?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.AttackResult attack_result = 7;
     */
    attackResult?: AttackResult;
    /**
     * @generated from protobuf field: optional uint32 frame_num = 4;
     */
    frameNum?: number;
}
/**
 * @generated from protobuf message com.midnights.game.EvtHittingOtherInfo
 */
export interface EvtHittingOtherInfo {
    /**
     * @generated from protobuf field: optional com.midnights.game.AttackResult attack_result = 2;
     */
    attackResult?: AttackResult;
    /**
     * @generated from protobuf field: optional uint32 peer_id = 8;
     */
    peerId?: number;
}
/**
 * @generated from protobuf message com.midnights.game.EvtBeingHitNotify
 */
export interface EvtBeingHitNotify {
    /**
     * @generated from protobuf field: optional com.midnights.game.ForwardType forward_type = 6;
     */
    forwardType?: ForwardType;
    /**
     * @generated from protobuf field: optional com.midnights.game.EvtBeingHitInfo being_hit_info = 3;
     */
    beingHitInfo?: EvtBeingHitInfo;
}
/**
 * @generated from protobuf enum com.midnights.game.EvtBeingHitNotify.CmdId
 */
export enum EvtBeingHitNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 372;
     */
    CMD_ID = 372,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.EvtAnimatorParameterInfo
 */
export interface EvtAnimatorParameterInfo {
    /**
     * @generated from protobuf field: optional uint32 entity_id = 4;
     */
    entityId?: number;
    /**
     * @generated from protobuf field: optional bool is_server_cache = 5;
     */
    isServerCache?: boolean;
    /**
     * @generated from protobuf field: optional com.midnights.game.AnimatorParameterValueInfo value = 7;
     */
    value?: AnimatorParameterValueInfo;
    /**
     * @generated from protobuf field: optional int32 name_id = 15;
     */
    nameId?: number;
}
/**
 * @generated from protobuf message com.midnights.game.EvtAnimatorParameterNotify
 */
export interface EvtAnimatorParameterNotify {
    /**
     * @generated from protobuf field: optional com.midnights.game.EvtAnimatorParameterInfo animator_param_info = 12;
     */
    animatorParamInfo?: EvtAnimatorParameterInfo;
    /**
     * @generated from protobuf field: optional com.midnights.game.ForwardType forward_type = 14;
     */
    forwardType?: ForwardType;
}
/**
 * @generated from protobuf enum com.midnights.game.EvtAnimatorParameterNotify.CmdId
 */
export enum EvtAnimatorParameterNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 398;
     */
    CMD_ID = 398,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.AbilityArgument
 */
export interface AbilityArgument {
    /**
     * @generated from protobuf oneof: arg
     */
    arg: {
        oneofKind: "intArg";
        /**
         * @generated from protobuf field: uint32 int_arg = 5;
         */
        intArg: number;
    } | {
        oneofKind: "floatArg";
        /**
         * @generated from protobuf field: float float_arg = 15;
         */
        floatArg: number;
    } | {
        oneofKind: "strArg";
        /**
         * @generated from protobuf field: string str_arg = 11;
         */
        strArg: string;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message com.midnights.game.HostPlayerNotify
 */
export interface HostPlayerNotify {
    /**
     * @generated from protobuf field: optional uint32 host_peer_id = 13;
     */
    hostPeerId?: number;
    /**
     * @generated from protobuf field: optional uint32 host_uid = 10;
     */
    hostUid?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.HostPlayerNotify.CmdId
 */
export enum HostPlayerNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 312;
     */
    CMD_ID = 312,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.EvtDoSkillSuccNotify
 */
export interface EvtDoSkillSuccNotify {
    /**
     * @generated from protobuf field: optional uint32 caster_id = 13;
     */
    casterId?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.ForwardType forward_type = 10;
     */
    forwardType?: ForwardType;
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector forward = 15;
     */
    forward?: Vector;
    /**
     * @generated from protobuf field: optional uint32 skill_id = 7;
     */
    skillId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.EvtDoSkillSuccNotify.CmdId
 */
export enum EvtDoSkillSuccNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 335;
     */
    CMD_ID = 335,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.EvtCreateGadgetNotify
 */
export interface EvtCreateGadgetNotify {
    /**
     * @generated from protobuf field: optional bool is_async_load = 8;
     */
    isAsyncLoad?: boolean;
    /**
     * @generated from protobuf field: optional uint32 camp_type = 5;
     */
    campType?: number;
    /**
     * @generated from protobuf field: optional bool sight_group_with_owner = 10;
     */
    sightGroupWithOwner?: boolean;
    /**
     * @generated from protobuf field: repeated uint32 target_entity_id_list = 889;
     */
    targetEntityIdList: number[];
    /**
     * @generated from protobuf field: optional com.midnights.game.ForwardType forward_type = 12;
     */
    forwardType?: ForwardType;
    /**
     * @generated from protobuf field: optional uint32 entity_id = 2;
     */
    entityId?: number;
    /**
     * @generated from protobuf field: optional uint32 target_entity_id = 3;
     */
    targetEntityId?: number;
    /**
     * @generated from protobuf field: optional uint32 camp_id = 15;
     */
    campId?: number;
    /**
     * @generated from protobuf field: optional uint64 guid = 6;
     */
    guid?: bigint;
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector init_euler_angles = 13;
     */
    initEulerAngles?: Vector;
    /**
     * @generated from protobuf field: optional uint32 target_lock_point_index = 11;
     */
    targetLockPointIndex?: number;
    /**
     * @generated from protobuf field: repeated uint32 target_lock_point_index_list = 1920;
     */
    targetLockPointIndexList: number[];
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector init_pos = 4;
     */
    initPos?: Vector;
    /**
     * @generated from protobuf field: optional uint32 owner_entity_id = 9;
     */
    ownerEntityId?: number;
    /**
     * @generated from protobuf field: optional uint32 room_id = 7;
     */
    roomId?: number;
    /**
     * @generated from protobuf field: optional bool is_peer_id_from_player = 25;
     */
    isPeerIdFromPlayer?: boolean;
    /**
     * @generated from protobuf field: optional uint32 prop_owner_entity_id = 1;
     */
    propOwnerEntityId?: number;
    /**
     * @generated from protobuf field: optional bool is_true_life_time_by_owner = 379;
     */
    isTrueLifeTimeByOwner?: boolean;
    /**
     * @generated from protobuf field: optional uint32 config_id = 14;
     */
    configId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.EvtCreateGadgetNotify.CmdId
 */
export enum EvtCreateGadgetNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 307;
     */
    CMD_ID = 307,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.EvtDestroyGadgetNotify
 */
export interface EvtDestroyGadgetNotify {
    /**
     * @generated from protobuf field: optional com.midnights.game.ForwardType forward_type = 5;
     */
    forwardType?: ForwardType;
    /**
     * @generated from protobuf field: optional uint32 entity_id = 3;
     */
    entityId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.EvtDestroyGadgetNotify.CmdId
 */
export enum EvtDestroyGadgetNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 321;
     */
    CMD_ID = 321,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.EvtFaceToEntityNotify
 */
export interface EvtFaceToEntityNotify {
    /**
     * @generated from protobuf field: optional uint32 face_entity_id = 5;
     */
    faceEntityId?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.ForwardType forward_type = 9;
     */
    forwardType?: ForwardType;
    /**
     * @generated from protobuf field: optional uint32 entity_id = 1;
     */
    entityId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.EvtFaceToEntityNotify.CmdId
 */
export enum EvtFaceToEntityNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 303;
     */
    CMD_ID = 303,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.EvtFaceToDirInfo
 */
export interface EvtFaceToDirInfo {
    /**
     * @generated from protobuf field: optional uint32 entity_id = 12;
     */
    entityId?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector face_dir = 14;
     */
    faceDir?: Vector;
}
/**
 * @generated from protobuf message com.midnights.game.EvtFaceToDirNotify
 */
export interface EvtFaceToDirNotify {
    /**
     * @generated from protobuf field: optional com.midnights.game.ForwardType forward_type = 13;
     */
    forwardType?: ForwardType;
    /**
     * @generated from protobuf field: optional com.midnights.game.EvtFaceToDirInfo evt_face_to_dir_info = 5;
     */
    evtFaceToDirInfo?: EvtFaceToDirInfo;
}
/**
 * @generated from protobuf enum com.midnights.game.EvtFaceToDirNotify.CmdId
 */
export enum EvtFaceToDirNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 390;
     */
    CMD_ID = 390,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.EvtCostStaminaNotify
 */
export interface EvtCostStaminaNotify {
    /**
     * @generated from protobuf field: optional uint32 skill_id = 6;
     */
    skillId?: number;
    /**
     * @generated from protobuf field: optional float cost_stamina = 11;
     */
    costStamina?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.EvtCostStaminaNotify.CmdId
 */
export enum EvtCostStaminaNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 373;
     */
    CMD_ID = 373,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.EvtSetAttackTargetInfo
 */
export interface EvtSetAttackTargetInfo {
    /**
     * @generated from protobuf field: optional uint32 entity_id = 11;
     */
    entityId?: number;
    /**
     * @generated from protobuf field: optional uint32 select_point_index = 6;
     */
    selectPointIndex?: number;
    /**
     * @generated from protobuf field: optional uint32 attack_target_id = 7;
     */
    attackTargetId?: number;
}
/**
 * @generated from protobuf message com.midnights.game.EvtSetAttackTargetNotify
 */
export interface EvtSetAttackTargetNotify {
    /**
     * @generated from protobuf field: optional com.midnights.game.ForwardType forward_type = 1;
     */
    forwardType?: ForwardType;
    /**
     * @generated from protobuf field: optional com.midnights.game.EvtSetAttackTargetInfo evt_set_attack_target_info = 11;
     */
    evtSetAttackTargetInfo?: EvtSetAttackTargetInfo;
}
/**
 * @generated from protobuf enum com.midnights.game.EvtSetAttackTargetNotify.CmdId
 */
export enum EvtSetAttackTargetNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 399;
     */
    CMD_ID = 399,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.EvtAnimatorStateChangedInfo
 */
export interface EvtAnimatorStateChangedInfo {
    /**
     * @generated from protobuf field: optional int32 face_angle_compact = 14;
     */
    faceAngleCompact?: number;
    /**
     * @generated from protobuf field: optional uint32 to_state_hash = 5;
     */
    toStateHash?: number;
    /**
     * @generated from protobuf field: optional uint32 normalized_time_compact = 9;
     */
    normalizedTimeCompact?: number;
    /**
     * @generated from protobuf field: optional uint32 layer = 2;
     */
    layer?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector pos = 13;
     */
    pos?: Vector;
    /**
     * @generated from protobuf field: optional float fade_duration = 3;
     */
    fadeDuration?: number;
    /**
     * @generated from protobuf field: optional bool forceSync = 1;
     */
    forceSync?: boolean;
    /**
     * @generated from protobuf field: optional uint32 entity_id = 15;
     */
    entityId?: number;
    /**
     * @generated from protobuf field: optional bool handle_animator_state_immediately = 7;
     */
    handleAnimatorStateImmediately?: boolean;
}
/**
 * @generated from protobuf message com.midnights.game.EvtCompensatePosDiffInfo
 */
export interface EvtCompensatePosDiffInfo {
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector cur_pos = 14;
     */
    curPos?: Vector;
    /**
     * @generated from protobuf field: optional uint32 entity_id = 11;
     */
    entityId?: number;
    /**
     * @generated from protobuf field: optional int32 face_angle_compact = 10;
     */
    faceAngleCompact?: number;
    /**
     * @generated from protobuf field: optional uint32 cur_hash = 4;
     */
    curHash?: number;
    /**
     * @generated from protobuf field: optional uint32 normalized_time_compact = 3;
     */
    normalizedTimeCompact?: number;
}
/**
 * @generated from protobuf message com.midnights.game.EvtMonsterDoBlink
 */
export interface EvtMonsterDoBlink {
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector target_rot = 3;
     */
    targetRot?: Vector;
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector target_pos = 7;
     */
    targetPos?: Vector;
    /**
     * @generated from protobuf field: optional uint32 entity_id = 2;
     */
    entityId?: number;
}
/**
 * @generated from protobuf message com.midnights.game.EvtFixedRushMove
 */
export interface EvtFixedRushMove {
    /**
     * @generated from protobuf field: optional uint32 entity_id = 15;
     */
    entityId?: number;
    /**
     * @generated from protobuf field: optional float speed = 3;
     */
    speed?: number;
    /**
     * @generated from protobuf field: optional bool need_set_is_in_air = 7;
     */
    needSetIsInAir?: boolean;
    /**
     * @generated from protobuf field: repeated uint32 animator_state_id_list = 2;
     */
    animatorStateIdList: number[];
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector target_pos = 9;
     */
    targetPos?: Vector;
    /**
     * @generated from protobuf field: optional bool check_animator_state_on_exit_only = 6;
     */
    checkAnimatorStateOnExitOnly?: boolean;
    /**
     * @generated from protobuf field: optional string override_collider = 13;
     */
    overrideCollider?: string;
}
/**
 * @generated from protobuf message com.midnights.game.EvtSyncTransform
 */
export interface EvtSyncTransform {
    /**
     * @generated from protobuf field: optional uint32 entity_id = 15;
     */
    entityId?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector entity_pos = 6;
     */
    entityPos?: Vector;
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector entity_rot = 1;
     */
    entityRot?: Vector;
}
/**
 * @generated from protobuf message com.midnights.game.EvtLightCoreMove
 */
export interface EvtLightCoreMove {
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector target_pos = 15;
     */
    targetPos?: Vector;
    /**
     * @generated from protobuf field: optional float acelerate = 11;
     */
    acelerate?: number;
    /**
     * @generated from protobuf field: optional uint32 entity_id = 5;
     */
    entityId?: number;
    /**
     * @generated from protobuf field: optional float max_absorb_time = 10;
     */
    maxAbsorbTime?: number;
    /**
     * @generated from protobuf field: optional float speed = 14;
     */
    speed?: number;
}
/**
 * @generated from protobuf message com.midnights.game.EvtGrapplingHookMove
 */
export interface EvtGrapplingHookMove {
    /**
     * @generated from protobuf field: optional float acceleration = 1;
     */
    acceleration?: number;
    /**
     * @generated from protobuf field: repeated uint32 animator_state_id_list = 2;
     */
    animatorStateIdList: number[];
    /**
     * @generated from protobuf field: optional uint32 entity_id = 3;
     */
    entityId?: number;
    /**
     * @generated from protobuf field: optional bool need_set_is_in_air = 13;
     */
    needSetIsInAir?: boolean;
    /**
     * @generated from protobuf field: optional float speed = 12;
     */
    speed?: number;
    /**
     * @generated from protobuf field: optional float max_speed = 8;
     */
    maxSpeed?: number;
    /**
     * @generated from protobuf field: optional bool check_animator_state_on_exit_only = 11;
     */
    checkAnimatorStateOnExitOnly?: boolean;
    /**
     * @generated from protobuf field: optional string override_collider = 14;
     */
    overrideCollider?: string;
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector target_pos = 10;
     */
    targetPos?: Vector;
}
/**
 * @generated from protobuf message com.midnights.game.EvtAnimatorStateChangedNotify
 */
export interface EvtAnimatorStateChangedNotify {
    /**
     * @generated from protobuf field: optional com.midnights.game.ForwardType forward_type = 3;
     */
    forwardType?: ForwardType;
    /**
     * @generated from protobuf field: optional com.midnights.game.EvtAnimatorStateChangedInfo evt_animator_state_changed_info = 10;
     */
    evtAnimatorStateChangedInfo?: EvtAnimatorStateChangedInfo;
}
/**
 * @generated from protobuf enum com.midnights.game.EvtAnimatorStateChangedNotify.CmdId
 */
export enum EvtAnimatorStateChangedNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 331;
     */
    CMD_ID = 331,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.EvtRushMoveInfo
 */
export interface EvtRushMoveInfo {
    /**
     * @generated from protobuf field: optional int32 state_name_hash = 11;
     */
    stateNameHash?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector rush_to_pos = 9;
     */
    rushToPos?: Vector;
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector rush_attack_target_pos = 8;
     */
    rushAttackTargetPos?: Vector;
    /**
     * @generated from protobuf field: optional uint32 entity_id = 4;
     */
    entityId?: number;
    /**
     * @generated from protobuf field: optional float timeRange = 15;
     */
    timeRange?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector velocity = 6;
     */
    velocity?: Vector;
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector pos = 2;
     */
    pos?: Vector;
    /**
     * @generated from protobuf field: optional int32 face_angle_compact = 10;
     */
    faceAngleCompact?: number;
}
/**
 * @generated from protobuf message com.midnights.game.EvtMotionInfoDuringSteerAttack
 */
export interface EvtMotionInfoDuringSteerAttack {
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector face_dir = 4;
     */
    faceDir?: Vector;
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector velocity = 3;
     */
    velocity?: Vector;
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector pos = 1;
     */
    pos?: Vector;
    /**
     * @generated from protobuf field: optional uint32 entity_id = 6;
     */
    entityId?: number;
}
/**
 * @generated from protobuf message com.midnights.game.EvtCombatSteerMotionInfo
 */
export interface EvtCombatSteerMotionInfo {
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector pos = 12;
     */
    pos?: Vector;
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector velocity = 10;
     */
    velocity?: Vector;
    /**
     * @generated from protobuf field: optional uint32 entity_id = 4;
     */
    entityId?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector face_dir = 1;
     */
    faceDir?: Vector;
}
/**
 * @generated from protobuf message com.midnights.game.EvtCombatForceSetPosInfo
 */
export interface EvtCombatForceSetPosInfo {
    /**
     * @generated from protobuf field: optional uint32 ice_id = 9;
     */
    iceId?: number;
    /**
     * @generated from protobuf field: optional uint32 collider_entity_id = 10;
     */
    colliderEntityId?: number;
    /**
     * @generated from protobuf field: optional uint32 entity_id = 6;
     */
    entityId?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector target_pos = 1;
     */
    targetPos?: Vector;
}
/**
 * @generated from protobuf message com.midnights.game.EvtSyncEntityPositionInfo
 */
export interface EvtSyncEntityPositionInfo {
    /**
     * @generated from protobuf field: optional uint32 entity_id = 10;
     */
    entityId?: number;
    /**
     * @generated from protobuf field: optional uint32 normalized_time_compact = 13;
     */
    normalizedTimeCompact?: number;
    /**
     * @generated from protobuf field: optional uint32 state_hash = 8;
     */
    stateHash?: number;
    /**
     * @generated from protobuf field: optional int32 face_angle_compact = 7;
     */
    faceAngleCompact?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector pos = 15;
     */
    pos?: Vector;
}
/**
 * @generated from protobuf message com.midnights.game.EvtRushMoveNotify
 */
export interface EvtRushMoveNotify {
    /**
     * @generated from protobuf field: optional com.midnights.game.ForwardType forward_type = 1;
     */
    forwardType?: ForwardType;
    /**
     * @generated from protobuf field: optional com.midnights.game.EvtRushMoveInfo evt_rush_move_info = 15;
     */
    evtRushMoveInfo?: EvtRushMoveInfo;
}
/**
 * @generated from protobuf enum com.midnights.game.EvtRushMoveNotify.CmdId
 */
export enum EvtRushMoveNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 375;
     */
    CMD_ID = 375,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.EvtBulletHitNotify
 */
export interface EvtBulletHitNotify {
    /**
     * @generated from protobuf field: optional uint32 single_bullet_id = 8;
     */
    singleBulletId?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector hit_point = 15;
     */
    hitPoint?: Vector;
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector hit_normal = 11;
     */
    hitNormal?: Vector;
    /**
     * @generated from protobuf field: optional int32 hit_box_index = 9;
     */
    hitBoxIndex?: number;
    /**
     * @generated from protobuf field: optional uint32 hit_entity_id = 3;
     */
    hitEntityId?: number;
    /**
     * @generated from protobuf field: optional uint32 entity_id = 5;
     */
    entityId?: number;
    /**
     * @generated from protobuf field: optional uint32 forward_peer = 7;
     */
    forwardPeer?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.ForwardType forward_type = 2;
     */
    forwardType?: ForwardType;
    /**
     * @generated from protobuf field: optional com.midnights.game.HitColliderType hit_collider_type = 6;
     */
    hitColliderType?: HitColliderType;
}
/**
 * @generated from protobuf enum com.midnights.game.EvtBulletHitNotify.CmdId
 */
export enum EvtBulletHitNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 348;
     */
    CMD_ID = 348,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.EvtBulletDeactiveNotify
 */
export interface EvtBulletDeactiveNotify {
    /**
     * @generated from protobuf field: optional com.midnights.game.ForwardType forward_type = 6;
     */
    forwardType?: ForwardType;
    /**
     * @generated from protobuf field: optional uint32 entity_id = 9;
     */
    entityId?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector disappear_pos = 4;
     */
    disappearPos?: Vector;
}
/**
 * @generated from protobuf enum com.midnights.game.EvtBulletDeactiveNotify.CmdId
 */
export enum EvtBulletDeactiveNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 397;
     */
    CMD_ID = 397,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.EvtEntityStartDieEndNotify
 */
export interface EvtEntityStartDieEndNotify {
    /**
     * @generated from protobuf field: optional bool immediately = 15;
     */
    immediately?: boolean;
    /**
     * @generated from protobuf field: optional uint32 die_state_flag = 12;
     */
    dieStateFlag?: number;
    /**
     * @generated from protobuf field: optional uint32 entity_id = 8;
     */
    entityId?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.ForwardType forward_type = 11;
     */
    forwardType?: ForwardType;
}
/**
 * @generated from protobuf enum com.midnights.game.EvtEntityStartDieEndNotify.CmdId
 */
export enum EvtEntityStartDieEndNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 381;
     */
    CMD_ID = 381,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.EvtBulletMoveNotify
 */
export interface EvtBulletMoveNotify {
    /**
     * @generated from protobuf field: optional com.midnights.game.ForwardType forward_type = 14;
     */
    forwardType?: ForwardType;
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector cur_pos = 1;
     */
    curPos?: Vector;
    /**
     * @generated from protobuf field: optional uint32 entity_id = 11;
     */
    entityId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.EvtBulletMoveNotify.CmdId
 */
export enum EvtBulletMoveNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 365;
     */
    CMD_ID = 365,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.EvtAvatarEnterFocusNotify
 */
export interface EvtAvatarEnterFocusNotify {
    /**
     * @generated from protobuf field: optional uint32 entity_id = 1;
     */
    entityId?: number;
    /**
     * @generated from protobuf field: optional bool can_move = 10;
     */
    canMove?: boolean;
    /**
     * @generated from protobuf field: optional bool enter_holding_focus_shoot = 13;
     */
    enterHoldingFocusShoot?: boolean;
    /**
     * @generated from protobuf field: optional bool disable_aim_layer = 6;
     */
    disableAimLayer?: boolean;
    /**
     * @generated from protobuf field: optional bool use_auto_focus = 5;
     */
    useAutoFocus?: boolean;
    /**
     * @generated from protobuf field: optional bool fast_focus = 3;
     */
    fastFocus?: boolean;
    /**
     * @generated from protobuf field: optional bool show_cross_hair = 12;
     */
    showCrossHair?: boolean;
    /**
     * @generated from protobuf field: optional bool enter_normal_focus_shoot = 14;
     */
    enterNormalFocusShoot?: boolean;
    /**
     * @generated from protobuf field: optional com.midnights.game.ForwardType forward_type = 8;
     */
    forwardType?: ForwardType;
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector focus_forward = 7;
     */
    focusForward?: Vector;
    /**
     * @generated from protobuf field: optional bool disable_anim = 9;
     */
    disableAnim?: boolean;
    /**
     * @generated from protobuf field: optional bool use_focus_sticky = 15;
     */
    useFocusSticky?: boolean;
    /**
     * @generated from protobuf field: optional bool use_gyro = 11;
     */
    useGyro?: boolean;
}
/**
 * @generated from protobuf enum com.midnights.game.EvtAvatarEnterFocusNotify.CmdId
 */
export enum EvtAvatarEnterFocusNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 304;
     */
    CMD_ID = 304,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.EvtAvatarExitFocusNotify
 */
export interface EvtAvatarExitFocusNotify {
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector finish_forward = 12;
     */
    finishForward?: Vector;
    /**
     * @generated from protobuf field: optional com.midnights.game.ForwardType forward_type = 11;
     */
    forwardType?: ForwardType;
    /**
     * @generated from protobuf field: optional uint32 entity_id = 14;
     */
    entityId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.EvtAvatarExitFocusNotify.CmdId
 */
export enum EvtAvatarExitFocusNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 393;
     */
    CMD_ID = 393,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.EvtAvatarUpdateFocusNotify
 */
export interface EvtAvatarUpdateFocusNotify {
    /**
     * @generated from protobuf field: optional com.midnights.game.ForwardType forward_type = 7;
     */
    forwardType?: ForwardType;
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector focus_forward = 11;
     */
    focusForward?: Vector;
    /**
     * @generated from protobuf field: optional uint32 entity_id = 10;
     */
    entityId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.EvtAvatarUpdateFocusNotify.CmdId
 */
export enum EvtAvatarUpdateFocusNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 327;
     */
    CMD_ID = 327,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.AuthorityChange
 */
export interface AuthorityChange {
    /**
     * @generated from protobuf field: optional com.midnights.game.EntityAuthorityInfo entity_authority_info = 5;
     */
    entityAuthorityInfo?: EntityAuthorityInfo;
    /**
     * @generated from protobuf field: optional uint32 authority_peer_id = 3;
     */
    authorityPeerId?: number;
    /**
     * @generated from protobuf field: optional uint32 entity_id = 13;
     */
    entityId?: number;
}
/**
 * @generated from protobuf message com.midnights.game.EntityAuthorityChangeNotify
 */
export interface EntityAuthorityChangeNotify {
    /**
     * @generated from protobuf field: repeated com.midnights.game.AuthorityChange authority_change_list = 15;
     */
    authorityChangeList: AuthorityChange[];
}
/**
 * @generated from protobuf enum com.midnights.game.EntityAuthorityChangeNotify.CmdId
 */
export enum EntityAuthorityChangeNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 394;
     */
    CMD_ID = 394,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.AvatarBuffAddNotify
 */
export interface AvatarBuffAddNotify {
    /**
     * @generated from protobuf field: optional uint64 avatar_guid = 10;
     */
    avatarGuid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 buff_id = 6;
     */
    buffId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.AvatarBuffAddNotify.CmdId
 */
export enum AvatarBuffAddNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 388;
     */
    CMD_ID = 388,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.AvatarBuffDelNotify
 */
export interface AvatarBuffDelNotify {
    /**
     * @generated from protobuf field: optional uint64 avatar_guid = 10;
     */
    avatarGuid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 buff_id = 12;
     */
    buffId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.AvatarBuffDelNotify.CmdId
 */
export enum AvatarBuffDelNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 326;
     */
    CMD_ID = 326,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.MonsterAlertChangeNotify
 */
export interface MonsterAlertChangeNotify {
    /**
     * @generated from protobuf field: optional uint32 avatar_entity_id = 15;
     */
    avatarEntityId?: number;
    /**
     * @generated from protobuf field: repeated uint32 monster_entity_list = 5;
     */
    monsterEntityList: number[];
    /**
     * @generated from protobuf field: optional uint32 is_alert = 13;
     */
    isAlert?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.MonsterAlertChangeNotify.CmdId
 */
export enum MonsterAlertChangeNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 363;
     */
    CMD_ID = 363,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.MonsterForceAlertNotify
 */
export interface MonsterForceAlertNotify {
    /**
     * @generated from protobuf field: optional uint32 monster_entity_id = 13;
     */
    monsterEntityId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.MonsterForceAlertNotify.CmdId
 */
export enum MonsterForceAlertNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 395;
     */
    CMD_ID = 395,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.AvatarEnterElementViewNotify
 */
export interface AvatarEnterElementViewNotify {
    /**
     * @generated from protobuf field: optional bool is_triggerd = 3;
     */
    isTriggerd?: boolean;
    /**
     * @generated from protobuf field: optional uint32 avatar_entity_id = 12;
     */
    avatarEntityId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.AvatarEnterElementViewNotify.CmdId
 */
export enum AvatarEnterElementViewNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 334;
     */
    CMD_ID = 334,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.TriggerCreateGadgetToEquipPartNotify
 */
export interface TriggerCreateGadgetToEquipPartNotify {
    /**
     * @generated from protobuf field: optional uint32 gadget_id = 1;
     */
    gadgetId?: number;
    /**
     * @generated from protobuf field: optional uint32 entity_id = 13;
     */
    entityId?: number;
    /**
     * @generated from protobuf field: optional string equip_part = 14;
     */
    equipPart?: string;
    /**
     * @generated from protobuf field: optional uint32 gadget_entity_id = 10;
     */
    gadgetEntityId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.TriggerCreateGadgetToEquipPartNotify.CmdId
 */
export enum TriggerCreateGadgetToEquipPartNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 350;
     */
    CMD_ID = 350,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.EvtEntityRenderersChangedNotify
 */
export interface EvtEntityRenderersChangedNotify {
    /**
     * @generated from protobuf field: optional com.midnights.game.ForwardType forward_type = 8;
     */
    forwardType?: ForwardType;
    /**
     * @generated from protobuf field: optional bool is_server_cache = 3;
     */
    isServerCache?: boolean;
    /**
     * @generated from protobuf field: optional com.midnights.game.EntityRendererChangedInfo renderer_changed_info = 5;
     */
    rendererChangedInfo?: EntityRendererChangedInfo;
    /**
     * @generated from protobuf field: optional uint32 entity_id = 15;
     */
    entityId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.EvtEntityRenderersChangedNotify.CmdId
 */
export enum EvtEntityRenderersChangedNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 343;
     */
    CMD_ID = 343,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.AnimatorForceSetAirMoveNotify
 */
export interface AnimatorForceSetAirMoveNotify {
    /**
     * @generated from protobuf field: optional uint32 entity_id = 14;
     */
    entityId?: number;
    /**
     * @generated from protobuf field: optional bool in_air_move = 13;
     */
    inAirMove?: boolean;
    /**
     * @generated from protobuf field: optional com.midnights.game.ForwardType forward_type = 9;
     */
    forwardType?: ForwardType;
}
/**
 * @generated from protobuf enum com.midnights.game.AnimatorForceSetAirMoveNotify.CmdId
 */
export enum AnimatorForceSetAirMoveNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 374;
     */
    CMD_ID = 374,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.AiSkillCdInfo
 */
export interface AiSkillCdInfo {
    /**
     * @generated from protobuf field: map<uint32, uint32> skill_cd_map = 11;
     */
    skillCdMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<uint32, uint32> skill_group_cd_map = 6;
     */
    skillGroupCdMap: {
        [key: number]: number;
    };
}
/**
 * @generated from protobuf message com.midnights.game.EvtAiSyncSkillCdNotify
 */
export interface EvtAiSyncSkillCdNotify {
    /**
     * @generated from protobuf field: map<uint32, com.midnights.game.AiSkillCdInfo> ai_cd_map = 7;
     */
    aiCdMap: {
        [key: number]: AiSkillCdInfo;
    };
}
/**
 * @generated from protobuf enum com.midnights.game.EvtAiSyncSkillCdNotify.CmdId
 */
export enum EvtAiSyncSkillCdNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 376;
     */
    CMD_ID = 376,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.EvtBeingHitsCombineNotify
 */
export interface EvtBeingHitsCombineNotify {
    /**
     * @generated from protobuf field: optional com.midnights.game.ForwardType forward_type = 11;
     */
    forwardType?: ForwardType;
    /**
     * @generated from protobuf field: repeated com.midnights.game.EvtBeingHitInfo evt_being_hit_info_list = 7;
     */
    evtBeingHitInfoList: EvtBeingHitInfo[];
}
/**
 * @generated from protobuf enum com.midnights.game.EvtBeingHitsCombineNotify.CmdId
 */
export enum EvtBeingHitsCombineNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 346;
     */
    CMD_ID = 346,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.EvtAvatarSitDownNotify
 */
export interface EvtAvatarSitDownNotify {
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector position = 9;
     */
    position?: Vector;
    /**
     * @generated from protobuf field: optional uint32 entity_id = 4;
     */
    entityId?: number;
    /**
     * @generated from protobuf field: optional uint64 chair_id = 6;
     */
    chairId?: bigint;
}
/**
 * @generated from protobuf enum com.midnights.game.EvtAvatarSitDownNotify.CmdId
 */
export enum EvtAvatarSitDownNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 324;
     */
    CMD_ID = 324,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.EvtAvatarStandUpNotify
 */
export interface EvtAvatarStandUpNotify {
    /**
     * @generated from protobuf field: optional uint64 chair_id = 11;
     */
    chairId?: bigint;
    /**
     * @generated from protobuf field: optional int32 performID = 6;
     */
    performID?: number;
    /**
     * @generated from protobuf field: optional int32 direction = 1;
     */
    direction?: number;
    /**
     * @generated from protobuf field: optional uint32 entity_id = 9;
     */
    entityId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.EvtAvatarStandUpNotify.CmdId
 */
export enum EvtAvatarStandUpNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 356;
     */
    CMD_ID = 356,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.CreateMassiveEntityReq
 */
export interface CreateMassiveEntityReq {
    /**
     * @generated from protobuf field: repeated com.midnights.game.ClientMassiveEntity massive_entity_list = 1;
     */
    massiveEntityList: ClientMassiveEntity[];
}
/**
 * @generated from protobuf enum com.midnights.game.CreateMassiveEntityReq.CmdId
 */
export enum CreateMassiveEntityReq_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 342;
     */
    CMD_ID = 342,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.CreateMassiveEntityRsp
 */
export interface CreateMassiveEntityRsp {
    /**
     * @generated from protobuf field: optional int32 retcode = 1;
     */
    retcode?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.CreateMassiveEntityRsp.CmdId
 */
export enum CreateMassiveEntityRsp_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 330;
     */
    CMD_ID = 330,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.CreateMassiveEntityNotify
 */
export interface CreateMassiveEntityNotify {
    /**
     * @generated from protobuf field: repeated com.midnights.game.ServerMassiveEntity massive_entity_list = 15;
     */
    massiveEntityList: ServerMassiveEntity[];
}
/**
 * @generated from protobuf enum com.midnights.game.CreateMassiveEntityNotify.CmdId
 */
export enum CreateMassiveEntityNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 367;
     */
    CMD_ID = 367,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.DestroyMassiveEntityNotify
 */
export interface DestroyMassiveEntityNotify {
    /**
     * @generated from protobuf field: repeated com.midnights.game.ClientMassiveEntity massive_entity_list = 7;
     */
    massiveEntityList: ClientMassiveEntity[];
}
/**
 * @generated from protobuf enum com.midnights.game.DestroyMassiveEntityNotify.CmdId
 */
export enum DestroyMassiveEntityNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 358;
     */
    CMD_ID = 358,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.MassiveEntityStateChangedNotify
 */
export interface MassiveEntityStateChangedNotify {
    /**
     * @generated from protobuf field: repeated com.midnights.game.MassiveEntityState massive_entity_state_list = 4;
     */
    massiveEntityStateList: MassiveEntityState[];
}
/**
 * @generated from protobuf enum com.midnights.game.MassiveEntityStateChangedNotify.CmdId
 */
export enum MassiveEntityStateChangedNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 370;
     */
    CMD_ID = 370,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.TeamEntityInfo
 */
export interface TeamEntityInfo {
    /**
     * @generated from protobuf field: optional uint32 authority_peer_id = 10;
     */
    authorityPeerId?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.AbilitySyncStateInfo team_ability_info = 9;
     */
    teamAbilityInfo?: AbilitySyncStateInfo;
    /**
     * @generated from protobuf field: optional uint32 team_entity_id = 8;
     */
    teamEntityId?: number;
}
/**
 * @generated from protobuf message com.midnights.game.SyncTeamEntityNotify
 */
export interface SyncTeamEntityNotify {
    /**
     * @generated from protobuf field: optional uint32 scene_id = 13;
     */
    sceneId?: number;
    /**
     * @generated from protobuf field: repeated com.midnights.game.TeamEntityInfo team_entity_info_list = 15;
     */
    teamEntityInfoList: TeamEntityInfo[];
}
/**
 * @generated from protobuf enum com.midnights.game.SyncTeamEntityNotify.CmdId
 */
export enum SyncTeamEntityNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 317;
     */
    CMD_ID = 317,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.DelTeamEntityNotify
 */
export interface DelTeamEntityNotify {
    /**
     * @generated from protobuf field: repeated uint32 del_entity_id_list = 15;
     */
    delEntityIdList: number[];
    /**
     * @generated from protobuf field: optional uint32 scene_id = 8;
     */
    sceneId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.DelTeamEntityNotify.CmdId
 */
export enum DelTeamEntityNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 302;
     */
    CMD_ID = 302,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.EvtSyncSkillAnchorPosition
 */
export interface EvtSyncSkillAnchorPosition {
    /**
     * @generated from protobuf field: optional uint32 entity_id = 2;
     */
    entityId?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector skill_anchor_position = 13;
     */
    skillAnchorPosition?: Vector;
}
/**
 * @generated from protobuf message com.midnights.game.CombatInvokeEntry
 */
export interface CombatInvokeEntry {
    /**
     * @generated from protobuf field: optional bytes combat_data = 12;
     */
    combatData?: Uint8Array;
    /**
     * @generated from protobuf field: optional com.midnights.game.ForwardType forward_type = 10;
     */
    forwardType?: ForwardType;
    /**
     * @generated from protobuf field: optional com.midnights.game.CombatTypeArgument argument_type = 11;
     */
    argumentType?: CombatTypeArgument;
}
/**
 * @generated from protobuf message com.midnights.game.CombatInvocationsNotify
 */
export interface CombatInvocationsNotify {
    /**
     * @generated from protobuf field: repeated com.midnights.game.CombatInvokeEntry invoke_list = 14;
     */
    invokeList: CombatInvokeEntry[];
}
/**
 * @generated from protobuf enum com.midnights.game.CombatInvocationsNotify.CmdId
 */
export enum CombatInvocationsNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 319;
     */
    CMD_ID = 319,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.ServerBuffChangeNotify
 */
export interface ServerBuffChangeNotify {
    /**
     * @generated from protobuf field: optional com.midnights.game.ServerBuffChangeNotify.ServerBuffChangeType server_buff_change_type = 7;
     */
    serverBuffChangeType?: ServerBuffChangeNotify_ServerBuffChangeType;
    /**
     * @generated from protobuf field: optional bool is_creature_buff = 10;
     */
    isCreatureBuff?: boolean;
    /**
     * @generated from protobuf field: repeated uint32 entity_id_list = 1;
     */
    entityIdList: number[];
    /**
     * @generated from protobuf field: repeated uint64 avatar_guid_list = 12;
     */
    avatarGuidList: bigint[];
    /**
     * @generated from protobuf field: repeated com.midnights.game.ServerBuff server_buff_list = 11;
     */
    serverBuffList: ServerBuff[];
}
/**
 * @generated from protobuf enum com.midnights.game.ServerBuffChangeNotify.ServerBuffChangeType
 */
export enum ServerBuffChangeNotify_ServerBuffChangeType {
    /**
     * @generated from protobuf enum value: ADD_SERVER_BUFF = 0;
     */
    ADD_SERVER_BUFF = 0,
    /**
     * @generated from protobuf enum value: DEL_SERVER_BUFF = 1;
     */
    DEL_SERVER_BUFF = 1
}
/**
 * @generated from protobuf enum com.midnights.game.ServerBuffChangeNotify.CmdId
 */
export enum ServerBuffChangeNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 361;
     */
    CMD_ID = 361,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.AiThreatInfo
 */
export interface AiThreatInfo {
    /**
     * @generated from protobuf field: map<uint32, uint32> ai_threat_map = 11;
     */
    aiThreatMap: {
        [key: number]: number;
    };
}
/**
 * @generated from protobuf message com.midnights.game.EvtAiSyncCombatThreatInfoNotify
 */
export interface EvtAiSyncCombatThreatInfoNotify {
    /**
     * @generated from protobuf field: map<uint32, com.midnights.game.AiThreatInfo> combat_threat_info_map = 8;
     */
    combatThreatInfoMap: {
        [key: number]: AiThreatInfo;
    };
}
/**
 * @generated from protobuf enum com.midnights.game.EvtAiSyncCombatThreatInfoNotify.CmdId
 */
export enum EvtAiSyncCombatThreatInfoNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 329;
     */
    CMD_ID = 329,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.MassiveEntityElementOpBatchNotify
 */
export interface MassiveEntityElementOpBatchNotify {
    /**
     * @generated from protobuf field: optional int32 entity_type = 6;
     */
    entityType?: number;
    /**
     * @generated from protobuf field: optional uint32 op_idx = 9;
     */
    opIdx?: number;
    /**
     * @generated from protobuf field: optional uint32 user_id = 11;
     */
    userId?: number;
    /**
     * @generated from protobuf field: optional uint32 attacker_id = 3;
     */
    attackerId?: number;
    /**
     * @generated from protobuf field: optional int32 source_element_type = 12;
     */
    sourceElementType?: number;
    /**
     * @generated from protobuf field: optional int32 reaction_source_type = 4;
     */
    reactionSourceType?: number;
    /**
     * @generated from protobuf field: optional float attack_element_durability = 7;
     */
    attackElementDurability?: number;
    /**
     * @generated from protobuf oneof: check_shape
     */
    checkShape: {
        oneofKind: "shapeSphere";
        /**
         * @generated from protobuf field: com.midnights.game.ShapeSphere shape_sphere = 10;
         */
        shapeSphere: ShapeSphere;
    } | {
        oneofKind: "shapeBox";
        /**
         * @generated from protobuf field: com.midnights.game.ShapeBox shape_box = 2;
         */
        shapeBox: ShapeBox;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf enum com.midnights.game.MassiveEntityElementOpBatchNotify.CmdId
 */
export enum MassiveEntityElementOpBatchNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 357;
     */
    CMD_ID = 357,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.AiSyncInfo
 */
export interface AiSyncInfo {
    /**
     * @generated from protobuf field: optional uint32 entity_id = 9;
     */
    entityId?: number;
    /**
     * @generated from protobuf field: optional bool is_self_killing = 8;
     */
    isSelfKilling?: boolean;
    /**
     * @generated from protobuf field: optional bool has_path_to_target = 4;
     */
    hasPathToTarget?: boolean;
}
/**
 * @generated from protobuf message com.midnights.game.EntityAiSyncNotify
 */
export interface EntityAiSyncNotify {
    /**
     * @generated from protobuf field: repeated uint32 local_avatar_alerted_monster_list = 15;
     */
    localAvatarAlertedMonsterList: number[];
    /**
     * @generated from protobuf field: repeated com.midnights.game.AiSyncInfo info_list = 1;
     */
    infoList: AiSyncInfo[];
}
/**
 * @generated from protobuf enum com.midnights.game.EntityAiSyncNotify.CmdId
 */
export enum EntityAiSyncNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 400;
     */
    CMD_ID = 400,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.LuaSetOptionNotify
 */
export interface LuaSetOptionNotify {
    /**
     * @generated from protobuf field: optional string lua_set_param = 8;
     */
    luaSetParam?: string;
    /**
     * @generated from protobuf field: optional com.midnights.game.LuaSetOptionNotify.LuaOptionType option_type = 10;
     */
    optionType?: LuaSetOptionNotify_LuaOptionType;
}
/**
 * @generated from protobuf enum com.midnights.game.LuaSetOptionNotify.LuaOptionType
 */
export enum LuaSetOptionNotify_LuaOptionType {
    /**
     * @generated from protobuf enum value: LUA_OPTION_NONE = 0;
     */
    LUA_OPTION_NONE = 0,
    /**
     * @generated from protobuf enum value: LUA_OPTION_PLAYER_INPUT = 1;
     */
    LUA_OPTION_PLAYER_INPUT = 1
}
/**
 * @generated from protobuf enum com.midnights.game.LuaSetOptionNotify.CmdId
 */
export enum LuaSetOptionNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 316;
     */
    CMD_ID = 316,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.EvtDestroyServerGadgetNotify
 */
export interface EvtDestroyServerGadgetNotify {
    /**
     * @generated from protobuf field: optional uint32 entity_id = 7;
     */
    entityId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.EvtDestroyServerGadgetNotify.CmdId
 */
export enum EvtDestroyServerGadgetNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 387;
     */
    CMD_ID = 387,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.EntityAiKillSelfNotify
 */
export interface EntityAiKillSelfNotify {
    /**
     * @generated from protobuf field: optional uint32 entity_id = 12;
     */
    entityId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.EntityAiKillSelfNotify.CmdId
 */
export enum EntityAiKillSelfNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 340;
     */
    CMD_ID = 340,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.EvtAvatarLockChairReq
 */
export interface EvtAvatarLockChairReq {
    /**
     * @generated from protobuf field: optional uint64 chair_id = 5;
     */
    chairId?: bigint;
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector position = 8;
     */
    position?: Vector;
}
/**
 * @generated from protobuf enum com.midnights.game.EvtAvatarLockChairReq.CmdId
 */
export enum EvtAvatarLockChairReq_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 318;
     */
    CMD_ID = 318,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.EvtAvatarLockChairRsp
 */
export interface EvtAvatarLockChairRsp {
    /**
     * @generated from protobuf field: optional uint64 chair_id = 14;
     */
    chairId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 entity_id = 15;
     */
    entityId?: number;
    /**
     * @generated from protobuf field: optional com.midnights.game.Vector position = 4;
     */
    position?: Vector;
    /**
     * @generated from protobuf field: optional int32 retcode = 12;
     */
    retcode?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.EvtAvatarLockChairRsp.CmdId
 */
export enum EvtAvatarLockChairRsp_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 366;
     */
    CMD_ID = 366,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.ReportFightAntiCheatNotify
 */
export interface ReportFightAntiCheatNotify {
    /**
     * @generated from protobuf field: optional uint32 cheat_count = 8;
     */
    cheatCount?: number;
    /**
     * @generated from protobuf field: optional uint32 cheat_type = 12;
     */
    cheatType?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.ReportFightAntiCheatNotify.CmdId
 */
export enum ReportFightAntiCheatNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 368;
     */
    CMD_ID = 368,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    IS_ALLOW_CLIENT = 1
}
/**
 * @generated from protobuf message com.midnights.game.EvtBeingHealedNotify
 */
export interface EvtBeingHealedNotify {
    /**
     * @generated from protobuf field: optional uint32 target_id = 1;
     */
    targetId?: number;
    /**
     * @generated from protobuf field: optional float real_heal_amount = 5;
     */
    realHealAmount?: number;
    /**
     * @generated from protobuf field: optional uint32 source_id = 13;
     */
    sourceId?: number;
    /**
     * @generated from protobuf field: optional float heal_amount = 4;
     */
    healAmount?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.EvtBeingHealedNotify.CmdId
 */
export enum EvtBeingHealedNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 333;
     */
    CMD_ID = 333,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf message com.midnights.game.EvtLocalGadgetOwnerLeaveSceneNotify
 */
export interface EvtLocalGadgetOwnerLeaveSceneNotify {
    /**
     * @generated from protobuf field: optional uint32 entity_id = 10;
     */
    entityId?: number;
}
/**
 * @generated from protobuf enum com.midnights.game.EvtLocalGadgetOwnerLeaveSceneNotify.CmdId
 */
export enum EvtLocalGadgetOwnerLeaveSceneNotify_CmdId {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_ID = 384;
     */
    CMD_ID = 384,
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    ENET_CHANNEL_ID = 0,
    /**
     * @generated from protobuf enum value: ENET_IS_RELIABLE = 1;
     */
    ENET_IS_RELIABLE = 1
}
/**
 * @generated from protobuf enum com.midnights.game.ForwardType
 */
export enum ForwardType {
    /**
     * @generated from protobuf enum value: FORWARD_LOCAL = 0;
     */
    FORWARD_LOCAL = 0,
    /**
     * @generated from protobuf enum value: FORWARD_TO_ALL = 1;
     */
    FORWARD_TO_ALL = 1,
    /**
     * @generated from protobuf enum value: FORWARD_TO_ALL_EXCEPT_CUR = 2;
     */
    FORWARD_TO_ALL_EXCEPT_CUR = 2,
    /**
     * @generated from protobuf enum value: FORWARD_TO_HOST = 3;
     */
    FORWARD_TO_HOST = 3,
    /**
     * @generated from protobuf enum value: FORWARD_TO_ALL_GUEST = 4;
     */
    FORWARD_TO_ALL_GUEST = 4,
    /**
     * @generated from protobuf enum value: FORWARD_TO_PEER = 5;
     */
    FORWARD_TO_PEER = 5,
    /**
     * @generated from protobuf enum value: FORWARD_TO_PEERS = 6;
     */
    FORWARD_TO_PEERS = 6,
    /**
     * @generated from protobuf enum value: FORWARD_ONLY_SERVER = 7;
     */
    FORWARD_ONLY_SERVER = 7,
    /**
     * @generated from protobuf enum value: FORWARD_TO_ALL_EXIST_EXCEPT_CUR = 8;
     */
    FORWARD_TO_ALL_EXIST_EXCEPT_CUR = 8
}
/**
 * @generated from protobuf enum com.midnights.game.HitColliderType
 */
export enum HitColliderType {
    /**
     * @generated from protobuf enum value: HIT_COLLIDER_INVALID = 0;
     */
    HIT_COLLIDER_INVALID = 0,
    /**
     * @generated from protobuf enum value: HIT_COLLIDER_HIT_BOX = 1;
     */
    HIT_COLLIDER_HIT_BOX = 1,
    /**
     * @generated from protobuf enum value: HIT_COLLIDER_WET_HIT_BOX = 2;
     */
    HIT_COLLIDER_WET_HIT_BOX = 2,
    /**
     * @generated from protobuf enum value: HIT_COLLIDER_HEAD_BOX = 3;
     */
    HIT_COLLIDER_HEAD_BOX = 3
}
/**
 * @generated from protobuf enum com.midnights.game.CombatTypeArgument
 */
export enum CombatTypeArgument {
    /**
     * @generated from protobuf enum value: COMBAT_NONE = 0;
     */
    COMBAT_NONE = 0,
    /**
     * @generated from protobuf enum value: COMBAT_EVT_BEING_HIT = 1;
     */
    COMBAT_EVT_BEING_HIT = 1,
    /**
     * @generated from protobuf enum value: COMBAT_ANIMATOR_STATE_CHANGED = 2;
     */
    COMBAT_ANIMATOR_STATE_CHANGED = 2,
    /**
     * @generated from protobuf enum value: COMBAT_FACE_TO_DIR = 3;
     */
    COMBAT_FACE_TO_DIR = 3,
    /**
     * @generated from protobuf enum value: COMBAT_SET_ATTACK_TARGET = 4;
     */
    COMBAT_SET_ATTACK_TARGET = 4,
    /**
     * @generated from protobuf enum value: COMBAT_RUSH_MOVE = 5;
     */
    COMBAT_RUSH_MOVE = 5,
    /**
     * @generated from protobuf enum value: COMBAT_ANIMATOR_PARAMETER_CHANGED = 6;
     */
    COMBAT_ANIMATOR_PARAMETER_CHANGED = 6,
    /**
     * @generated from protobuf enum value: ENTITY_MOVE = 7;
     */
    ENTITY_MOVE = 7,
    /**
     * @generated from protobuf enum value: SYNC_ENTITY_POSITION = 8;
     */
    SYNC_ENTITY_POSITION = 8,
    /**
     * @generated from protobuf enum value: COMBAT_STEER_MOTION_INFO = 9;
     */
    COMBAT_STEER_MOTION_INFO = 9,
    /**
     * @generated from protobuf enum value: COMBAT_FORCE_SET_POS_INFO = 10;
     */
    COMBAT_FORCE_SET_POS_INFO = 10,
    /**
     * @generated from protobuf enum value: COMBAT_COMPENSATE_POS_DIFF = 11;
     */
    COMBAT_COMPENSATE_POS_DIFF = 11,
    /**
     * @generated from protobuf enum value: COMBAT_MONSTER_DO_BLINK = 12;
     */
    COMBAT_MONSTER_DO_BLINK = 12,
    /**
     * @generated from protobuf enum value: COMBAT_FIXED_RUSH_MOVE = 13;
     */
    COMBAT_FIXED_RUSH_MOVE = 13,
    /**
     * @generated from protobuf enum value: COMBAT_SYNC_TRANSFORM = 14;
     */
    COMBAT_SYNC_TRANSFORM = 14,
    /**
     * @generated from protobuf enum value: COMBAT_LIGHT_CORE_MOVE = 15;
     */
    COMBAT_LIGHT_CORE_MOVE = 15,
    /**
     * @generated from protobuf enum value: COMBAT_BEING_HEALED_NTF = 16;
     */
    COMBAT_BEING_HEALED_NTF = 16,
    /**
     * @generated from protobuf enum value: COMBAT_SKILL_ANCHOR_POSITION_NTF = 17;
     */
    COMBAT_SKILL_ANCHOR_POSITION_NTF = 17,
    /**
     * @generated from protobuf enum value: COMBAT_GRAPPLING_HOOK_MOVE = 18;
     */
    COMBAT_GRAPPLING_HOOK_MOVE = 18
}
// @generated message type with reflection information, may provide speed optimized methods
class HitCollision$Type extends MessageType<HitCollision> {
    constructor() {
        super("com.midnights.game.HitCollision", [
            { no: 8, name: "hit_collider_type", kind: "enum", opt: true, T: () => ["com.midnights.game.HitColliderType", HitColliderType] },
            { no: 7, name: "hit_point", kind: "message", T: () => Vector },
            { no: 2, name: "attackee_hit_force_angle", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 13, name: "hit_dir", kind: "message", T: () => Vector },
            { no: 15, name: "attackee_hit_entity_angle", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "hit_box_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<HitCollision>): HitCollision {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HitCollision>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HitCollision): HitCollision {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.HitColliderType hit_collider_type */ 8:
                    message.hitColliderType = reader.int32();
                    break;
                case /* optional com.midnights.game.Vector hit_point */ 7:
                    message.hitPoint = Vector.internalBinaryRead(reader, reader.uint32(), options, message.hitPoint);
                    break;
                case /* optional float attackee_hit_force_angle */ 2:
                    message.attackeeHitForceAngle = reader.float();
                    break;
                case /* optional com.midnights.game.Vector hit_dir */ 13:
                    message.hitDir = Vector.internalBinaryRead(reader, reader.uint32(), options, message.hitDir);
                    break;
                case /* optional float attackee_hit_entity_angle */ 15:
                    message.attackeeHitEntityAngle = reader.float();
                    break;
                case /* optional int32 hit_box_index */ 4:
                    message.hitBoxIndex = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HitCollision, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.HitColliderType hit_collider_type = 8; */
        if (message.hitColliderType !== undefined)
            writer.tag(8, WireType.Varint).int32(message.hitColliderType);
        /* optional com.midnights.game.Vector hit_point = 7; */
        if (message.hitPoint)
            Vector.internalBinaryWrite(message.hitPoint, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* optional float attackee_hit_force_angle = 2; */
        if (message.attackeeHitForceAngle !== undefined)
            writer.tag(2, WireType.Bit32).float(message.attackeeHitForceAngle);
        /* optional com.midnights.game.Vector hit_dir = 13; */
        if (message.hitDir)
            Vector.internalBinaryWrite(message.hitDir, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* optional float attackee_hit_entity_angle = 15; */
        if (message.attackeeHitEntityAngle !== undefined)
            writer.tag(15, WireType.Bit32).float(message.attackeeHitEntityAngle);
        /* optional int32 hit_box_index = 4; */
        if (message.hitBoxIndex !== undefined)
            writer.tag(4, WireType.Varint).int32(message.hitBoxIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.HitCollision
 */
export const HitCollision = new HitCollision$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttackHitEffectResult$Type extends MessageType<AttackHitEffectResult> {
    constructor() {
        super("com.midnights.game.AttackHitEffectResult", [
            { no: 8, name: "hit_halt_time_scale", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 12, name: "original_hit_eff_level", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "air_strength", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "hit_eff_level", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "hit_halt_time", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "retreat_strength", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<AttackHitEffectResult>): AttackHitEffectResult {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AttackHitEffectResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttackHitEffectResult): AttackHitEffectResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float hit_halt_time_scale */ 8:
                    message.hitHaltTimeScale = reader.float();
                    break;
                case /* optional uint32 original_hit_eff_level */ 12:
                    message.originalHitEffLevel = reader.uint32();
                    break;
                case /* optional float air_strength */ 15:
                    message.airStrength = reader.float();
                    break;
                case /* optional uint32 hit_eff_level */ 2:
                    message.hitEffLevel = reader.uint32();
                    break;
                case /* optional float hit_halt_time */ 13:
                    message.hitHaltTime = reader.float();
                    break;
                case /* optional float retreat_strength */ 7:
                    message.retreatStrength = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AttackHitEffectResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float hit_halt_time_scale = 8; */
        if (message.hitHaltTimeScale !== undefined)
            writer.tag(8, WireType.Bit32).float(message.hitHaltTimeScale);
        /* optional uint32 original_hit_eff_level = 12; */
        if (message.originalHitEffLevel !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.originalHitEffLevel);
        /* optional float air_strength = 15; */
        if (message.airStrength !== undefined)
            writer.tag(15, WireType.Bit32).float(message.airStrength);
        /* optional uint32 hit_eff_level = 2; */
        if (message.hitEffLevel !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.hitEffLevel);
        /* optional float hit_halt_time = 13; */
        if (message.hitHaltTime !== undefined)
            writer.tag(13, WireType.Bit32).float(message.hitHaltTime);
        /* optional float retreat_strength = 7; */
        if (message.retreatStrength !== undefined)
            writer.tag(7, WireType.Bit32).float(message.retreatStrength);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.AttackHitEffectResult
 */
export const AttackHitEffectResult = new AttackHitEffectResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AbilityIdentifier$Type extends MessageType<AbilityIdentifier> {
    constructor() {
        super("com.midnights.game.AbilityIdentifier", [
            { no: 2, name: "modifier_owner_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "instanced_modifier_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "instanced_ability_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "is_serverbuff_modifier", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "ability_caster_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "local_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AbilityIdentifier>): AbilityIdentifier {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AbilityIdentifier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbilityIdentifier): AbilityIdentifier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 modifier_owner_id */ 2:
                    message.modifierOwnerId = reader.uint32();
                    break;
                case /* optional uint32 instanced_modifier_id */ 9:
                    message.instancedModifierId = reader.uint32();
                    break;
                case /* optional uint32 instanced_ability_id */ 10:
                    message.instancedAbilityId = reader.uint32();
                    break;
                case /* optional bool is_serverbuff_modifier */ 6:
                    message.isServerbuffModifier = reader.bool();
                    break;
                case /* optional uint32 ability_caster_id */ 15:
                    message.abilityCasterId = reader.uint32();
                    break;
                case /* optional int32 local_id */ 3:
                    message.localId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AbilityIdentifier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 modifier_owner_id = 2; */
        if (message.modifierOwnerId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.modifierOwnerId);
        /* optional uint32 instanced_modifier_id = 9; */
        if (message.instancedModifierId !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.instancedModifierId);
        /* optional uint32 instanced_ability_id = 10; */
        if (message.instancedAbilityId !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.instancedAbilityId);
        /* optional bool is_serverbuff_modifier = 6; */
        if (message.isServerbuffModifier !== undefined)
            writer.tag(6, WireType.Varint).bool(message.isServerbuffModifier);
        /* optional uint32 ability_caster_id = 15; */
        if (message.abilityCasterId !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.abilityCasterId);
        /* optional int32 local_id = 3; */
        if (message.localId !== undefined)
            writer.tag(3, WireType.Varint).int32(message.localId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.AbilityIdentifier
 */
export const AbilityIdentifier = new AbilityIdentifier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttackResult$Type extends MessageType<AttackResult> {
    constructor() {
        super("com.midnights.game.AttackResult", [
            { no: 1858, name: "is_resist_text", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 1011, name: "create_count_sync_to_server", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2005, name: "amplify_reaction_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "endure_break", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "element_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 425, name: "element_durability_attenuation", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 15, name: "defense_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 1188, name: "attack_timestamp_ms", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 91, name: "bullet_fly_time_ms", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "is_crit", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 900, name: "element_amplify_rate", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 1564, name: "attack_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 1664, name: "critical_rand", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "hit_pos_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "anim_event_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "hit_eff_result", kind: "message", T: () => AttackHitEffectResult },
            { no: 1202, name: "damage_shield", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 430, name: "endure_delta", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 1, name: "resolved_dir", kind: "message", T: () => Vector },
            { no: 6, name: "damage", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 1887, name: "addhurt_reaction_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 278, name: "hashed_anim_event_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 1418, name: "use_gadget_damage_action", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "hit_retreat_angle_compat", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "ability_identifier", kind: "message", T: () => AbilityIdentifier },
            { no: 11, name: "attacker_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 1530, name: "mute_element_hurt", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 1366, name: "target_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "hit_collision", kind: "message", T: () => HitCollision },
            { no: 1110, name: "gadget_damage_action_idx", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AttackResult>): AttackResult {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AttackResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttackResult): AttackResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool is_resist_text */ 1858:
                    message.isResistText = reader.bool();
                    break;
                case /* optional uint32 create_count_sync_to_server */ 1011:
                    message.createCountSyncToServer = reader.uint32();
                    break;
                case /* optional uint32 amplify_reaction_type */ 2005:
                    message.amplifyReactionType = reader.uint32();
                    break;
                case /* optional uint32 endure_break */ 7:
                    message.endureBreak = reader.uint32();
                    break;
                case /* optional uint32 element_type */ 5:
                    message.elementType = reader.uint32();
                    break;
                case /* optional float element_durability_attenuation */ 425:
                    message.elementDurabilityAttenuation = reader.float();
                    break;
                case /* optional uint32 defense_id */ 15:
                    message.defenseId = reader.uint32();
                    break;
                case /* optional uint32 attack_timestamp_ms */ 1188:
                    message.attackTimestampMs = reader.uint32();
                    break;
                case /* optional uint32 bullet_fly_time_ms */ 91:
                    message.bulletFlyTimeMs = reader.uint32();
                    break;
                case /* optional bool is_crit */ 13:
                    message.isCrit = reader.bool();
                    break;
                case /* optional float element_amplify_rate */ 900:
                    message.elementAmplifyRate = reader.float();
                    break;
                case /* optional uint32 attack_count */ 1564:
                    message.attackCount = reader.uint32();
                    break;
                case /* optional uint32 critical_rand */ 1664:
                    message.criticalRand = reader.uint32();
                    break;
                case /* optional uint32 hit_pos_type */ 2:
                    message.hitPosType = reader.uint32();
                    break;
                case /* optional string anim_event_id */ 4:
                    message.animEventId = reader.string();
                    break;
                case /* optional com.midnights.game.AttackHitEffectResult hit_eff_result */ 8:
                    message.hitEffResult = AttackHitEffectResult.internalBinaryRead(reader, reader.uint32(), options, message.hitEffResult);
                    break;
                case /* optional float damage_shield */ 1202:
                    message.damageShield = reader.float();
                    break;
                case /* optional float endure_delta */ 430:
                    message.endureDelta = reader.float();
                    break;
                case /* optional com.midnights.game.Vector resolved_dir */ 1:
                    message.resolvedDir = Vector.internalBinaryRead(reader, reader.uint32(), options, message.resolvedDir);
                    break;
                case /* optional float damage */ 6:
                    message.damage = reader.float();
                    break;
                case /* optional uint32 addhurt_reaction_type */ 1887:
                    message.addhurtReactionType = reader.uint32();
                    break;
                case /* optional uint32 hashed_anim_event_id */ 278:
                    message.hashedAnimEventId = reader.uint32();
                    break;
                case /* optional bool use_gadget_damage_action */ 1418:
                    message.useGadgetDamageAction = reader.bool();
                    break;
                case /* optional int32 hit_retreat_angle_compat */ 9:
                    message.hitRetreatAngleCompat = reader.int32();
                    break;
                case /* optional com.midnights.game.AbilityIdentifier ability_identifier */ 14:
                    message.abilityIdentifier = AbilityIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.abilityIdentifier);
                    break;
                case /* optional uint32 attacker_id */ 11:
                    message.attackerId = reader.uint32();
                    break;
                case /* optional bool mute_element_hurt */ 1530:
                    message.muteElementHurt = reader.bool();
                    break;
                case /* optional uint32 target_type */ 1366:
                    message.targetType = reader.uint32();
                    break;
                case /* optional com.midnights.game.HitCollision hit_collision */ 10:
                    message.hitCollision = HitCollision.internalBinaryRead(reader, reader.uint32(), options, message.hitCollision);
                    break;
                case /* optional uint32 gadget_damage_action_idx */ 1110:
                    message.gadgetDamageActionIdx = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AttackResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool is_resist_text = 1858; */
        if (message.isResistText !== undefined)
            writer.tag(1858, WireType.Varint).bool(message.isResistText);
        /* optional uint32 create_count_sync_to_server = 1011; */
        if (message.createCountSyncToServer !== undefined)
            writer.tag(1011, WireType.Varint).uint32(message.createCountSyncToServer);
        /* optional uint32 amplify_reaction_type = 2005; */
        if (message.amplifyReactionType !== undefined)
            writer.tag(2005, WireType.Varint).uint32(message.amplifyReactionType);
        /* optional uint32 endure_break = 7; */
        if (message.endureBreak !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.endureBreak);
        /* optional uint32 element_type = 5; */
        if (message.elementType !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.elementType);
        /* optional float element_durability_attenuation = 425; */
        if (message.elementDurabilityAttenuation !== undefined)
            writer.tag(425, WireType.Bit32).float(message.elementDurabilityAttenuation);
        /* optional uint32 defense_id = 15; */
        if (message.defenseId !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.defenseId);
        /* optional uint32 attack_timestamp_ms = 1188; */
        if (message.attackTimestampMs !== undefined)
            writer.tag(1188, WireType.Varint).uint32(message.attackTimestampMs);
        /* optional uint32 bullet_fly_time_ms = 91; */
        if (message.bulletFlyTimeMs !== undefined)
            writer.tag(91, WireType.Varint).uint32(message.bulletFlyTimeMs);
        /* optional bool is_crit = 13; */
        if (message.isCrit !== undefined)
            writer.tag(13, WireType.Varint).bool(message.isCrit);
        /* optional float element_amplify_rate = 900; */
        if (message.elementAmplifyRate !== undefined)
            writer.tag(900, WireType.Bit32).float(message.elementAmplifyRate);
        /* optional uint32 attack_count = 1564; */
        if (message.attackCount !== undefined)
            writer.tag(1564, WireType.Varint).uint32(message.attackCount);
        /* optional uint32 critical_rand = 1664; */
        if (message.criticalRand !== undefined)
            writer.tag(1664, WireType.Varint).uint32(message.criticalRand);
        /* optional uint32 hit_pos_type = 2; */
        if (message.hitPosType !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.hitPosType);
        /* optional string anim_event_id = 4; */
        if (message.animEventId !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.animEventId);
        /* optional com.midnights.game.AttackHitEffectResult hit_eff_result = 8; */
        if (message.hitEffResult)
            AttackHitEffectResult.internalBinaryWrite(message.hitEffResult, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* optional float damage_shield = 1202; */
        if (message.damageShield !== undefined)
            writer.tag(1202, WireType.Bit32).float(message.damageShield);
        /* optional float endure_delta = 430; */
        if (message.endureDelta !== undefined)
            writer.tag(430, WireType.Bit32).float(message.endureDelta);
        /* optional com.midnights.game.Vector resolved_dir = 1; */
        if (message.resolvedDir)
            Vector.internalBinaryWrite(message.resolvedDir, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional float damage = 6; */
        if (message.damage !== undefined)
            writer.tag(6, WireType.Bit32).float(message.damage);
        /* optional uint32 addhurt_reaction_type = 1887; */
        if (message.addhurtReactionType !== undefined)
            writer.tag(1887, WireType.Varint).uint32(message.addhurtReactionType);
        /* optional uint32 hashed_anim_event_id = 278; */
        if (message.hashedAnimEventId !== undefined)
            writer.tag(278, WireType.Varint).uint32(message.hashedAnimEventId);
        /* optional bool use_gadget_damage_action = 1418; */
        if (message.useGadgetDamageAction !== undefined)
            writer.tag(1418, WireType.Varint).bool(message.useGadgetDamageAction);
        /* optional int32 hit_retreat_angle_compat = 9; */
        if (message.hitRetreatAngleCompat !== undefined)
            writer.tag(9, WireType.Varint).int32(message.hitRetreatAngleCompat);
        /* optional com.midnights.game.AbilityIdentifier ability_identifier = 14; */
        if (message.abilityIdentifier)
            AbilityIdentifier.internalBinaryWrite(message.abilityIdentifier, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 attacker_id = 11; */
        if (message.attackerId !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.attackerId);
        /* optional bool mute_element_hurt = 1530; */
        if (message.muteElementHurt !== undefined)
            writer.tag(1530, WireType.Varint).bool(message.muteElementHurt);
        /* optional uint32 target_type = 1366; */
        if (message.targetType !== undefined)
            writer.tag(1366, WireType.Varint).uint32(message.targetType);
        /* optional com.midnights.game.HitCollision hit_collision = 10; */
        if (message.hitCollision)
            HitCollision.internalBinaryWrite(message.hitCollision, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 gadget_damage_action_idx = 1110; */
        if (message.gadgetDamageActionIdx !== undefined)
            writer.tag(1110, WireType.Varint).uint32(message.gadgetDamageActionIdx);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.AttackResult
 */
export const AttackResult = new AttackResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtBeingHitInfo$Type extends MessageType<EvtBeingHitInfo> {
    constructor() {
        super("com.midnights.game.EvtBeingHitInfo", [
            { no: 6, name: "peer_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "attack_result", kind: "message", T: () => AttackResult },
            { no: 4, name: "frame_num", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EvtBeingHitInfo>): EvtBeingHitInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtBeingHitInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtBeingHitInfo): EvtBeingHitInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 peer_id */ 6:
                    message.peerId = reader.uint32();
                    break;
                case /* optional com.midnights.game.AttackResult attack_result */ 7:
                    message.attackResult = AttackResult.internalBinaryRead(reader, reader.uint32(), options, message.attackResult);
                    break;
                case /* optional uint32 frame_num */ 4:
                    message.frameNum = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtBeingHitInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 peer_id = 6; */
        if (message.peerId !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.peerId);
        /* optional com.midnights.game.AttackResult attack_result = 7; */
        if (message.attackResult)
            AttackResult.internalBinaryWrite(message.attackResult, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 frame_num = 4; */
        if (message.frameNum !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.frameNum);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtBeingHitInfo
 */
export const EvtBeingHitInfo = new EvtBeingHitInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtHittingOtherInfo$Type extends MessageType<EvtHittingOtherInfo> {
    constructor() {
        super("com.midnights.game.EvtHittingOtherInfo", [
            { no: 2, name: "attack_result", kind: "message", T: () => AttackResult },
            { no: 8, name: "peer_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EvtHittingOtherInfo>): EvtHittingOtherInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtHittingOtherInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtHittingOtherInfo): EvtHittingOtherInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.AttackResult attack_result */ 2:
                    message.attackResult = AttackResult.internalBinaryRead(reader, reader.uint32(), options, message.attackResult);
                    break;
                case /* optional uint32 peer_id */ 8:
                    message.peerId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtHittingOtherInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.AttackResult attack_result = 2; */
        if (message.attackResult)
            AttackResult.internalBinaryWrite(message.attackResult, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 peer_id = 8; */
        if (message.peerId !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.peerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtHittingOtherInfo
 */
export const EvtHittingOtherInfo = new EvtHittingOtherInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtBeingHitNotify$Type extends MessageType<EvtBeingHitNotify> {
    constructor() {
        super("com.midnights.game.EvtBeingHitNotify", [
            { no: 6, name: "forward_type", kind: "enum", opt: true, T: () => ["com.midnights.game.ForwardType", ForwardType] },
            { no: 3, name: "being_hit_info", kind: "message", T: () => EvtBeingHitInfo }
        ]);
    }
    create(value?: PartialMessage<EvtBeingHitNotify>): EvtBeingHitNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtBeingHitNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtBeingHitNotify): EvtBeingHitNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.ForwardType forward_type */ 6:
                    message.forwardType = reader.int32();
                    break;
                case /* optional com.midnights.game.EvtBeingHitInfo being_hit_info */ 3:
                    message.beingHitInfo = EvtBeingHitInfo.internalBinaryRead(reader, reader.uint32(), options, message.beingHitInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtBeingHitNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.ForwardType forward_type = 6; */
        if (message.forwardType !== undefined)
            writer.tag(6, WireType.Varint).int32(message.forwardType);
        /* optional com.midnights.game.EvtBeingHitInfo being_hit_info = 3; */
        if (message.beingHitInfo)
            EvtBeingHitInfo.internalBinaryWrite(message.beingHitInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtBeingHitNotify
 */
export const EvtBeingHitNotify = new EvtBeingHitNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtAnimatorParameterInfo$Type extends MessageType<EvtAnimatorParameterInfo> {
    constructor() {
        super("com.midnights.game.EvtAnimatorParameterInfo", [
            { no: 4, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "is_server_cache", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "value", kind: "message", T: () => AnimatorParameterValueInfo },
            { no: 15, name: "name_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<EvtAnimatorParameterInfo>): EvtAnimatorParameterInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtAnimatorParameterInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtAnimatorParameterInfo): EvtAnimatorParameterInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 entity_id */ 4:
                    message.entityId = reader.uint32();
                    break;
                case /* optional bool is_server_cache */ 5:
                    message.isServerCache = reader.bool();
                    break;
                case /* optional com.midnights.game.AnimatorParameterValueInfo value */ 7:
                    message.value = AnimatorParameterValueInfo.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                case /* optional int32 name_id */ 15:
                    message.nameId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtAnimatorParameterInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 entity_id = 4; */
        if (message.entityId !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.entityId);
        /* optional bool is_server_cache = 5; */
        if (message.isServerCache !== undefined)
            writer.tag(5, WireType.Varint).bool(message.isServerCache);
        /* optional com.midnights.game.AnimatorParameterValueInfo value = 7; */
        if (message.value)
            AnimatorParameterValueInfo.internalBinaryWrite(message.value, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 name_id = 15; */
        if (message.nameId !== undefined)
            writer.tag(15, WireType.Varint).int32(message.nameId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtAnimatorParameterInfo
 */
export const EvtAnimatorParameterInfo = new EvtAnimatorParameterInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtAnimatorParameterNotify$Type extends MessageType<EvtAnimatorParameterNotify> {
    constructor() {
        super("com.midnights.game.EvtAnimatorParameterNotify", [
            { no: 12, name: "animator_param_info", kind: "message", T: () => EvtAnimatorParameterInfo },
            { no: 14, name: "forward_type", kind: "enum", opt: true, T: () => ["com.midnights.game.ForwardType", ForwardType] }
        ]);
    }
    create(value?: PartialMessage<EvtAnimatorParameterNotify>): EvtAnimatorParameterNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtAnimatorParameterNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtAnimatorParameterNotify): EvtAnimatorParameterNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.EvtAnimatorParameterInfo animator_param_info */ 12:
                    message.animatorParamInfo = EvtAnimatorParameterInfo.internalBinaryRead(reader, reader.uint32(), options, message.animatorParamInfo);
                    break;
                case /* optional com.midnights.game.ForwardType forward_type */ 14:
                    message.forwardType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtAnimatorParameterNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.EvtAnimatorParameterInfo animator_param_info = 12; */
        if (message.animatorParamInfo)
            EvtAnimatorParameterInfo.internalBinaryWrite(message.animatorParamInfo, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* optional com.midnights.game.ForwardType forward_type = 14; */
        if (message.forwardType !== undefined)
            writer.tag(14, WireType.Varint).int32(message.forwardType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtAnimatorParameterNotify
 */
export const EvtAnimatorParameterNotify = new EvtAnimatorParameterNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AbilityArgument$Type extends MessageType<AbilityArgument> {
    constructor() {
        super("com.midnights.game.AbilityArgument", [
            { no: 5, name: "int_arg", kind: "scalar", oneof: "arg", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "float_arg", kind: "scalar", oneof: "arg", T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "str_arg", kind: "scalar", oneof: "arg", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AbilityArgument>): AbilityArgument {
        const message = { arg: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AbilityArgument>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbilityArgument): AbilityArgument {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 int_arg */ 5:
                    message.arg = {
                        oneofKind: "intArg",
                        intArg: reader.uint32()
                    };
                    break;
                case /* float float_arg */ 15:
                    message.arg = {
                        oneofKind: "floatArg",
                        floatArg: reader.float()
                    };
                    break;
                case /* string str_arg */ 11:
                    message.arg = {
                        oneofKind: "strArg",
                        strArg: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AbilityArgument, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 int_arg = 5; */
        if (message.arg.oneofKind === "intArg")
            writer.tag(5, WireType.Varint).uint32(message.arg.intArg);
        /* float float_arg = 15; */
        if (message.arg.oneofKind === "floatArg")
            writer.tag(15, WireType.Bit32).float(message.arg.floatArg);
        /* string str_arg = 11; */
        if (message.arg.oneofKind === "strArg")
            writer.tag(11, WireType.LengthDelimited).string(message.arg.strArg);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.AbilityArgument
 */
export const AbilityArgument = new AbilityArgument$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HostPlayerNotify$Type extends MessageType<HostPlayerNotify> {
    constructor() {
        super("com.midnights.game.HostPlayerNotify", [
            { no: 13, name: "host_peer_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "host_uid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<HostPlayerNotify>): HostPlayerNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HostPlayerNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HostPlayerNotify): HostPlayerNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 host_peer_id */ 13:
                    message.hostPeerId = reader.uint32();
                    break;
                case /* optional uint32 host_uid */ 10:
                    message.hostUid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HostPlayerNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 host_peer_id = 13; */
        if (message.hostPeerId !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.hostPeerId);
        /* optional uint32 host_uid = 10; */
        if (message.hostUid !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.hostUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.HostPlayerNotify
 */
export const HostPlayerNotify = new HostPlayerNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtDoSkillSuccNotify$Type extends MessageType<EvtDoSkillSuccNotify> {
    constructor() {
        super("com.midnights.game.EvtDoSkillSuccNotify", [
            { no: 13, name: "caster_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "forward_type", kind: "enum", opt: true, T: () => ["com.midnights.game.ForwardType", ForwardType] },
            { no: 15, name: "forward", kind: "message", T: () => Vector },
            { no: 7, name: "skill_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EvtDoSkillSuccNotify>): EvtDoSkillSuccNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtDoSkillSuccNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtDoSkillSuccNotify): EvtDoSkillSuccNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 caster_id */ 13:
                    message.casterId = reader.uint32();
                    break;
                case /* optional com.midnights.game.ForwardType forward_type */ 10:
                    message.forwardType = reader.int32();
                    break;
                case /* optional com.midnights.game.Vector forward */ 15:
                    message.forward = Vector.internalBinaryRead(reader, reader.uint32(), options, message.forward);
                    break;
                case /* optional uint32 skill_id */ 7:
                    message.skillId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtDoSkillSuccNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 caster_id = 13; */
        if (message.casterId !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.casterId);
        /* optional com.midnights.game.ForwardType forward_type = 10; */
        if (message.forwardType !== undefined)
            writer.tag(10, WireType.Varint).int32(message.forwardType);
        /* optional com.midnights.game.Vector forward = 15; */
        if (message.forward)
            Vector.internalBinaryWrite(message.forward, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 skill_id = 7; */
        if (message.skillId !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.skillId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtDoSkillSuccNotify
 */
export const EvtDoSkillSuccNotify = new EvtDoSkillSuccNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtCreateGadgetNotify$Type extends MessageType<EvtCreateGadgetNotify> {
    constructor() {
        super("com.midnights.game.EvtCreateGadgetNotify", [
            { no: 8, name: "is_async_load", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "camp_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "sight_group_with_owner", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 889, name: "target_entity_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "forward_type", kind: "enum", opt: true, T: () => ["com.midnights.game.ForwardType", ForwardType] },
            { no: 2, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "target_entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "camp_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "guid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "init_euler_angles", kind: "message", T: () => Vector },
            { no: 11, name: "target_lock_point_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 1920, name: "target_lock_point_index_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "init_pos", kind: "message", T: () => Vector },
            { no: 9, name: "owner_entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "room_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 25, name: "is_peer_id_from_player", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 1, name: "prop_owner_entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 379, name: "is_true_life_time_by_owner", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "config_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EvtCreateGadgetNotify>): EvtCreateGadgetNotify {
        const message = { targetEntityIdList: [], targetLockPointIndexList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtCreateGadgetNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtCreateGadgetNotify): EvtCreateGadgetNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool is_async_load */ 8:
                    message.isAsyncLoad = reader.bool();
                    break;
                case /* optional uint32 camp_type */ 5:
                    message.campType = reader.uint32();
                    break;
                case /* optional bool sight_group_with_owner */ 10:
                    message.sightGroupWithOwner = reader.bool();
                    break;
                case /* repeated uint32 target_entity_id_list */ 889:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.targetEntityIdList.push(reader.uint32());
                    else
                        message.targetEntityIdList.push(reader.uint32());
                    break;
                case /* optional com.midnights.game.ForwardType forward_type */ 12:
                    message.forwardType = reader.int32();
                    break;
                case /* optional uint32 entity_id */ 2:
                    message.entityId = reader.uint32();
                    break;
                case /* optional uint32 target_entity_id */ 3:
                    message.targetEntityId = reader.uint32();
                    break;
                case /* optional uint32 camp_id */ 15:
                    message.campId = reader.uint32();
                    break;
                case /* optional uint64 guid */ 6:
                    message.guid = reader.uint64().toBigInt();
                    break;
                case /* optional com.midnights.game.Vector init_euler_angles */ 13:
                    message.initEulerAngles = Vector.internalBinaryRead(reader, reader.uint32(), options, message.initEulerAngles);
                    break;
                case /* optional uint32 target_lock_point_index */ 11:
                    message.targetLockPointIndex = reader.uint32();
                    break;
                case /* repeated uint32 target_lock_point_index_list */ 1920:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.targetLockPointIndexList.push(reader.uint32());
                    else
                        message.targetLockPointIndexList.push(reader.uint32());
                    break;
                case /* optional com.midnights.game.Vector init_pos */ 4:
                    message.initPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.initPos);
                    break;
                case /* optional uint32 owner_entity_id */ 9:
                    message.ownerEntityId = reader.uint32();
                    break;
                case /* optional uint32 room_id */ 7:
                    message.roomId = reader.uint32();
                    break;
                case /* optional bool is_peer_id_from_player */ 25:
                    message.isPeerIdFromPlayer = reader.bool();
                    break;
                case /* optional uint32 prop_owner_entity_id */ 1:
                    message.propOwnerEntityId = reader.uint32();
                    break;
                case /* optional bool is_true_life_time_by_owner */ 379:
                    message.isTrueLifeTimeByOwner = reader.bool();
                    break;
                case /* optional uint32 config_id */ 14:
                    message.configId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtCreateGadgetNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool is_async_load = 8; */
        if (message.isAsyncLoad !== undefined)
            writer.tag(8, WireType.Varint).bool(message.isAsyncLoad);
        /* optional uint32 camp_type = 5; */
        if (message.campType !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.campType);
        /* optional bool sight_group_with_owner = 10; */
        if (message.sightGroupWithOwner !== undefined)
            writer.tag(10, WireType.Varint).bool(message.sightGroupWithOwner);
        /* repeated uint32 target_entity_id_list = 889; */
        if (message.targetEntityIdList.length) {
            writer.tag(889, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.targetEntityIdList.length; i++)
                writer.uint32(message.targetEntityIdList[i]);
            writer.join();
        }
        /* optional com.midnights.game.ForwardType forward_type = 12; */
        if (message.forwardType !== undefined)
            writer.tag(12, WireType.Varint).int32(message.forwardType);
        /* optional uint32 entity_id = 2; */
        if (message.entityId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.entityId);
        /* optional uint32 target_entity_id = 3; */
        if (message.targetEntityId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.targetEntityId);
        /* optional uint32 camp_id = 15; */
        if (message.campId !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.campId);
        /* optional uint64 guid = 6; */
        if (message.guid !== undefined)
            writer.tag(6, WireType.Varint).uint64(message.guid);
        /* optional com.midnights.game.Vector init_euler_angles = 13; */
        if (message.initEulerAngles)
            Vector.internalBinaryWrite(message.initEulerAngles, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 target_lock_point_index = 11; */
        if (message.targetLockPointIndex !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.targetLockPointIndex);
        /* repeated uint32 target_lock_point_index_list = 1920; */
        if (message.targetLockPointIndexList.length) {
            writer.tag(1920, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.targetLockPointIndexList.length; i++)
                writer.uint32(message.targetLockPointIndexList[i]);
            writer.join();
        }
        /* optional com.midnights.game.Vector init_pos = 4; */
        if (message.initPos)
            Vector.internalBinaryWrite(message.initPos, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 owner_entity_id = 9; */
        if (message.ownerEntityId !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.ownerEntityId);
        /* optional uint32 room_id = 7; */
        if (message.roomId !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.roomId);
        /* optional bool is_peer_id_from_player = 25; */
        if (message.isPeerIdFromPlayer !== undefined)
            writer.tag(25, WireType.Varint).bool(message.isPeerIdFromPlayer);
        /* optional uint32 prop_owner_entity_id = 1; */
        if (message.propOwnerEntityId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.propOwnerEntityId);
        /* optional bool is_true_life_time_by_owner = 379; */
        if (message.isTrueLifeTimeByOwner !== undefined)
            writer.tag(379, WireType.Varint).bool(message.isTrueLifeTimeByOwner);
        /* optional uint32 config_id = 14; */
        if (message.configId !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.configId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtCreateGadgetNotify
 */
export const EvtCreateGadgetNotify = new EvtCreateGadgetNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtDestroyGadgetNotify$Type extends MessageType<EvtDestroyGadgetNotify> {
    constructor() {
        super("com.midnights.game.EvtDestroyGadgetNotify", [
            { no: 5, name: "forward_type", kind: "enum", opt: true, T: () => ["com.midnights.game.ForwardType", ForwardType] },
            { no: 3, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EvtDestroyGadgetNotify>): EvtDestroyGadgetNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtDestroyGadgetNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtDestroyGadgetNotify): EvtDestroyGadgetNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.ForwardType forward_type */ 5:
                    message.forwardType = reader.int32();
                    break;
                case /* optional uint32 entity_id */ 3:
                    message.entityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtDestroyGadgetNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.ForwardType forward_type = 5; */
        if (message.forwardType !== undefined)
            writer.tag(5, WireType.Varint).int32(message.forwardType);
        /* optional uint32 entity_id = 3; */
        if (message.entityId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtDestroyGadgetNotify
 */
export const EvtDestroyGadgetNotify = new EvtDestroyGadgetNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtFaceToEntityNotify$Type extends MessageType<EvtFaceToEntityNotify> {
    constructor() {
        super("com.midnights.game.EvtFaceToEntityNotify", [
            { no: 5, name: "face_entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "forward_type", kind: "enum", opt: true, T: () => ["com.midnights.game.ForwardType", ForwardType] },
            { no: 1, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EvtFaceToEntityNotify>): EvtFaceToEntityNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtFaceToEntityNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtFaceToEntityNotify): EvtFaceToEntityNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 face_entity_id */ 5:
                    message.faceEntityId = reader.uint32();
                    break;
                case /* optional com.midnights.game.ForwardType forward_type */ 9:
                    message.forwardType = reader.int32();
                    break;
                case /* optional uint32 entity_id */ 1:
                    message.entityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtFaceToEntityNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 face_entity_id = 5; */
        if (message.faceEntityId !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.faceEntityId);
        /* optional com.midnights.game.ForwardType forward_type = 9; */
        if (message.forwardType !== undefined)
            writer.tag(9, WireType.Varint).int32(message.forwardType);
        /* optional uint32 entity_id = 1; */
        if (message.entityId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtFaceToEntityNotify
 */
export const EvtFaceToEntityNotify = new EvtFaceToEntityNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtFaceToDirInfo$Type extends MessageType<EvtFaceToDirInfo> {
    constructor() {
        super("com.midnights.game.EvtFaceToDirInfo", [
            { no: 12, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "face_dir", kind: "message", T: () => Vector }
        ]);
    }
    create(value?: PartialMessage<EvtFaceToDirInfo>): EvtFaceToDirInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtFaceToDirInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtFaceToDirInfo): EvtFaceToDirInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 entity_id */ 12:
                    message.entityId = reader.uint32();
                    break;
                case /* optional com.midnights.game.Vector face_dir */ 14:
                    message.faceDir = Vector.internalBinaryRead(reader, reader.uint32(), options, message.faceDir);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtFaceToDirInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 entity_id = 12; */
        if (message.entityId !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.entityId);
        /* optional com.midnights.game.Vector face_dir = 14; */
        if (message.faceDir)
            Vector.internalBinaryWrite(message.faceDir, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtFaceToDirInfo
 */
export const EvtFaceToDirInfo = new EvtFaceToDirInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtFaceToDirNotify$Type extends MessageType<EvtFaceToDirNotify> {
    constructor() {
        super("com.midnights.game.EvtFaceToDirNotify", [
            { no: 13, name: "forward_type", kind: "enum", opt: true, T: () => ["com.midnights.game.ForwardType", ForwardType] },
            { no: 5, name: "evt_face_to_dir_info", kind: "message", T: () => EvtFaceToDirInfo }
        ]);
    }
    create(value?: PartialMessage<EvtFaceToDirNotify>): EvtFaceToDirNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtFaceToDirNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtFaceToDirNotify): EvtFaceToDirNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.ForwardType forward_type */ 13:
                    message.forwardType = reader.int32();
                    break;
                case /* optional com.midnights.game.EvtFaceToDirInfo evt_face_to_dir_info */ 5:
                    message.evtFaceToDirInfo = EvtFaceToDirInfo.internalBinaryRead(reader, reader.uint32(), options, message.evtFaceToDirInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtFaceToDirNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.ForwardType forward_type = 13; */
        if (message.forwardType !== undefined)
            writer.tag(13, WireType.Varint).int32(message.forwardType);
        /* optional com.midnights.game.EvtFaceToDirInfo evt_face_to_dir_info = 5; */
        if (message.evtFaceToDirInfo)
            EvtFaceToDirInfo.internalBinaryWrite(message.evtFaceToDirInfo, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtFaceToDirNotify
 */
export const EvtFaceToDirNotify = new EvtFaceToDirNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtCostStaminaNotify$Type extends MessageType<EvtCostStaminaNotify> {
    constructor() {
        super("com.midnights.game.EvtCostStaminaNotify", [
            { no: 6, name: "skill_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "cost_stamina", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<EvtCostStaminaNotify>): EvtCostStaminaNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtCostStaminaNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtCostStaminaNotify): EvtCostStaminaNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 skill_id */ 6:
                    message.skillId = reader.uint32();
                    break;
                case /* optional float cost_stamina */ 11:
                    message.costStamina = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtCostStaminaNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 skill_id = 6; */
        if (message.skillId !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.skillId);
        /* optional float cost_stamina = 11; */
        if (message.costStamina !== undefined)
            writer.tag(11, WireType.Bit32).float(message.costStamina);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtCostStaminaNotify
 */
export const EvtCostStaminaNotify = new EvtCostStaminaNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtSetAttackTargetInfo$Type extends MessageType<EvtSetAttackTargetInfo> {
    constructor() {
        super("com.midnights.game.EvtSetAttackTargetInfo", [
            { no: 11, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "select_point_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "attack_target_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EvtSetAttackTargetInfo>): EvtSetAttackTargetInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtSetAttackTargetInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtSetAttackTargetInfo): EvtSetAttackTargetInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 entity_id */ 11:
                    message.entityId = reader.uint32();
                    break;
                case /* optional uint32 select_point_index */ 6:
                    message.selectPointIndex = reader.uint32();
                    break;
                case /* optional uint32 attack_target_id */ 7:
                    message.attackTargetId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtSetAttackTargetInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 entity_id = 11; */
        if (message.entityId !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.entityId);
        /* optional uint32 select_point_index = 6; */
        if (message.selectPointIndex !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.selectPointIndex);
        /* optional uint32 attack_target_id = 7; */
        if (message.attackTargetId !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.attackTargetId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtSetAttackTargetInfo
 */
export const EvtSetAttackTargetInfo = new EvtSetAttackTargetInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtSetAttackTargetNotify$Type extends MessageType<EvtSetAttackTargetNotify> {
    constructor() {
        super("com.midnights.game.EvtSetAttackTargetNotify", [
            { no: 1, name: "forward_type", kind: "enum", opt: true, T: () => ["com.midnights.game.ForwardType", ForwardType] },
            { no: 11, name: "evt_set_attack_target_info", kind: "message", T: () => EvtSetAttackTargetInfo }
        ]);
    }
    create(value?: PartialMessage<EvtSetAttackTargetNotify>): EvtSetAttackTargetNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtSetAttackTargetNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtSetAttackTargetNotify): EvtSetAttackTargetNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.ForwardType forward_type */ 1:
                    message.forwardType = reader.int32();
                    break;
                case /* optional com.midnights.game.EvtSetAttackTargetInfo evt_set_attack_target_info */ 11:
                    message.evtSetAttackTargetInfo = EvtSetAttackTargetInfo.internalBinaryRead(reader, reader.uint32(), options, message.evtSetAttackTargetInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtSetAttackTargetNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.ForwardType forward_type = 1; */
        if (message.forwardType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.forwardType);
        /* optional com.midnights.game.EvtSetAttackTargetInfo evt_set_attack_target_info = 11; */
        if (message.evtSetAttackTargetInfo)
            EvtSetAttackTargetInfo.internalBinaryWrite(message.evtSetAttackTargetInfo, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtSetAttackTargetNotify
 */
export const EvtSetAttackTargetNotify = new EvtSetAttackTargetNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtAnimatorStateChangedInfo$Type extends MessageType<EvtAnimatorStateChangedInfo> {
    constructor() {
        super("com.midnights.game.EvtAnimatorStateChangedInfo", [
            { no: 14, name: "face_angle_compact", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "to_state_hash", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "normalized_time_compact", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "layer", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "pos", kind: "message", T: () => Vector },
            { no: 3, name: "fade_duration", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 1, name: "forceSync", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "handle_animator_state_immediately", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<EvtAnimatorStateChangedInfo>): EvtAnimatorStateChangedInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtAnimatorStateChangedInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtAnimatorStateChangedInfo): EvtAnimatorStateChangedInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 face_angle_compact */ 14:
                    message.faceAngleCompact = reader.int32();
                    break;
                case /* optional uint32 to_state_hash */ 5:
                    message.toStateHash = reader.uint32();
                    break;
                case /* optional uint32 normalized_time_compact */ 9:
                    message.normalizedTimeCompact = reader.uint32();
                    break;
                case /* optional uint32 layer */ 2:
                    message.layer = reader.uint32();
                    break;
                case /* optional com.midnights.game.Vector pos */ 13:
                    message.pos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.pos);
                    break;
                case /* optional float fade_duration */ 3:
                    message.fadeDuration = reader.float();
                    break;
                case /* optional bool forceSync */ 1:
                    message.forceSync = reader.bool();
                    break;
                case /* optional uint32 entity_id */ 15:
                    message.entityId = reader.uint32();
                    break;
                case /* optional bool handle_animator_state_immediately */ 7:
                    message.handleAnimatorStateImmediately = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtAnimatorStateChangedInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 face_angle_compact = 14; */
        if (message.faceAngleCompact !== undefined)
            writer.tag(14, WireType.Varint).int32(message.faceAngleCompact);
        /* optional uint32 to_state_hash = 5; */
        if (message.toStateHash !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.toStateHash);
        /* optional uint32 normalized_time_compact = 9; */
        if (message.normalizedTimeCompact !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.normalizedTimeCompact);
        /* optional uint32 layer = 2; */
        if (message.layer !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.layer);
        /* optional com.midnights.game.Vector pos = 13; */
        if (message.pos)
            Vector.internalBinaryWrite(message.pos, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* optional float fade_duration = 3; */
        if (message.fadeDuration !== undefined)
            writer.tag(3, WireType.Bit32).float(message.fadeDuration);
        /* optional bool forceSync = 1; */
        if (message.forceSync !== undefined)
            writer.tag(1, WireType.Varint).bool(message.forceSync);
        /* optional uint32 entity_id = 15; */
        if (message.entityId !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.entityId);
        /* optional bool handle_animator_state_immediately = 7; */
        if (message.handleAnimatorStateImmediately !== undefined)
            writer.tag(7, WireType.Varint).bool(message.handleAnimatorStateImmediately);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtAnimatorStateChangedInfo
 */
export const EvtAnimatorStateChangedInfo = new EvtAnimatorStateChangedInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtCompensatePosDiffInfo$Type extends MessageType<EvtCompensatePosDiffInfo> {
    constructor() {
        super("com.midnights.game.EvtCompensatePosDiffInfo", [
            { no: 14, name: "cur_pos", kind: "message", T: () => Vector },
            { no: 11, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "face_angle_compact", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "cur_hash", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "normalized_time_compact", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EvtCompensatePosDiffInfo>): EvtCompensatePosDiffInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtCompensatePosDiffInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtCompensatePosDiffInfo): EvtCompensatePosDiffInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.Vector cur_pos */ 14:
                    message.curPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.curPos);
                    break;
                case /* optional uint32 entity_id */ 11:
                    message.entityId = reader.uint32();
                    break;
                case /* optional int32 face_angle_compact */ 10:
                    message.faceAngleCompact = reader.int32();
                    break;
                case /* optional uint32 cur_hash */ 4:
                    message.curHash = reader.uint32();
                    break;
                case /* optional uint32 normalized_time_compact */ 3:
                    message.normalizedTimeCompact = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtCompensatePosDiffInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.Vector cur_pos = 14; */
        if (message.curPos)
            Vector.internalBinaryWrite(message.curPos, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 entity_id = 11; */
        if (message.entityId !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.entityId);
        /* optional int32 face_angle_compact = 10; */
        if (message.faceAngleCompact !== undefined)
            writer.tag(10, WireType.Varint).int32(message.faceAngleCompact);
        /* optional uint32 cur_hash = 4; */
        if (message.curHash !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.curHash);
        /* optional uint32 normalized_time_compact = 3; */
        if (message.normalizedTimeCompact !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.normalizedTimeCompact);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtCompensatePosDiffInfo
 */
export const EvtCompensatePosDiffInfo = new EvtCompensatePosDiffInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtMonsterDoBlink$Type extends MessageType<EvtMonsterDoBlink> {
    constructor() {
        super("com.midnights.game.EvtMonsterDoBlink", [
            { no: 3, name: "target_rot", kind: "message", T: () => Vector },
            { no: 7, name: "target_pos", kind: "message", T: () => Vector },
            { no: 2, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EvtMonsterDoBlink>): EvtMonsterDoBlink {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtMonsterDoBlink>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtMonsterDoBlink): EvtMonsterDoBlink {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.Vector target_rot */ 3:
                    message.targetRot = Vector.internalBinaryRead(reader, reader.uint32(), options, message.targetRot);
                    break;
                case /* optional com.midnights.game.Vector target_pos */ 7:
                    message.targetPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.targetPos);
                    break;
                case /* optional uint32 entity_id */ 2:
                    message.entityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtMonsterDoBlink, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.Vector target_rot = 3; */
        if (message.targetRot)
            Vector.internalBinaryWrite(message.targetRot, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional com.midnights.game.Vector target_pos = 7; */
        if (message.targetPos)
            Vector.internalBinaryWrite(message.targetPos, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 entity_id = 2; */
        if (message.entityId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtMonsterDoBlink
 */
export const EvtMonsterDoBlink = new EvtMonsterDoBlink$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtFixedRushMove$Type extends MessageType<EvtFixedRushMove> {
    constructor() {
        super("com.midnights.game.EvtFixedRushMove", [
            { no: 15, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "speed", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "need_set_is_in_air", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "animator_state_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "target_pos", kind: "message", T: () => Vector },
            { no: 6, name: "check_animator_state_on_exit_only", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "override_collider", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EvtFixedRushMove>): EvtFixedRushMove {
        const message = { animatorStateIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtFixedRushMove>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtFixedRushMove): EvtFixedRushMove {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 entity_id */ 15:
                    message.entityId = reader.uint32();
                    break;
                case /* optional float speed */ 3:
                    message.speed = reader.float();
                    break;
                case /* optional bool need_set_is_in_air */ 7:
                    message.needSetIsInAir = reader.bool();
                    break;
                case /* repeated uint32 animator_state_id_list */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.animatorStateIdList.push(reader.uint32());
                    else
                        message.animatorStateIdList.push(reader.uint32());
                    break;
                case /* optional com.midnights.game.Vector target_pos */ 9:
                    message.targetPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.targetPos);
                    break;
                case /* optional bool check_animator_state_on_exit_only */ 6:
                    message.checkAnimatorStateOnExitOnly = reader.bool();
                    break;
                case /* optional string override_collider */ 13:
                    message.overrideCollider = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtFixedRushMove, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 entity_id = 15; */
        if (message.entityId !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.entityId);
        /* optional float speed = 3; */
        if (message.speed !== undefined)
            writer.tag(3, WireType.Bit32).float(message.speed);
        /* optional bool need_set_is_in_air = 7; */
        if (message.needSetIsInAir !== undefined)
            writer.tag(7, WireType.Varint).bool(message.needSetIsInAir);
        /* repeated uint32 animator_state_id_list = 2; */
        if (message.animatorStateIdList.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.animatorStateIdList.length; i++)
                writer.uint32(message.animatorStateIdList[i]);
            writer.join();
        }
        /* optional com.midnights.game.Vector target_pos = 9; */
        if (message.targetPos)
            Vector.internalBinaryWrite(message.targetPos, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* optional bool check_animator_state_on_exit_only = 6; */
        if (message.checkAnimatorStateOnExitOnly !== undefined)
            writer.tag(6, WireType.Varint).bool(message.checkAnimatorStateOnExitOnly);
        /* optional string override_collider = 13; */
        if (message.overrideCollider !== undefined)
            writer.tag(13, WireType.LengthDelimited).string(message.overrideCollider);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtFixedRushMove
 */
export const EvtFixedRushMove = new EvtFixedRushMove$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtSyncTransform$Type extends MessageType<EvtSyncTransform> {
    constructor() {
        super("com.midnights.game.EvtSyncTransform", [
            { no: 15, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "entity_pos", kind: "message", T: () => Vector },
            { no: 1, name: "entity_rot", kind: "message", T: () => Vector }
        ]);
    }
    create(value?: PartialMessage<EvtSyncTransform>): EvtSyncTransform {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtSyncTransform>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtSyncTransform): EvtSyncTransform {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 entity_id */ 15:
                    message.entityId = reader.uint32();
                    break;
                case /* optional com.midnights.game.Vector entity_pos */ 6:
                    message.entityPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.entityPos);
                    break;
                case /* optional com.midnights.game.Vector entity_rot */ 1:
                    message.entityRot = Vector.internalBinaryRead(reader, reader.uint32(), options, message.entityRot);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtSyncTransform, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 entity_id = 15; */
        if (message.entityId !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.entityId);
        /* optional com.midnights.game.Vector entity_pos = 6; */
        if (message.entityPos)
            Vector.internalBinaryWrite(message.entityPos, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional com.midnights.game.Vector entity_rot = 1; */
        if (message.entityRot)
            Vector.internalBinaryWrite(message.entityRot, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtSyncTransform
 */
export const EvtSyncTransform = new EvtSyncTransform$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtLightCoreMove$Type extends MessageType<EvtLightCoreMove> {
    constructor() {
        super("com.midnights.game.EvtLightCoreMove", [
            { no: 15, name: "target_pos", kind: "message", T: () => Vector },
            { no: 11, name: "acelerate", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "max_absorb_time", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 14, name: "speed", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<EvtLightCoreMove>): EvtLightCoreMove {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtLightCoreMove>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtLightCoreMove): EvtLightCoreMove {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.Vector target_pos */ 15:
                    message.targetPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.targetPos);
                    break;
                case /* optional float acelerate */ 11:
                    message.acelerate = reader.float();
                    break;
                case /* optional uint32 entity_id */ 5:
                    message.entityId = reader.uint32();
                    break;
                case /* optional float max_absorb_time */ 10:
                    message.maxAbsorbTime = reader.float();
                    break;
                case /* optional float speed */ 14:
                    message.speed = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtLightCoreMove, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.Vector target_pos = 15; */
        if (message.targetPos)
            Vector.internalBinaryWrite(message.targetPos, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* optional float acelerate = 11; */
        if (message.acelerate !== undefined)
            writer.tag(11, WireType.Bit32).float(message.acelerate);
        /* optional uint32 entity_id = 5; */
        if (message.entityId !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.entityId);
        /* optional float max_absorb_time = 10; */
        if (message.maxAbsorbTime !== undefined)
            writer.tag(10, WireType.Bit32).float(message.maxAbsorbTime);
        /* optional float speed = 14; */
        if (message.speed !== undefined)
            writer.tag(14, WireType.Bit32).float(message.speed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtLightCoreMove
 */
export const EvtLightCoreMove = new EvtLightCoreMove$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtGrapplingHookMove$Type extends MessageType<EvtGrapplingHookMove> {
    constructor() {
        super("com.midnights.game.EvtGrapplingHookMove", [
            { no: 1, name: "acceleration", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "animator_state_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "need_set_is_in_air", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "speed", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "max_speed", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "check_animator_state_on_exit_only", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "override_collider", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "target_pos", kind: "message", T: () => Vector }
        ]);
    }
    create(value?: PartialMessage<EvtGrapplingHookMove>): EvtGrapplingHookMove {
        const message = { animatorStateIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtGrapplingHookMove>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtGrapplingHookMove): EvtGrapplingHookMove {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float acceleration */ 1:
                    message.acceleration = reader.float();
                    break;
                case /* repeated uint32 animator_state_id_list */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.animatorStateIdList.push(reader.uint32());
                    else
                        message.animatorStateIdList.push(reader.uint32());
                    break;
                case /* optional uint32 entity_id */ 3:
                    message.entityId = reader.uint32();
                    break;
                case /* optional bool need_set_is_in_air */ 13:
                    message.needSetIsInAir = reader.bool();
                    break;
                case /* optional float speed */ 12:
                    message.speed = reader.float();
                    break;
                case /* optional float max_speed */ 8:
                    message.maxSpeed = reader.float();
                    break;
                case /* optional bool check_animator_state_on_exit_only */ 11:
                    message.checkAnimatorStateOnExitOnly = reader.bool();
                    break;
                case /* optional string override_collider */ 14:
                    message.overrideCollider = reader.string();
                    break;
                case /* optional com.midnights.game.Vector target_pos */ 10:
                    message.targetPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.targetPos);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtGrapplingHookMove, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float acceleration = 1; */
        if (message.acceleration !== undefined)
            writer.tag(1, WireType.Bit32).float(message.acceleration);
        /* repeated uint32 animator_state_id_list = 2; */
        if (message.animatorStateIdList.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.animatorStateIdList.length; i++)
                writer.uint32(message.animatorStateIdList[i]);
            writer.join();
        }
        /* optional uint32 entity_id = 3; */
        if (message.entityId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.entityId);
        /* optional bool need_set_is_in_air = 13; */
        if (message.needSetIsInAir !== undefined)
            writer.tag(13, WireType.Varint).bool(message.needSetIsInAir);
        /* optional float speed = 12; */
        if (message.speed !== undefined)
            writer.tag(12, WireType.Bit32).float(message.speed);
        /* optional float max_speed = 8; */
        if (message.maxSpeed !== undefined)
            writer.tag(8, WireType.Bit32).float(message.maxSpeed);
        /* optional bool check_animator_state_on_exit_only = 11; */
        if (message.checkAnimatorStateOnExitOnly !== undefined)
            writer.tag(11, WireType.Varint).bool(message.checkAnimatorStateOnExitOnly);
        /* optional string override_collider = 14; */
        if (message.overrideCollider !== undefined)
            writer.tag(14, WireType.LengthDelimited).string(message.overrideCollider);
        /* optional com.midnights.game.Vector target_pos = 10; */
        if (message.targetPos)
            Vector.internalBinaryWrite(message.targetPos, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtGrapplingHookMove
 */
export const EvtGrapplingHookMove = new EvtGrapplingHookMove$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtAnimatorStateChangedNotify$Type extends MessageType<EvtAnimatorStateChangedNotify> {
    constructor() {
        super("com.midnights.game.EvtAnimatorStateChangedNotify", [
            { no: 3, name: "forward_type", kind: "enum", opt: true, T: () => ["com.midnights.game.ForwardType", ForwardType] },
            { no: 10, name: "evt_animator_state_changed_info", kind: "message", T: () => EvtAnimatorStateChangedInfo }
        ]);
    }
    create(value?: PartialMessage<EvtAnimatorStateChangedNotify>): EvtAnimatorStateChangedNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtAnimatorStateChangedNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtAnimatorStateChangedNotify): EvtAnimatorStateChangedNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.ForwardType forward_type */ 3:
                    message.forwardType = reader.int32();
                    break;
                case /* optional com.midnights.game.EvtAnimatorStateChangedInfo evt_animator_state_changed_info */ 10:
                    message.evtAnimatorStateChangedInfo = EvtAnimatorStateChangedInfo.internalBinaryRead(reader, reader.uint32(), options, message.evtAnimatorStateChangedInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtAnimatorStateChangedNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.ForwardType forward_type = 3; */
        if (message.forwardType !== undefined)
            writer.tag(3, WireType.Varint).int32(message.forwardType);
        /* optional com.midnights.game.EvtAnimatorStateChangedInfo evt_animator_state_changed_info = 10; */
        if (message.evtAnimatorStateChangedInfo)
            EvtAnimatorStateChangedInfo.internalBinaryWrite(message.evtAnimatorStateChangedInfo, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtAnimatorStateChangedNotify
 */
export const EvtAnimatorStateChangedNotify = new EvtAnimatorStateChangedNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtRushMoveInfo$Type extends MessageType<EvtRushMoveInfo> {
    constructor() {
        super("com.midnights.game.EvtRushMoveInfo", [
            { no: 11, name: "state_name_hash", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "rush_to_pos", kind: "message", T: () => Vector },
            { no: 8, name: "rush_attack_target_pos", kind: "message", T: () => Vector },
            { no: 4, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "timeRange", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "velocity", kind: "message", T: () => Vector },
            { no: 2, name: "pos", kind: "message", T: () => Vector },
            { no: 10, name: "face_angle_compact", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<EvtRushMoveInfo>): EvtRushMoveInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtRushMoveInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtRushMoveInfo): EvtRushMoveInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 state_name_hash */ 11:
                    message.stateNameHash = reader.int32();
                    break;
                case /* optional com.midnights.game.Vector rush_to_pos */ 9:
                    message.rushToPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.rushToPos);
                    break;
                case /* optional com.midnights.game.Vector rush_attack_target_pos */ 8:
                    message.rushAttackTargetPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.rushAttackTargetPos);
                    break;
                case /* optional uint32 entity_id */ 4:
                    message.entityId = reader.uint32();
                    break;
                case /* optional float timeRange */ 15:
                    message.timeRange = reader.float();
                    break;
                case /* optional com.midnights.game.Vector velocity */ 6:
                    message.velocity = Vector.internalBinaryRead(reader, reader.uint32(), options, message.velocity);
                    break;
                case /* optional com.midnights.game.Vector pos */ 2:
                    message.pos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.pos);
                    break;
                case /* optional int32 face_angle_compact */ 10:
                    message.faceAngleCompact = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtRushMoveInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 state_name_hash = 11; */
        if (message.stateNameHash !== undefined)
            writer.tag(11, WireType.Varint).int32(message.stateNameHash);
        /* optional com.midnights.game.Vector rush_to_pos = 9; */
        if (message.rushToPos)
            Vector.internalBinaryWrite(message.rushToPos, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* optional com.midnights.game.Vector rush_attack_target_pos = 8; */
        if (message.rushAttackTargetPos)
            Vector.internalBinaryWrite(message.rushAttackTargetPos, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 entity_id = 4; */
        if (message.entityId !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.entityId);
        /* optional float timeRange = 15; */
        if (message.timeRange !== undefined)
            writer.tag(15, WireType.Bit32).float(message.timeRange);
        /* optional com.midnights.game.Vector velocity = 6; */
        if (message.velocity)
            Vector.internalBinaryWrite(message.velocity, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional com.midnights.game.Vector pos = 2; */
        if (message.pos)
            Vector.internalBinaryWrite(message.pos, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 face_angle_compact = 10; */
        if (message.faceAngleCompact !== undefined)
            writer.tag(10, WireType.Varint).int32(message.faceAngleCompact);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtRushMoveInfo
 */
export const EvtRushMoveInfo = new EvtRushMoveInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtMotionInfoDuringSteerAttack$Type extends MessageType<EvtMotionInfoDuringSteerAttack> {
    constructor() {
        super("com.midnights.game.EvtMotionInfoDuringSteerAttack", [
            { no: 4, name: "face_dir", kind: "message", T: () => Vector },
            { no: 3, name: "velocity", kind: "message", T: () => Vector },
            { no: 1, name: "pos", kind: "message", T: () => Vector },
            { no: 6, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EvtMotionInfoDuringSteerAttack>): EvtMotionInfoDuringSteerAttack {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtMotionInfoDuringSteerAttack>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtMotionInfoDuringSteerAttack): EvtMotionInfoDuringSteerAttack {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.Vector face_dir */ 4:
                    message.faceDir = Vector.internalBinaryRead(reader, reader.uint32(), options, message.faceDir);
                    break;
                case /* optional com.midnights.game.Vector velocity */ 3:
                    message.velocity = Vector.internalBinaryRead(reader, reader.uint32(), options, message.velocity);
                    break;
                case /* optional com.midnights.game.Vector pos */ 1:
                    message.pos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.pos);
                    break;
                case /* optional uint32 entity_id */ 6:
                    message.entityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtMotionInfoDuringSteerAttack, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.Vector face_dir = 4; */
        if (message.faceDir)
            Vector.internalBinaryWrite(message.faceDir, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional com.midnights.game.Vector velocity = 3; */
        if (message.velocity)
            Vector.internalBinaryWrite(message.velocity, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional com.midnights.game.Vector pos = 1; */
        if (message.pos)
            Vector.internalBinaryWrite(message.pos, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 entity_id = 6; */
        if (message.entityId !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtMotionInfoDuringSteerAttack
 */
export const EvtMotionInfoDuringSteerAttack = new EvtMotionInfoDuringSteerAttack$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtCombatSteerMotionInfo$Type extends MessageType<EvtCombatSteerMotionInfo> {
    constructor() {
        super("com.midnights.game.EvtCombatSteerMotionInfo", [
            { no: 12, name: "pos", kind: "message", T: () => Vector },
            { no: 10, name: "velocity", kind: "message", T: () => Vector },
            { no: 4, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "face_dir", kind: "message", T: () => Vector }
        ]);
    }
    create(value?: PartialMessage<EvtCombatSteerMotionInfo>): EvtCombatSteerMotionInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtCombatSteerMotionInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtCombatSteerMotionInfo): EvtCombatSteerMotionInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.Vector pos */ 12:
                    message.pos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.pos);
                    break;
                case /* optional com.midnights.game.Vector velocity */ 10:
                    message.velocity = Vector.internalBinaryRead(reader, reader.uint32(), options, message.velocity);
                    break;
                case /* optional uint32 entity_id */ 4:
                    message.entityId = reader.uint32();
                    break;
                case /* optional com.midnights.game.Vector face_dir */ 1:
                    message.faceDir = Vector.internalBinaryRead(reader, reader.uint32(), options, message.faceDir);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtCombatSteerMotionInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.Vector pos = 12; */
        if (message.pos)
            Vector.internalBinaryWrite(message.pos, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* optional com.midnights.game.Vector velocity = 10; */
        if (message.velocity)
            Vector.internalBinaryWrite(message.velocity, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 entity_id = 4; */
        if (message.entityId !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.entityId);
        /* optional com.midnights.game.Vector face_dir = 1; */
        if (message.faceDir)
            Vector.internalBinaryWrite(message.faceDir, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtCombatSteerMotionInfo
 */
export const EvtCombatSteerMotionInfo = new EvtCombatSteerMotionInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtCombatForceSetPosInfo$Type extends MessageType<EvtCombatForceSetPosInfo> {
    constructor() {
        super("com.midnights.game.EvtCombatForceSetPosInfo", [
            { no: 9, name: "ice_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "collider_entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "target_pos", kind: "message", T: () => Vector }
        ]);
    }
    create(value?: PartialMessage<EvtCombatForceSetPosInfo>): EvtCombatForceSetPosInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtCombatForceSetPosInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtCombatForceSetPosInfo): EvtCombatForceSetPosInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 ice_id */ 9:
                    message.iceId = reader.uint32();
                    break;
                case /* optional uint32 collider_entity_id */ 10:
                    message.colliderEntityId = reader.uint32();
                    break;
                case /* optional uint32 entity_id */ 6:
                    message.entityId = reader.uint32();
                    break;
                case /* optional com.midnights.game.Vector target_pos */ 1:
                    message.targetPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.targetPos);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtCombatForceSetPosInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 ice_id = 9; */
        if (message.iceId !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.iceId);
        /* optional uint32 collider_entity_id = 10; */
        if (message.colliderEntityId !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.colliderEntityId);
        /* optional uint32 entity_id = 6; */
        if (message.entityId !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.entityId);
        /* optional com.midnights.game.Vector target_pos = 1; */
        if (message.targetPos)
            Vector.internalBinaryWrite(message.targetPos, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtCombatForceSetPosInfo
 */
export const EvtCombatForceSetPosInfo = new EvtCombatForceSetPosInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtSyncEntityPositionInfo$Type extends MessageType<EvtSyncEntityPositionInfo> {
    constructor() {
        super("com.midnights.game.EvtSyncEntityPositionInfo", [
            { no: 10, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "normalized_time_compact", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "state_hash", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "face_angle_compact", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "pos", kind: "message", T: () => Vector }
        ]);
    }
    create(value?: PartialMessage<EvtSyncEntityPositionInfo>): EvtSyncEntityPositionInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtSyncEntityPositionInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtSyncEntityPositionInfo): EvtSyncEntityPositionInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 entity_id */ 10:
                    message.entityId = reader.uint32();
                    break;
                case /* optional uint32 normalized_time_compact */ 13:
                    message.normalizedTimeCompact = reader.uint32();
                    break;
                case /* optional uint32 state_hash */ 8:
                    message.stateHash = reader.uint32();
                    break;
                case /* optional int32 face_angle_compact */ 7:
                    message.faceAngleCompact = reader.int32();
                    break;
                case /* optional com.midnights.game.Vector pos */ 15:
                    message.pos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.pos);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtSyncEntityPositionInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 entity_id = 10; */
        if (message.entityId !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.entityId);
        /* optional uint32 normalized_time_compact = 13; */
        if (message.normalizedTimeCompact !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.normalizedTimeCompact);
        /* optional uint32 state_hash = 8; */
        if (message.stateHash !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.stateHash);
        /* optional int32 face_angle_compact = 7; */
        if (message.faceAngleCompact !== undefined)
            writer.tag(7, WireType.Varint).int32(message.faceAngleCompact);
        /* optional com.midnights.game.Vector pos = 15; */
        if (message.pos)
            Vector.internalBinaryWrite(message.pos, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtSyncEntityPositionInfo
 */
export const EvtSyncEntityPositionInfo = new EvtSyncEntityPositionInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtRushMoveNotify$Type extends MessageType<EvtRushMoveNotify> {
    constructor() {
        super("com.midnights.game.EvtRushMoveNotify", [
            { no: 1, name: "forward_type", kind: "enum", opt: true, T: () => ["com.midnights.game.ForwardType", ForwardType] },
            { no: 15, name: "evt_rush_move_info", kind: "message", T: () => EvtRushMoveInfo }
        ]);
    }
    create(value?: PartialMessage<EvtRushMoveNotify>): EvtRushMoveNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtRushMoveNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtRushMoveNotify): EvtRushMoveNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.ForwardType forward_type */ 1:
                    message.forwardType = reader.int32();
                    break;
                case /* optional com.midnights.game.EvtRushMoveInfo evt_rush_move_info */ 15:
                    message.evtRushMoveInfo = EvtRushMoveInfo.internalBinaryRead(reader, reader.uint32(), options, message.evtRushMoveInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtRushMoveNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.ForwardType forward_type = 1; */
        if (message.forwardType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.forwardType);
        /* optional com.midnights.game.EvtRushMoveInfo evt_rush_move_info = 15; */
        if (message.evtRushMoveInfo)
            EvtRushMoveInfo.internalBinaryWrite(message.evtRushMoveInfo, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtRushMoveNotify
 */
export const EvtRushMoveNotify = new EvtRushMoveNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtBulletHitNotify$Type extends MessageType<EvtBulletHitNotify> {
    constructor() {
        super("com.midnights.game.EvtBulletHitNotify", [
            { no: 8, name: "single_bullet_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "hit_point", kind: "message", T: () => Vector },
            { no: 11, name: "hit_normal", kind: "message", T: () => Vector },
            { no: 9, name: "hit_box_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "hit_entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "forward_peer", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "forward_type", kind: "enum", opt: true, T: () => ["com.midnights.game.ForwardType", ForwardType] },
            { no: 6, name: "hit_collider_type", kind: "enum", opt: true, T: () => ["com.midnights.game.HitColliderType", HitColliderType] }
        ]);
    }
    create(value?: PartialMessage<EvtBulletHitNotify>): EvtBulletHitNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtBulletHitNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtBulletHitNotify): EvtBulletHitNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 single_bullet_id */ 8:
                    message.singleBulletId = reader.uint32();
                    break;
                case /* optional com.midnights.game.Vector hit_point */ 15:
                    message.hitPoint = Vector.internalBinaryRead(reader, reader.uint32(), options, message.hitPoint);
                    break;
                case /* optional com.midnights.game.Vector hit_normal */ 11:
                    message.hitNormal = Vector.internalBinaryRead(reader, reader.uint32(), options, message.hitNormal);
                    break;
                case /* optional int32 hit_box_index */ 9:
                    message.hitBoxIndex = reader.int32();
                    break;
                case /* optional uint32 hit_entity_id */ 3:
                    message.hitEntityId = reader.uint32();
                    break;
                case /* optional uint32 entity_id */ 5:
                    message.entityId = reader.uint32();
                    break;
                case /* optional uint32 forward_peer */ 7:
                    message.forwardPeer = reader.uint32();
                    break;
                case /* optional com.midnights.game.ForwardType forward_type */ 2:
                    message.forwardType = reader.int32();
                    break;
                case /* optional com.midnights.game.HitColliderType hit_collider_type */ 6:
                    message.hitColliderType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtBulletHitNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 single_bullet_id = 8; */
        if (message.singleBulletId !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.singleBulletId);
        /* optional com.midnights.game.Vector hit_point = 15; */
        if (message.hitPoint)
            Vector.internalBinaryWrite(message.hitPoint, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* optional com.midnights.game.Vector hit_normal = 11; */
        if (message.hitNormal)
            Vector.internalBinaryWrite(message.hitNormal, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 hit_box_index = 9; */
        if (message.hitBoxIndex !== undefined)
            writer.tag(9, WireType.Varint).int32(message.hitBoxIndex);
        /* optional uint32 hit_entity_id = 3; */
        if (message.hitEntityId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.hitEntityId);
        /* optional uint32 entity_id = 5; */
        if (message.entityId !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.entityId);
        /* optional uint32 forward_peer = 7; */
        if (message.forwardPeer !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.forwardPeer);
        /* optional com.midnights.game.ForwardType forward_type = 2; */
        if (message.forwardType !== undefined)
            writer.tag(2, WireType.Varint).int32(message.forwardType);
        /* optional com.midnights.game.HitColliderType hit_collider_type = 6; */
        if (message.hitColliderType !== undefined)
            writer.tag(6, WireType.Varint).int32(message.hitColliderType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtBulletHitNotify
 */
export const EvtBulletHitNotify = new EvtBulletHitNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtBulletDeactiveNotify$Type extends MessageType<EvtBulletDeactiveNotify> {
    constructor() {
        super("com.midnights.game.EvtBulletDeactiveNotify", [
            { no: 6, name: "forward_type", kind: "enum", opt: true, T: () => ["com.midnights.game.ForwardType", ForwardType] },
            { no: 9, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "disappear_pos", kind: "message", T: () => Vector }
        ]);
    }
    create(value?: PartialMessage<EvtBulletDeactiveNotify>): EvtBulletDeactiveNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtBulletDeactiveNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtBulletDeactiveNotify): EvtBulletDeactiveNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.ForwardType forward_type */ 6:
                    message.forwardType = reader.int32();
                    break;
                case /* optional uint32 entity_id */ 9:
                    message.entityId = reader.uint32();
                    break;
                case /* optional com.midnights.game.Vector disappear_pos */ 4:
                    message.disappearPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.disappearPos);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtBulletDeactiveNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.ForwardType forward_type = 6; */
        if (message.forwardType !== undefined)
            writer.tag(6, WireType.Varint).int32(message.forwardType);
        /* optional uint32 entity_id = 9; */
        if (message.entityId !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.entityId);
        /* optional com.midnights.game.Vector disappear_pos = 4; */
        if (message.disappearPos)
            Vector.internalBinaryWrite(message.disappearPos, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtBulletDeactiveNotify
 */
export const EvtBulletDeactiveNotify = new EvtBulletDeactiveNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtEntityStartDieEndNotify$Type extends MessageType<EvtEntityStartDieEndNotify> {
    constructor() {
        super("com.midnights.game.EvtEntityStartDieEndNotify", [
            { no: 15, name: "immediately", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "die_state_flag", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "forward_type", kind: "enum", opt: true, T: () => ["com.midnights.game.ForwardType", ForwardType] }
        ]);
    }
    create(value?: PartialMessage<EvtEntityStartDieEndNotify>): EvtEntityStartDieEndNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtEntityStartDieEndNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtEntityStartDieEndNotify): EvtEntityStartDieEndNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool immediately */ 15:
                    message.immediately = reader.bool();
                    break;
                case /* optional uint32 die_state_flag */ 12:
                    message.dieStateFlag = reader.uint32();
                    break;
                case /* optional uint32 entity_id */ 8:
                    message.entityId = reader.uint32();
                    break;
                case /* optional com.midnights.game.ForwardType forward_type */ 11:
                    message.forwardType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtEntityStartDieEndNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool immediately = 15; */
        if (message.immediately !== undefined)
            writer.tag(15, WireType.Varint).bool(message.immediately);
        /* optional uint32 die_state_flag = 12; */
        if (message.dieStateFlag !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.dieStateFlag);
        /* optional uint32 entity_id = 8; */
        if (message.entityId !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.entityId);
        /* optional com.midnights.game.ForwardType forward_type = 11; */
        if (message.forwardType !== undefined)
            writer.tag(11, WireType.Varint).int32(message.forwardType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtEntityStartDieEndNotify
 */
export const EvtEntityStartDieEndNotify = new EvtEntityStartDieEndNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtBulletMoveNotify$Type extends MessageType<EvtBulletMoveNotify> {
    constructor() {
        super("com.midnights.game.EvtBulletMoveNotify", [
            { no: 14, name: "forward_type", kind: "enum", opt: true, T: () => ["com.midnights.game.ForwardType", ForwardType] },
            { no: 1, name: "cur_pos", kind: "message", T: () => Vector },
            { no: 11, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EvtBulletMoveNotify>): EvtBulletMoveNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtBulletMoveNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtBulletMoveNotify): EvtBulletMoveNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.ForwardType forward_type */ 14:
                    message.forwardType = reader.int32();
                    break;
                case /* optional com.midnights.game.Vector cur_pos */ 1:
                    message.curPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.curPos);
                    break;
                case /* optional uint32 entity_id */ 11:
                    message.entityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtBulletMoveNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.ForwardType forward_type = 14; */
        if (message.forwardType !== undefined)
            writer.tag(14, WireType.Varint).int32(message.forwardType);
        /* optional com.midnights.game.Vector cur_pos = 1; */
        if (message.curPos)
            Vector.internalBinaryWrite(message.curPos, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 entity_id = 11; */
        if (message.entityId !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtBulletMoveNotify
 */
export const EvtBulletMoveNotify = new EvtBulletMoveNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtAvatarEnterFocusNotify$Type extends MessageType<EvtAvatarEnterFocusNotify> {
    constructor() {
        super("com.midnights.game.EvtAvatarEnterFocusNotify", [
            { no: 1, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "can_move", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "enter_holding_focus_shoot", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "disable_aim_layer", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "use_auto_focus", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "fast_focus", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "show_cross_hair", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "enter_normal_focus_shoot", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "forward_type", kind: "enum", opt: true, T: () => ["com.midnights.game.ForwardType", ForwardType] },
            { no: 7, name: "focus_forward", kind: "message", T: () => Vector },
            { no: 9, name: "disable_anim", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "use_focus_sticky", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "use_gyro", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<EvtAvatarEnterFocusNotify>): EvtAvatarEnterFocusNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtAvatarEnterFocusNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtAvatarEnterFocusNotify): EvtAvatarEnterFocusNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 entity_id */ 1:
                    message.entityId = reader.uint32();
                    break;
                case /* optional bool can_move */ 10:
                    message.canMove = reader.bool();
                    break;
                case /* optional bool enter_holding_focus_shoot */ 13:
                    message.enterHoldingFocusShoot = reader.bool();
                    break;
                case /* optional bool disable_aim_layer */ 6:
                    message.disableAimLayer = reader.bool();
                    break;
                case /* optional bool use_auto_focus */ 5:
                    message.useAutoFocus = reader.bool();
                    break;
                case /* optional bool fast_focus */ 3:
                    message.fastFocus = reader.bool();
                    break;
                case /* optional bool show_cross_hair */ 12:
                    message.showCrossHair = reader.bool();
                    break;
                case /* optional bool enter_normal_focus_shoot */ 14:
                    message.enterNormalFocusShoot = reader.bool();
                    break;
                case /* optional com.midnights.game.ForwardType forward_type */ 8:
                    message.forwardType = reader.int32();
                    break;
                case /* optional com.midnights.game.Vector focus_forward */ 7:
                    message.focusForward = Vector.internalBinaryRead(reader, reader.uint32(), options, message.focusForward);
                    break;
                case /* optional bool disable_anim */ 9:
                    message.disableAnim = reader.bool();
                    break;
                case /* optional bool use_focus_sticky */ 15:
                    message.useFocusSticky = reader.bool();
                    break;
                case /* optional bool use_gyro */ 11:
                    message.useGyro = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtAvatarEnterFocusNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 entity_id = 1; */
        if (message.entityId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.entityId);
        /* optional bool can_move = 10; */
        if (message.canMove !== undefined)
            writer.tag(10, WireType.Varint).bool(message.canMove);
        /* optional bool enter_holding_focus_shoot = 13; */
        if (message.enterHoldingFocusShoot !== undefined)
            writer.tag(13, WireType.Varint).bool(message.enterHoldingFocusShoot);
        /* optional bool disable_aim_layer = 6; */
        if (message.disableAimLayer !== undefined)
            writer.tag(6, WireType.Varint).bool(message.disableAimLayer);
        /* optional bool use_auto_focus = 5; */
        if (message.useAutoFocus !== undefined)
            writer.tag(5, WireType.Varint).bool(message.useAutoFocus);
        /* optional bool fast_focus = 3; */
        if (message.fastFocus !== undefined)
            writer.tag(3, WireType.Varint).bool(message.fastFocus);
        /* optional bool show_cross_hair = 12; */
        if (message.showCrossHair !== undefined)
            writer.tag(12, WireType.Varint).bool(message.showCrossHair);
        /* optional bool enter_normal_focus_shoot = 14; */
        if (message.enterNormalFocusShoot !== undefined)
            writer.tag(14, WireType.Varint).bool(message.enterNormalFocusShoot);
        /* optional com.midnights.game.ForwardType forward_type = 8; */
        if (message.forwardType !== undefined)
            writer.tag(8, WireType.Varint).int32(message.forwardType);
        /* optional com.midnights.game.Vector focus_forward = 7; */
        if (message.focusForward)
            Vector.internalBinaryWrite(message.focusForward, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* optional bool disable_anim = 9; */
        if (message.disableAnim !== undefined)
            writer.tag(9, WireType.Varint).bool(message.disableAnim);
        /* optional bool use_focus_sticky = 15; */
        if (message.useFocusSticky !== undefined)
            writer.tag(15, WireType.Varint).bool(message.useFocusSticky);
        /* optional bool use_gyro = 11; */
        if (message.useGyro !== undefined)
            writer.tag(11, WireType.Varint).bool(message.useGyro);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtAvatarEnterFocusNotify
 */
export const EvtAvatarEnterFocusNotify = new EvtAvatarEnterFocusNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtAvatarExitFocusNotify$Type extends MessageType<EvtAvatarExitFocusNotify> {
    constructor() {
        super("com.midnights.game.EvtAvatarExitFocusNotify", [
            { no: 12, name: "finish_forward", kind: "message", T: () => Vector },
            { no: 11, name: "forward_type", kind: "enum", opt: true, T: () => ["com.midnights.game.ForwardType", ForwardType] },
            { no: 14, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EvtAvatarExitFocusNotify>): EvtAvatarExitFocusNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtAvatarExitFocusNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtAvatarExitFocusNotify): EvtAvatarExitFocusNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.Vector finish_forward */ 12:
                    message.finishForward = Vector.internalBinaryRead(reader, reader.uint32(), options, message.finishForward);
                    break;
                case /* optional com.midnights.game.ForwardType forward_type */ 11:
                    message.forwardType = reader.int32();
                    break;
                case /* optional uint32 entity_id */ 14:
                    message.entityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtAvatarExitFocusNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.Vector finish_forward = 12; */
        if (message.finishForward)
            Vector.internalBinaryWrite(message.finishForward, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* optional com.midnights.game.ForwardType forward_type = 11; */
        if (message.forwardType !== undefined)
            writer.tag(11, WireType.Varint).int32(message.forwardType);
        /* optional uint32 entity_id = 14; */
        if (message.entityId !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtAvatarExitFocusNotify
 */
export const EvtAvatarExitFocusNotify = new EvtAvatarExitFocusNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtAvatarUpdateFocusNotify$Type extends MessageType<EvtAvatarUpdateFocusNotify> {
    constructor() {
        super("com.midnights.game.EvtAvatarUpdateFocusNotify", [
            { no: 7, name: "forward_type", kind: "enum", opt: true, T: () => ["com.midnights.game.ForwardType", ForwardType] },
            { no: 11, name: "focus_forward", kind: "message", T: () => Vector },
            { no: 10, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EvtAvatarUpdateFocusNotify>): EvtAvatarUpdateFocusNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtAvatarUpdateFocusNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtAvatarUpdateFocusNotify): EvtAvatarUpdateFocusNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.ForwardType forward_type */ 7:
                    message.forwardType = reader.int32();
                    break;
                case /* optional com.midnights.game.Vector focus_forward */ 11:
                    message.focusForward = Vector.internalBinaryRead(reader, reader.uint32(), options, message.focusForward);
                    break;
                case /* optional uint32 entity_id */ 10:
                    message.entityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtAvatarUpdateFocusNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.ForwardType forward_type = 7; */
        if (message.forwardType !== undefined)
            writer.tag(7, WireType.Varint).int32(message.forwardType);
        /* optional com.midnights.game.Vector focus_forward = 11; */
        if (message.focusForward)
            Vector.internalBinaryWrite(message.focusForward, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 entity_id = 10; */
        if (message.entityId !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtAvatarUpdateFocusNotify
 */
export const EvtAvatarUpdateFocusNotify = new EvtAvatarUpdateFocusNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthorityChange$Type extends MessageType<AuthorityChange> {
    constructor() {
        super("com.midnights.game.AuthorityChange", [
            { no: 5, name: "entity_authority_info", kind: "message", T: () => EntityAuthorityInfo },
            { no: 3, name: "authority_peer_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AuthorityChange>): AuthorityChange {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AuthorityChange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthorityChange): AuthorityChange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.EntityAuthorityInfo entity_authority_info */ 5:
                    message.entityAuthorityInfo = EntityAuthorityInfo.internalBinaryRead(reader, reader.uint32(), options, message.entityAuthorityInfo);
                    break;
                case /* optional uint32 authority_peer_id */ 3:
                    message.authorityPeerId = reader.uint32();
                    break;
                case /* optional uint32 entity_id */ 13:
                    message.entityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthorityChange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.EntityAuthorityInfo entity_authority_info = 5; */
        if (message.entityAuthorityInfo)
            EntityAuthorityInfo.internalBinaryWrite(message.entityAuthorityInfo, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 authority_peer_id = 3; */
        if (message.authorityPeerId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.authorityPeerId);
        /* optional uint32 entity_id = 13; */
        if (message.entityId !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.AuthorityChange
 */
export const AuthorityChange = new AuthorityChange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EntityAuthorityChangeNotify$Type extends MessageType<EntityAuthorityChangeNotify> {
    constructor() {
        super("com.midnights.game.EntityAuthorityChangeNotify", [
            { no: 15, name: "authority_change_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AuthorityChange }
        ]);
    }
    create(value?: PartialMessage<EntityAuthorityChangeNotify>): EntityAuthorityChangeNotify {
        const message = { authorityChangeList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EntityAuthorityChangeNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EntityAuthorityChangeNotify): EntityAuthorityChangeNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated com.midnights.game.AuthorityChange authority_change_list */ 15:
                    message.authorityChangeList.push(AuthorityChange.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EntityAuthorityChangeNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated com.midnights.game.AuthorityChange authority_change_list = 15; */
        for (let i = 0; i < message.authorityChangeList.length; i++)
            AuthorityChange.internalBinaryWrite(message.authorityChangeList[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EntityAuthorityChangeNotify
 */
export const EntityAuthorityChangeNotify = new EntityAuthorityChangeNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarBuffAddNotify$Type extends MessageType<AvatarBuffAddNotify> {
    constructor() {
        super("com.midnights.game.AvatarBuffAddNotify", [
            { no: 10, name: "avatar_guid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "buff_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarBuffAddNotify>): AvatarBuffAddNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarBuffAddNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarBuffAddNotify): AvatarBuffAddNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 avatar_guid */ 10:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 buff_id */ 6:
                    message.buffId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarBuffAddNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 avatar_guid = 10; */
        if (message.avatarGuid !== undefined)
            writer.tag(10, WireType.Varint).uint64(message.avatarGuid);
        /* optional uint32 buff_id = 6; */
        if (message.buffId !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.buffId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.AvatarBuffAddNotify
 */
export const AvatarBuffAddNotify = new AvatarBuffAddNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarBuffDelNotify$Type extends MessageType<AvatarBuffDelNotify> {
    constructor() {
        super("com.midnights.game.AvatarBuffDelNotify", [
            { no: 10, name: "avatar_guid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "buff_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarBuffDelNotify>): AvatarBuffDelNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarBuffDelNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarBuffDelNotify): AvatarBuffDelNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 avatar_guid */ 10:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 buff_id */ 12:
                    message.buffId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarBuffDelNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 avatar_guid = 10; */
        if (message.avatarGuid !== undefined)
            writer.tag(10, WireType.Varint).uint64(message.avatarGuid);
        /* optional uint32 buff_id = 12; */
        if (message.buffId !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.buffId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.AvatarBuffDelNotify
 */
export const AvatarBuffDelNotify = new AvatarBuffDelNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MonsterAlertChangeNotify$Type extends MessageType<MonsterAlertChangeNotify> {
    constructor() {
        super("com.midnights.game.MonsterAlertChangeNotify", [
            { no: 15, name: "avatar_entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "monster_entity_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "is_alert", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<MonsterAlertChangeNotify>): MonsterAlertChangeNotify {
        const message = { monsterEntityList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MonsterAlertChangeNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MonsterAlertChangeNotify): MonsterAlertChangeNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 avatar_entity_id */ 15:
                    message.avatarEntityId = reader.uint32();
                    break;
                case /* repeated uint32 monster_entity_list */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.monsterEntityList.push(reader.uint32());
                    else
                        message.monsterEntityList.push(reader.uint32());
                    break;
                case /* optional uint32 is_alert */ 13:
                    message.isAlert = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MonsterAlertChangeNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 avatar_entity_id = 15; */
        if (message.avatarEntityId !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.avatarEntityId);
        /* repeated uint32 monster_entity_list = 5; */
        if (message.monsterEntityList.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.monsterEntityList.length; i++)
                writer.uint32(message.monsterEntityList[i]);
            writer.join();
        }
        /* optional uint32 is_alert = 13; */
        if (message.isAlert !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.isAlert);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.MonsterAlertChangeNotify
 */
export const MonsterAlertChangeNotify = new MonsterAlertChangeNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MonsterForceAlertNotify$Type extends MessageType<MonsterForceAlertNotify> {
    constructor() {
        super("com.midnights.game.MonsterForceAlertNotify", [
            { no: 13, name: "monster_entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<MonsterForceAlertNotify>): MonsterForceAlertNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MonsterForceAlertNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MonsterForceAlertNotify): MonsterForceAlertNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 monster_entity_id */ 13:
                    message.monsterEntityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MonsterForceAlertNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 monster_entity_id = 13; */
        if (message.monsterEntityId !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.monsterEntityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.MonsterForceAlertNotify
 */
export const MonsterForceAlertNotify = new MonsterForceAlertNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarEnterElementViewNotify$Type extends MessageType<AvatarEnterElementViewNotify> {
    constructor() {
        super("com.midnights.game.AvatarEnterElementViewNotify", [
            { no: 3, name: "is_triggerd", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "avatar_entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarEnterElementViewNotify>): AvatarEnterElementViewNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarEnterElementViewNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarEnterElementViewNotify): AvatarEnterElementViewNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool is_triggerd */ 3:
                    message.isTriggerd = reader.bool();
                    break;
                case /* optional uint32 avatar_entity_id */ 12:
                    message.avatarEntityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarEnterElementViewNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool is_triggerd = 3; */
        if (message.isTriggerd !== undefined)
            writer.tag(3, WireType.Varint).bool(message.isTriggerd);
        /* optional uint32 avatar_entity_id = 12; */
        if (message.avatarEntityId !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.avatarEntityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.AvatarEnterElementViewNotify
 */
export const AvatarEnterElementViewNotify = new AvatarEnterElementViewNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TriggerCreateGadgetToEquipPartNotify$Type extends MessageType<TriggerCreateGadgetToEquipPartNotify> {
    constructor() {
        super("com.midnights.game.TriggerCreateGadgetToEquipPartNotify", [
            { no: 1, name: "gadget_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "equip_part", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "gadget_entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TriggerCreateGadgetToEquipPartNotify>): TriggerCreateGadgetToEquipPartNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TriggerCreateGadgetToEquipPartNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TriggerCreateGadgetToEquipPartNotify): TriggerCreateGadgetToEquipPartNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 gadget_id */ 1:
                    message.gadgetId = reader.uint32();
                    break;
                case /* optional uint32 entity_id */ 13:
                    message.entityId = reader.uint32();
                    break;
                case /* optional string equip_part */ 14:
                    message.equipPart = reader.string();
                    break;
                case /* optional uint32 gadget_entity_id */ 10:
                    message.gadgetEntityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TriggerCreateGadgetToEquipPartNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 gadget_id = 1; */
        if (message.gadgetId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.gadgetId);
        /* optional uint32 entity_id = 13; */
        if (message.entityId !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.entityId);
        /* optional string equip_part = 14; */
        if (message.equipPart !== undefined)
            writer.tag(14, WireType.LengthDelimited).string(message.equipPart);
        /* optional uint32 gadget_entity_id = 10; */
        if (message.gadgetEntityId !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.gadgetEntityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.TriggerCreateGadgetToEquipPartNotify
 */
export const TriggerCreateGadgetToEquipPartNotify = new TriggerCreateGadgetToEquipPartNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtEntityRenderersChangedNotify$Type extends MessageType<EvtEntityRenderersChangedNotify> {
    constructor() {
        super("com.midnights.game.EvtEntityRenderersChangedNotify", [
            { no: 8, name: "forward_type", kind: "enum", opt: true, T: () => ["com.midnights.game.ForwardType", ForwardType] },
            { no: 3, name: "is_server_cache", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "renderer_changed_info", kind: "message", T: () => EntityRendererChangedInfo },
            { no: 15, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EvtEntityRenderersChangedNotify>): EvtEntityRenderersChangedNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtEntityRenderersChangedNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtEntityRenderersChangedNotify): EvtEntityRenderersChangedNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.ForwardType forward_type */ 8:
                    message.forwardType = reader.int32();
                    break;
                case /* optional bool is_server_cache */ 3:
                    message.isServerCache = reader.bool();
                    break;
                case /* optional com.midnights.game.EntityRendererChangedInfo renderer_changed_info */ 5:
                    message.rendererChangedInfo = EntityRendererChangedInfo.internalBinaryRead(reader, reader.uint32(), options, message.rendererChangedInfo);
                    break;
                case /* optional uint32 entity_id */ 15:
                    message.entityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtEntityRenderersChangedNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.ForwardType forward_type = 8; */
        if (message.forwardType !== undefined)
            writer.tag(8, WireType.Varint).int32(message.forwardType);
        /* optional bool is_server_cache = 3; */
        if (message.isServerCache !== undefined)
            writer.tag(3, WireType.Varint).bool(message.isServerCache);
        /* optional com.midnights.game.EntityRendererChangedInfo renderer_changed_info = 5; */
        if (message.rendererChangedInfo)
            EntityRendererChangedInfo.internalBinaryWrite(message.rendererChangedInfo, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 entity_id = 15; */
        if (message.entityId !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtEntityRenderersChangedNotify
 */
export const EvtEntityRenderersChangedNotify = new EvtEntityRenderersChangedNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AnimatorForceSetAirMoveNotify$Type extends MessageType<AnimatorForceSetAirMoveNotify> {
    constructor() {
        super("com.midnights.game.AnimatorForceSetAirMoveNotify", [
            { no: 14, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "in_air_move", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "forward_type", kind: "enum", opt: true, T: () => ["com.midnights.game.ForwardType", ForwardType] }
        ]);
    }
    create(value?: PartialMessage<AnimatorForceSetAirMoveNotify>): AnimatorForceSetAirMoveNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AnimatorForceSetAirMoveNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AnimatorForceSetAirMoveNotify): AnimatorForceSetAirMoveNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 entity_id */ 14:
                    message.entityId = reader.uint32();
                    break;
                case /* optional bool in_air_move */ 13:
                    message.inAirMove = reader.bool();
                    break;
                case /* optional com.midnights.game.ForwardType forward_type */ 9:
                    message.forwardType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AnimatorForceSetAirMoveNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 entity_id = 14; */
        if (message.entityId !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.entityId);
        /* optional bool in_air_move = 13; */
        if (message.inAirMove !== undefined)
            writer.tag(13, WireType.Varint).bool(message.inAirMove);
        /* optional com.midnights.game.ForwardType forward_type = 9; */
        if (message.forwardType !== undefined)
            writer.tag(9, WireType.Varint).int32(message.forwardType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.AnimatorForceSetAirMoveNotify
 */
export const AnimatorForceSetAirMoveNotify = new AnimatorForceSetAirMoveNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AiSkillCdInfo$Type extends MessageType<AiSkillCdInfo> {
    constructor() {
        super("com.midnights.game.AiSkillCdInfo", [
            { no: 11, name: "skill_cd_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 6, name: "skill_group_cd_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } }
        ]);
    }
    create(value?: PartialMessage<AiSkillCdInfo>): AiSkillCdInfo {
        const message = { skillCdMap: {}, skillGroupCdMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AiSkillCdInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AiSkillCdInfo): AiSkillCdInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, uint32> skill_cd_map */ 11:
                    this.binaryReadMap11(message.skillCdMap, reader, options);
                    break;
                case /* map<uint32, uint32> skill_group_cd_map */ 6:
                    this.binaryReadMap6(message.skillGroupCdMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap11(map: AiSkillCdInfo["skillCdMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AiSkillCdInfo["skillCdMap"] | undefined, val: AiSkillCdInfo["skillCdMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field com.midnights.game.AiSkillCdInfo.skill_cd_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap6(map: AiSkillCdInfo["skillGroupCdMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AiSkillCdInfo["skillGroupCdMap"] | undefined, val: AiSkillCdInfo["skillGroupCdMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field com.midnights.game.AiSkillCdInfo.skill_group_cd_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: AiSkillCdInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, uint32> skill_cd_map = 11; */
        for (let k of Object.keys(message.skillCdMap))
            writer.tag(11, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.skillCdMap[k as any]).join();
        /* map<uint32, uint32> skill_group_cd_map = 6; */
        for (let k of Object.keys(message.skillGroupCdMap))
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.skillGroupCdMap[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.AiSkillCdInfo
 */
export const AiSkillCdInfo = new AiSkillCdInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtAiSyncSkillCdNotify$Type extends MessageType<EvtAiSyncSkillCdNotify> {
    constructor() {
        super("com.midnights.game.EvtAiSyncSkillCdNotify", [
            { no: 7, name: "ai_cd_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => AiSkillCdInfo } }
        ]);
    }
    create(value?: PartialMessage<EvtAiSyncSkillCdNotify>): EvtAiSyncSkillCdNotify {
        const message = { aiCdMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtAiSyncSkillCdNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtAiSyncSkillCdNotify): EvtAiSyncSkillCdNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, com.midnights.game.AiSkillCdInfo> ai_cd_map */ 7:
                    this.binaryReadMap7(message.aiCdMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap7(map: EvtAiSyncSkillCdNotify["aiCdMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof EvtAiSyncSkillCdNotify["aiCdMap"] | undefined, val: EvtAiSyncSkillCdNotify["aiCdMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = AiSkillCdInfo.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field com.midnights.game.EvtAiSyncSkillCdNotify.ai_cd_map");
            }
        }
        map[key ?? 0] = val ?? AiSkillCdInfo.create();
    }
    internalBinaryWrite(message: EvtAiSyncSkillCdNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, com.midnights.game.AiSkillCdInfo> ai_cd_map = 7; */
        for (let k of Object.keys(message.aiCdMap)) {
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            AiSkillCdInfo.internalBinaryWrite(message.aiCdMap[k as any], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtAiSyncSkillCdNotify
 */
export const EvtAiSyncSkillCdNotify = new EvtAiSyncSkillCdNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtBeingHitsCombineNotify$Type extends MessageType<EvtBeingHitsCombineNotify> {
    constructor() {
        super("com.midnights.game.EvtBeingHitsCombineNotify", [
            { no: 11, name: "forward_type", kind: "enum", opt: true, T: () => ["com.midnights.game.ForwardType", ForwardType] },
            { no: 7, name: "evt_being_hit_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EvtBeingHitInfo }
        ]);
    }
    create(value?: PartialMessage<EvtBeingHitsCombineNotify>): EvtBeingHitsCombineNotify {
        const message = { evtBeingHitInfoList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtBeingHitsCombineNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtBeingHitsCombineNotify): EvtBeingHitsCombineNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.ForwardType forward_type */ 11:
                    message.forwardType = reader.int32();
                    break;
                case /* repeated com.midnights.game.EvtBeingHitInfo evt_being_hit_info_list */ 7:
                    message.evtBeingHitInfoList.push(EvtBeingHitInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtBeingHitsCombineNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.ForwardType forward_type = 11; */
        if (message.forwardType !== undefined)
            writer.tag(11, WireType.Varint).int32(message.forwardType);
        /* repeated com.midnights.game.EvtBeingHitInfo evt_being_hit_info_list = 7; */
        for (let i = 0; i < message.evtBeingHitInfoList.length; i++)
            EvtBeingHitInfo.internalBinaryWrite(message.evtBeingHitInfoList[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtBeingHitsCombineNotify
 */
export const EvtBeingHitsCombineNotify = new EvtBeingHitsCombineNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtAvatarSitDownNotify$Type extends MessageType<EvtAvatarSitDownNotify> {
    constructor() {
        super("com.midnights.game.EvtAvatarSitDownNotify", [
            { no: 9, name: "position", kind: "message", T: () => Vector },
            { no: 4, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "chair_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<EvtAvatarSitDownNotify>): EvtAvatarSitDownNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtAvatarSitDownNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtAvatarSitDownNotify): EvtAvatarSitDownNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.Vector position */ 9:
                    message.position = Vector.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* optional uint32 entity_id */ 4:
                    message.entityId = reader.uint32();
                    break;
                case /* optional uint64 chair_id */ 6:
                    message.chairId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtAvatarSitDownNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.Vector position = 9; */
        if (message.position)
            Vector.internalBinaryWrite(message.position, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 entity_id = 4; */
        if (message.entityId !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.entityId);
        /* optional uint64 chair_id = 6; */
        if (message.chairId !== undefined)
            writer.tag(6, WireType.Varint).uint64(message.chairId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtAvatarSitDownNotify
 */
export const EvtAvatarSitDownNotify = new EvtAvatarSitDownNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtAvatarStandUpNotify$Type extends MessageType<EvtAvatarStandUpNotify> {
    constructor() {
        super("com.midnights.game.EvtAvatarStandUpNotify", [
            { no: 11, name: "chair_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "performID", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 1, name: "direction", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EvtAvatarStandUpNotify>): EvtAvatarStandUpNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtAvatarStandUpNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtAvatarStandUpNotify): EvtAvatarStandUpNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 chair_id */ 11:
                    message.chairId = reader.uint64().toBigInt();
                    break;
                case /* optional int32 performID */ 6:
                    message.performID = reader.int32();
                    break;
                case /* optional int32 direction */ 1:
                    message.direction = reader.int32();
                    break;
                case /* optional uint32 entity_id */ 9:
                    message.entityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtAvatarStandUpNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 chair_id = 11; */
        if (message.chairId !== undefined)
            writer.tag(11, WireType.Varint).uint64(message.chairId);
        /* optional int32 performID = 6; */
        if (message.performID !== undefined)
            writer.tag(6, WireType.Varint).int32(message.performID);
        /* optional int32 direction = 1; */
        if (message.direction !== undefined)
            writer.tag(1, WireType.Varint).int32(message.direction);
        /* optional uint32 entity_id = 9; */
        if (message.entityId !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtAvatarStandUpNotify
 */
export const EvtAvatarStandUpNotify = new EvtAvatarStandUpNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateMassiveEntityReq$Type extends MessageType<CreateMassiveEntityReq> {
    constructor() {
        super("com.midnights.game.CreateMassiveEntityReq", [
            { no: 1, name: "massive_entity_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ClientMassiveEntity }
        ]);
    }
    create(value?: PartialMessage<CreateMassiveEntityReq>): CreateMassiveEntityReq {
        const message = { massiveEntityList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreateMassiveEntityReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateMassiveEntityReq): CreateMassiveEntityReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated com.midnights.game.ClientMassiveEntity massive_entity_list */ 1:
                    message.massiveEntityList.push(ClientMassiveEntity.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateMassiveEntityReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated com.midnights.game.ClientMassiveEntity massive_entity_list = 1; */
        for (let i = 0; i < message.massiveEntityList.length; i++)
            ClientMassiveEntity.internalBinaryWrite(message.massiveEntityList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.CreateMassiveEntityReq
 */
export const CreateMassiveEntityReq = new CreateMassiveEntityReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateMassiveEntityRsp$Type extends MessageType<CreateMassiveEntityRsp> {
    constructor() {
        super("com.midnights.game.CreateMassiveEntityRsp", [
            { no: 1, name: "retcode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CreateMassiveEntityRsp>): CreateMassiveEntityRsp {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreateMassiveEntityRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateMassiveEntityRsp): CreateMassiveEntityRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 retcode */ 1:
                    message.retcode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateMassiveEntityRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 retcode = 1; */
        if (message.retcode !== undefined)
            writer.tag(1, WireType.Varint).int32(message.retcode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.CreateMassiveEntityRsp
 */
export const CreateMassiveEntityRsp = new CreateMassiveEntityRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateMassiveEntityNotify$Type extends MessageType<CreateMassiveEntityNotify> {
    constructor() {
        super("com.midnights.game.CreateMassiveEntityNotify", [
            { no: 15, name: "massive_entity_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ServerMassiveEntity }
        ]);
    }
    create(value?: PartialMessage<CreateMassiveEntityNotify>): CreateMassiveEntityNotify {
        const message = { massiveEntityList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreateMassiveEntityNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateMassiveEntityNotify): CreateMassiveEntityNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated com.midnights.game.ServerMassiveEntity massive_entity_list */ 15:
                    message.massiveEntityList.push(ServerMassiveEntity.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateMassiveEntityNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated com.midnights.game.ServerMassiveEntity massive_entity_list = 15; */
        for (let i = 0; i < message.massiveEntityList.length; i++)
            ServerMassiveEntity.internalBinaryWrite(message.massiveEntityList[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.CreateMassiveEntityNotify
 */
export const CreateMassiveEntityNotify = new CreateMassiveEntityNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DestroyMassiveEntityNotify$Type extends MessageType<DestroyMassiveEntityNotify> {
    constructor() {
        super("com.midnights.game.DestroyMassiveEntityNotify", [
            { no: 7, name: "massive_entity_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ClientMassiveEntity }
        ]);
    }
    create(value?: PartialMessage<DestroyMassiveEntityNotify>): DestroyMassiveEntityNotify {
        const message = { massiveEntityList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DestroyMassiveEntityNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DestroyMassiveEntityNotify): DestroyMassiveEntityNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated com.midnights.game.ClientMassiveEntity massive_entity_list */ 7:
                    message.massiveEntityList.push(ClientMassiveEntity.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DestroyMassiveEntityNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated com.midnights.game.ClientMassiveEntity massive_entity_list = 7; */
        for (let i = 0; i < message.massiveEntityList.length; i++)
            ClientMassiveEntity.internalBinaryWrite(message.massiveEntityList[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.DestroyMassiveEntityNotify
 */
export const DestroyMassiveEntityNotify = new DestroyMassiveEntityNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MassiveEntityStateChangedNotify$Type extends MessageType<MassiveEntityStateChangedNotify> {
    constructor() {
        super("com.midnights.game.MassiveEntityStateChangedNotify", [
            { no: 4, name: "massive_entity_state_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MassiveEntityState }
        ]);
    }
    create(value?: PartialMessage<MassiveEntityStateChangedNotify>): MassiveEntityStateChangedNotify {
        const message = { massiveEntityStateList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MassiveEntityStateChangedNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MassiveEntityStateChangedNotify): MassiveEntityStateChangedNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated com.midnights.game.MassiveEntityState massive_entity_state_list */ 4:
                    message.massiveEntityStateList.push(MassiveEntityState.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MassiveEntityStateChangedNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated com.midnights.game.MassiveEntityState massive_entity_state_list = 4; */
        for (let i = 0; i < message.massiveEntityStateList.length; i++)
            MassiveEntityState.internalBinaryWrite(message.massiveEntityStateList[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.MassiveEntityStateChangedNotify
 */
export const MassiveEntityStateChangedNotify = new MassiveEntityStateChangedNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeamEntityInfo$Type extends MessageType<TeamEntityInfo> {
    constructor() {
        super("com.midnights.game.TeamEntityInfo", [
            { no: 10, name: "authority_peer_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "team_ability_info", kind: "message", T: () => AbilitySyncStateInfo },
            { no: 8, name: "team_entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TeamEntityInfo>): TeamEntityInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TeamEntityInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeamEntityInfo): TeamEntityInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 authority_peer_id */ 10:
                    message.authorityPeerId = reader.uint32();
                    break;
                case /* optional com.midnights.game.AbilitySyncStateInfo team_ability_info */ 9:
                    message.teamAbilityInfo = AbilitySyncStateInfo.internalBinaryRead(reader, reader.uint32(), options, message.teamAbilityInfo);
                    break;
                case /* optional uint32 team_entity_id */ 8:
                    message.teamEntityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeamEntityInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 authority_peer_id = 10; */
        if (message.authorityPeerId !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.authorityPeerId);
        /* optional com.midnights.game.AbilitySyncStateInfo team_ability_info = 9; */
        if (message.teamAbilityInfo)
            AbilitySyncStateInfo.internalBinaryWrite(message.teamAbilityInfo, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 team_entity_id = 8; */
        if (message.teamEntityId !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.teamEntityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.TeamEntityInfo
 */
export const TeamEntityInfo = new TeamEntityInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SyncTeamEntityNotify$Type extends MessageType<SyncTeamEntityNotify> {
    constructor() {
        super("com.midnights.game.SyncTeamEntityNotify", [
            { no: 13, name: "scene_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "team_entity_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TeamEntityInfo }
        ]);
    }
    create(value?: PartialMessage<SyncTeamEntityNotify>): SyncTeamEntityNotify {
        const message = { teamEntityInfoList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SyncTeamEntityNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SyncTeamEntityNotify): SyncTeamEntityNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 scene_id */ 13:
                    message.sceneId = reader.uint32();
                    break;
                case /* repeated com.midnights.game.TeamEntityInfo team_entity_info_list */ 15:
                    message.teamEntityInfoList.push(TeamEntityInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SyncTeamEntityNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 scene_id = 13; */
        if (message.sceneId !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.sceneId);
        /* repeated com.midnights.game.TeamEntityInfo team_entity_info_list = 15; */
        for (let i = 0; i < message.teamEntityInfoList.length; i++)
            TeamEntityInfo.internalBinaryWrite(message.teamEntityInfoList[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.SyncTeamEntityNotify
 */
export const SyncTeamEntityNotify = new SyncTeamEntityNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DelTeamEntityNotify$Type extends MessageType<DelTeamEntityNotify> {
    constructor() {
        super("com.midnights.game.DelTeamEntityNotify", [
            { no: 15, name: "del_entity_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "scene_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<DelTeamEntityNotify>): DelTeamEntityNotify {
        const message = { delEntityIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DelTeamEntityNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DelTeamEntityNotify): DelTeamEntityNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 del_entity_id_list */ 15:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.delEntityIdList.push(reader.uint32());
                    else
                        message.delEntityIdList.push(reader.uint32());
                    break;
                case /* optional uint32 scene_id */ 8:
                    message.sceneId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DelTeamEntityNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 del_entity_id_list = 15; */
        if (message.delEntityIdList.length) {
            writer.tag(15, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.delEntityIdList.length; i++)
                writer.uint32(message.delEntityIdList[i]);
            writer.join();
        }
        /* optional uint32 scene_id = 8; */
        if (message.sceneId !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.sceneId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.DelTeamEntityNotify
 */
export const DelTeamEntityNotify = new DelTeamEntityNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtSyncSkillAnchorPosition$Type extends MessageType<EvtSyncSkillAnchorPosition> {
    constructor() {
        super("com.midnights.game.EvtSyncSkillAnchorPosition", [
            { no: 2, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "skill_anchor_position", kind: "message", T: () => Vector }
        ]);
    }
    create(value?: PartialMessage<EvtSyncSkillAnchorPosition>): EvtSyncSkillAnchorPosition {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtSyncSkillAnchorPosition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtSyncSkillAnchorPosition): EvtSyncSkillAnchorPosition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 entity_id */ 2:
                    message.entityId = reader.uint32();
                    break;
                case /* optional com.midnights.game.Vector skill_anchor_position */ 13:
                    message.skillAnchorPosition = Vector.internalBinaryRead(reader, reader.uint32(), options, message.skillAnchorPosition);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtSyncSkillAnchorPosition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 entity_id = 2; */
        if (message.entityId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.entityId);
        /* optional com.midnights.game.Vector skill_anchor_position = 13; */
        if (message.skillAnchorPosition)
            Vector.internalBinaryWrite(message.skillAnchorPosition, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtSyncSkillAnchorPosition
 */
export const EvtSyncSkillAnchorPosition = new EvtSyncSkillAnchorPosition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CombatInvokeEntry$Type extends MessageType<CombatInvokeEntry> {
    constructor() {
        super("com.midnights.game.CombatInvokeEntry", [
            { no: 12, name: "combat_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 10, name: "forward_type", kind: "enum", opt: true, T: () => ["com.midnights.game.ForwardType", ForwardType] },
            { no: 11, name: "argument_type", kind: "enum", opt: true, T: () => ["com.midnights.game.CombatTypeArgument", CombatTypeArgument] }
        ]);
    }
    create(value?: PartialMessage<CombatInvokeEntry>): CombatInvokeEntry {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CombatInvokeEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CombatInvokeEntry): CombatInvokeEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes combat_data */ 12:
                    message.combatData = reader.bytes();
                    break;
                case /* optional com.midnights.game.ForwardType forward_type */ 10:
                    message.forwardType = reader.int32();
                    break;
                case /* optional com.midnights.game.CombatTypeArgument argument_type */ 11:
                    message.argumentType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CombatInvokeEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes combat_data = 12; */
        if (message.combatData !== undefined)
            writer.tag(12, WireType.LengthDelimited).bytes(message.combatData);
        /* optional com.midnights.game.ForwardType forward_type = 10; */
        if (message.forwardType !== undefined)
            writer.tag(10, WireType.Varint).int32(message.forwardType);
        /* optional com.midnights.game.CombatTypeArgument argument_type = 11; */
        if (message.argumentType !== undefined)
            writer.tag(11, WireType.Varint).int32(message.argumentType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.CombatInvokeEntry
 */
export const CombatInvokeEntry = new CombatInvokeEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CombatInvocationsNotify$Type extends MessageType<CombatInvocationsNotify> {
    constructor() {
        super("com.midnights.game.CombatInvocationsNotify", [
            { no: 14, name: "invoke_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CombatInvokeEntry }
        ]);
    }
    create(value?: PartialMessage<CombatInvocationsNotify>): CombatInvocationsNotify {
        const message = { invokeList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CombatInvocationsNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CombatInvocationsNotify): CombatInvocationsNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated com.midnights.game.CombatInvokeEntry invoke_list */ 14:
                    message.invokeList.push(CombatInvokeEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CombatInvocationsNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated com.midnights.game.CombatInvokeEntry invoke_list = 14; */
        for (let i = 0; i < message.invokeList.length; i++)
            CombatInvokeEntry.internalBinaryWrite(message.invokeList[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.CombatInvocationsNotify
 */
export const CombatInvocationsNotify = new CombatInvocationsNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServerBuffChangeNotify$Type extends MessageType<ServerBuffChangeNotify> {
    constructor() {
        super("com.midnights.game.ServerBuffChangeNotify", [
            { no: 7, name: "server_buff_change_type", kind: "enum", opt: true, T: () => ["com.midnights.game.ServerBuffChangeNotify.ServerBuffChangeType", ServerBuffChangeNotify_ServerBuffChangeType] },
            { no: 10, name: "is_creature_buff", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 1, name: "entity_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "avatar_guid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "server_buff_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ServerBuff }
        ]);
    }
    create(value?: PartialMessage<ServerBuffChangeNotify>): ServerBuffChangeNotify {
        const message = { entityIdList: [], avatarGuidList: [], serverBuffList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ServerBuffChangeNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServerBuffChangeNotify): ServerBuffChangeNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional com.midnights.game.ServerBuffChangeNotify.ServerBuffChangeType server_buff_change_type */ 7:
                    message.serverBuffChangeType = reader.int32();
                    break;
                case /* optional bool is_creature_buff */ 10:
                    message.isCreatureBuff = reader.bool();
                    break;
                case /* repeated uint32 entity_id_list */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.entityIdList.push(reader.uint32());
                    else
                        message.entityIdList.push(reader.uint32());
                    break;
                case /* repeated uint64 avatar_guid_list */ 12:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.avatarGuidList.push(reader.uint64().toBigInt());
                    else
                        message.avatarGuidList.push(reader.uint64().toBigInt());
                    break;
                case /* repeated com.midnights.game.ServerBuff server_buff_list */ 11:
                    message.serverBuffList.push(ServerBuff.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServerBuffChangeNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional com.midnights.game.ServerBuffChangeNotify.ServerBuffChangeType server_buff_change_type = 7; */
        if (message.serverBuffChangeType !== undefined)
            writer.tag(7, WireType.Varint).int32(message.serverBuffChangeType);
        /* optional bool is_creature_buff = 10; */
        if (message.isCreatureBuff !== undefined)
            writer.tag(10, WireType.Varint).bool(message.isCreatureBuff);
        /* repeated uint32 entity_id_list = 1; */
        if (message.entityIdList.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.entityIdList.length; i++)
                writer.uint32(message.entityIdList[i]);
            writer.join();
        }
        /* repeated uint64 avatar_guid_list = 12; */
        if (message.avatarGuidList.length) {
            writer.tag(12, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.avatarGuidList.length; i++)
                writer.uint64(message.avatarGuidList[i]);
            writer.join();
        }
        /* repeated com.midnights.game.ServerBuff server_buff_list = 11; */
        for (let i = 0; i < message.serverBuffList.length; i++)
            ServerBuff.internalBinaryWrite(message.serverBuffList[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.ServerBuffChangeNotify
 */
export const ServerBuffChangeNotify = new ServerBuffChangeNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AiThreatInfo$Type extends MessageType<AiThreatInfo> {
    constructor() {
        super("com.midnights.game.AiThreatInfo", [
            { no: 11, name: "ai_threat_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } }
        ]);
    }
    create(value?: PartialMessage<AiThreatInfo>): AiThreatInfo {
        const message = { aiThreatMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AiThreatInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AiThreatInfo): AiThreatInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, uint32> ai_threat_map */ 11:
                    this.binaryReadMap11(message.aiThreatMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap11(map: AiThreatInfo["aiThreatMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AiThreatInfo["aiThreatMap"] | undefined, val: AiThreatInfo["aiThreatMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field com.midnights.game.AiThreatInfo.ai_threat_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: AiThreatInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, uint32> ai_threat_map = 11; */
        for (let k of Object.keys(message.aiThreatMap))
            writer.tag(11, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.aiThreatMap[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.AiThreatInfo
 */
export const AiThreatInfo = new AiThreatInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtAiSyncCombatThreatInfoNotify$Type extends MessageType<EvtAiSyncCombatThreatInfoNotify> {
    constructor() {
        super("com.midnights.game.EvtAiSyncCombatThreatInfoNotify", [
            { no: 8, name: "combat_threat_info_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => AiThreatInfo } }
        ]);
    }
    create(value?: PartialMessage<EvtAiSyncCombatThreatInfoNotify>): EvtAiSyncCombatThreatInfoNotify {
        const message = { combatThreatInfoMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtAiSyncCombatThreatInfoNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtAiSyncCombatThreatInfoNotify): EvtAiSyncCombatThreatInfoNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, com.midnights.game.AiThreatInfo> combat_threat_info_map */ 8:
                    this.binaryReadMap8(message.combatThreatInfoMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap8(map: EvtAiSyncCombatThreatInfoNotify["combatThreatInfoMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof EvtAiSyncCombatThreatInfoNotify["combatThreatInfoMap"] | undefined, val: EvtAiSyncCombatThreatInfoNotify["combatThreatInfoMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = AiThreatInfo.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field com.midnights.game.EvtAiSyncCombatThreatInfoNotify.combat_threat_info_map");
            }
        }
        map[key ?? 0] = val ?? AiThreatInfo.create();
    }
    internalBinaryWrite(message: EvtAiSyncCombatThreatInfoNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, com.midnights.game.AiThreatInfo> combat_threat_info_map = 8; */
        for (let k of Object.keys(message.combatThreatInfoMap)) {
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            AiThreatInfo.internalBinaryWrite(message.combatThreatInfoMap[k as any], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtAiSyncCombatThreatInfoNotify
 */
export const EvtAiSyncCombatThreatInfoNotify = new EvtAiSyncCombatThreatInfoNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MassiveEntityElementOpBatchNotify$Type extends MessageType<MassiveEntityElementOpBatchNotify> {
    constructor() {
        super("com.midnights.game.MassiveEntityElementOpBatchNotify", [
            { no: 6, name: "entity_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "op_idx", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "user_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "attacker_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "source_element_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "reaction_source_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "attack_element_durability", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "shape_sphere", kind: "message", oneof: "checkShape", T: () => ShapeSphere },
            { no: 2, name: "shape_box", kind: "message", oneof: "checkShape", T: () => ShapeBox }
        ]);
    }
    create(value?: PartialMessage<MassiveEntityElementOpBatchNotify>): MassiveEntityElementOpBatchNotify {
        const message = { checkShape: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MassiveEntityElementOpBatchNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MassiveEntityElementOpBatchNotify): MassiveEntityElementOpBatchNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 entity_type */ 6:
                    message.entityType = reader.int32();
                    break;
                case /* optional uint32 op_idx */ 9:
                    message.opIdx = reader.uint32();
                    break;
                case /* optional uint32 user_id */ 11:
                    message.userId = reader.uint32();
                    break;
                case /* optional uint32 attacker_id */ 3:
                    message.attackerId = reader.uint32();
                    break;
                case /* optional int32 source_element_type */ 12:
                    message.sourceElementType = reader.int32();
                    break;
                case /* optional int32 reaction_source_type */ 4:
                    message.reactionSourceType = reader.int32();
                    break;
                case /* optional float attack_element_durability */ 7:
                    message.attackElementDurability = reader.float();
                    break;
                case /* com.midnights.game.ShapeSphere shape_sphere */ 10:
                    message.checkShape = {
                        oneofKind: "shapeSphere",
                        shapeSphere: ShapeSphere.internalBinaryRead(reader, reader.uint32(), options, (message.checkShape as any).shapeSphere)
                    };
                    break;
                case /* com.midnights.game.ShapeBox shape_box */ 2:
                    message.checkShape = {
                        oneofKind: "shapeBox",
                        shapeBox: ShapeBox.internalBinaryRead(reader, reader.uint32(), options, (message.checkShape as any).shapeBox)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MassiveEntityElementOpBatchNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 entity_type = 6; */
        if (message.entityType !== undefined)
            writer.tag(6, WireType.Varint).int32(message.entityType);
        /* optional uint32 op_idx = 9; */
        if (message.opIdx !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.opIdx);
        /* optional uint32 user_id = 11; */
        if (message.userId !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.userId);
        /* optional uint32 attacker_id = 3; */
        if (message.attackerId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.attackerId);
        /* optional int32 source_element_type = 12; */
        if (message.sourceElementType !== undefined)
            writer.tag(12, WireType.Varint).int32(message.sourceElementType);
        /* optional int32 reaction_source_type = 4; */
        if (message.reactionSourceType !== undefined)
            writer.tag(4, WireType.Varint).int32(message.reactionSourceType);
        /* optional float attack_element_durability = 7; */
        if (message.attackElementDurability !== undefined)
            writer.tag(7, WireType.Bit32).float(message.attackElementDurability);
        /* com.midnights.game.ShapeSphere shape_sphere = 10; */
        if (message.checkShape.oneofKind === "shapeSphere")
            ShapeSphere.internalBinaryWrite(message.checkShape.shapeSphere, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* com.midnights.game.ShapeBox shape_box = 2; */
        if (message.checkShape.oneofKind === "shapeBox")
            ShapeBox.internalBinaryWrite(message.checkShape.shapeBox, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.MassiveEntityElementOpBatchNotify
 */
export const MassiveEntityElementOpBatchNotify = new MassiveEntityElementOpBatchNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AiSyncInfo$Type extends MessageType<AiSyncInfo> {
    constructor() {
        super("com.midnights.game.AiSyncInfo", [
            { no: 9, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "is_self_killing", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "has_path_to_target", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AiSyncInfo>): AiSyncInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AiSyncInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AiSyncInfo): AiSyncInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 entity_id */ 9:
                    message.entityId = reader.uint32();
                    break;
                case /* optional bool is_self_killing */ 8:
                    message.isSelfKilling = reader.bool();
                    break;
                case /* optional bool has_path_to_target */ 4:
                    message.hasPathToTarget = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AiSyncInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 entity_id = 9; */
        if (message.entityId !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.entityId);
        /* optional bool is_self_killing = 8; */
        if (message.isSelfKilling !== undefined)
            writer.tag(8, WireType.Varint).bool(message.isSelfKilling);
        /* optional bool has_path_to_target = 4; */
        if (message.hasPathToTarget !== undefined)
            writer.tag(4, WireType.Varint).bool(message.hasPathToTarget);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.AiSyncInfo
 */
export const AiSyncInfo = new AiSyncInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EntityAiSyncNotify$Type extends MessageType<EntityAiSyncNotify> {
    constructor() {
        super("com.midnights.game.EntityAiSyncNotify", [
            { no: 15, name: "local_avatar_alerted_monster_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AiSyncInfo }
        ]);
    }
    create(value?: PartialMessage<EntityAiSyncNotify>): EntityAiSyncNotify {
        const message = { localAvatarAlertedMonsterList: [], infoList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EntityAiSyncNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EntityAiSyncNotify): EntityAiSyncNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 local_avatar_alerted_monster_list */ 15:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.localAvatarAlertedMonsterList.push(reader.uint32());
                    else
                        message.localAvatarAlertedMonsterList.push(reader.uint32());
                    break;
                case /* repeated com.midnights.game.AiSyncInfo info_list */ 1:
                    message.infoList.push(AiSyncInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EntityAiSyncNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 local_avatar_alerted_monster_list = 15; */
        if (message.localAvatarAlertedMonsterList.length) {
            writer.tag(15, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.localAvatarAlertedMonsterList.length; i++)
                writer.uint32(message.localAvatarAlertedMonsterList[i]);
            writer.join();
        }
        /* repeated com.midnights.game.AiSyncInfo info_list = 1; */
        for (let i = 0; i < message.infoList.length; i++)
            AiSyncInfo.internalBinaryWrite(message.infoList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EntityAiSyncNotify
 */
export const EntityAiSyncNotify = new EntityAiSyncNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LuaSetOptionNotify$Type extends MessageType<LuaSetOptionNotify> {
    constructor() {
        super("com.midnights.game.LuaSetOptionNotify", [
            { no: 8, name: "lua_set_param", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "option_type", kind: "enum", opt: true, T: () => ["com.midnights.game.LuaSetOptionNotify.LuaOptionType", LuaSetOptionNotify_LuaOptionType] }
        ]);
    }
    create(value?: PartialMessage<LuaSetOptionNotify>): LuaSetOptionNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LuaSetOptionNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LuaSetOptionNotify): LuaSetOptionNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string lua_set_param */ 8:
                    message.luaSetParam = reader.string();
                    break;
                case /* optional com.midnights.game.LuaSetOptionNotify.LuaOptionType option_type */ 10:
                    message.optionType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LuaSetOptionNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string lua_set_param = 8; */
        if (message.luaSetParam !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.luaSetParam);
        /* optional com.midnights.game.LuaSetOptionNotify.LuaOptionType option_type = 10; */
        if (message.optionType !== undefined)
            writer.tag(10, WireType.Varint).int32(message.optionType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.LuaSetOptionNotify
 */
export const LuaSetOptionNotify = new LuaSetOptionNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtDestroyServerGadgetNotify$Type extends MessageType<EvtDestroyServerGadgetNotify> {
    constructor() {
        super("com.midnights.game.EvtDestroyServerGadgetNotify", [
            { no: 7, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EvtDestroyServerGadgetNotify>): EvtDestroyServerGadgetNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtDestroyServerGadgetNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtDestroyServerGadgetNotify): EvtDestroyServerGadgetNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 entity_id */ 7:
                    message.entityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtDestroyServerGadgetNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 entity_id = 7; */
        if (message.entityId !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtDestroyServerGadgetNotify
 */
export const EvtDestroyServerGadgetNotify = new EvtDestroyServerGadgetNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EntityAiKillSelfNotify$Type extends MessageType<EntityAiKillSelfNotify> {
    constructor() {
        super("com.midnights.game.EntityAiKillSelfNotify", [
            { no: 12, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EntityAiKillSelfNotify>): EntityAiKillSelfNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EntityAiKillSelfNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EntityAiKillSelfNotify): EntityAiKillSelfNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 entity_id */ 12:
                    message.entityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EntityAiKillSelfNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 entity_id = 12; */
        if (message.entityId !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EntityAiKillSelfNotify
 */
export const EntityAiKillSelfNotify = new EntityAiKillSelfNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtAvatarLockChairReq$Type extends MessageType<EvtAvatarLockChairReq> {
    constructor() {
        super("com.midnights.game.EvtAvatarLockChairReq", [
            { no: 5, name: "chair_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "position", kind: "message", T: () => Vector }
        ]);
    }
    create(value?: PartialMessage<EvtAvatarLockChairReq>): EvtAvatarLockChairReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtAvatarLockChairReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtAvatarLockChairReq): EvtAvatarLockChairReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 chair_id */ 5:
                    message.chairId = reader.uint64().toBigInt();
                    break;
                case /* optional com.midnights.game.Vector position */ 8:
                    message.position = Vector.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtAvatarLockChairReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 chair_id = 5; */
        if (message.chairId !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.chairId);
        /* optional com.midnights.game.Vector position = 8; */
        if (message.position)
            Vector.internalBinaryWrite(message.position, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtAvatarLockChairReq
 */
export const EvtAvatarLockChairReq = new EvtAvatarLockChairReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtAvatarLockChairRsp$Type extends MessageType<EvtAvatarLockChairRsp> {
    constructor() {
        super("com.midnights.game.EvtAvatarLockChairRsp", [
            { no: 14, name: "chair_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 15, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "position", kind: "message", T: () => Vector },
            { no: 12, name: "retcode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<EvtAvatarLockChairRsp>): EvtAvatarLockChairRsp {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtAvatarLockChairRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtAvatarLockChairRsp): EvtAvatarLockChairRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 chair_id */ 14:
                    message.chairId = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 entity_id */ 15:
                    message.entityId = reader.uint32();
                    break;
                case /* optional com.midnights.game.Vector position */ 4:
                    message.position = Vector.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* optional int32 retcode */ 12:
                    message.retcode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtAvatarLockChairRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 chair_id = 14; */
        if (message.chairId !== undefined)
            writer.tag(14, WireType.Varint).uint64(message.chairId);
        /* optional uint32 entity_id = 15; */
        if (message.entityId !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.entityId);
        /* optional com.midnights.game.Vector position = 4; */
        if (message.position)
            Vector.internalBinaryWrite(message.position, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 retcode = 12; */
        if (message.retcode !== undefined)
            writer.tag(12, WireType.Varint).int32(message.retcode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtAvatarLockChairRsp
 */
export const EvtAvatarLockChairRsp = new EvtAvatarLockChairRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReportFightAntiCheatNotify$Type extends MessageType<ReportFightAntiCheatNotify> {
    constructor() {
        super("com.midnights.game.ReportFightAntiCheatNotify", [
            { no: 8, name: "cheat_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "cheat_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ReportFightAntiCheatNotify>): ReportFightAntiCheatNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReportFightAntiCheatNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReportFightAntiCheatNotify): ReportFightAntiCheatNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 cheat_count */ 8:
                    message.cheatCount = reader.uint32();
                    break;
                case /* optional uint32 cheat_type */ 12:
                    message.cheatType = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReportFightAntiCheatNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 cheat_count = 8; */
        if (message.cheatCount !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.cheatCount);
        /* optional uint32 cheat_type = 12; */
        if (message.cheatType !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.cheatType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.ReportFightAntiCheatNotify
 */
export const ReportFightAntiCheatNotify = new ReportFightAntiCheatNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtBeingHealedNotify$Type extends MessageType<EvtBeingHealedNotify> {
    constructor() {
        super("com.midnights.game.EvtBeingHealedNotify", [
            { no: 1, name: "target_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "real_heal_amount", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 13, name: "source_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "heal_amount", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<EvtBeingHealedNotify>): EvtBeingHealedNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtBeingHealedNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtBeingHealedNotify): EvtBeingHealedNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 target_id */ 1:
                    message.targetId = reader.uint32();
                    break;
                case /* optional float real_heal_amount */ 5:
                    message.realHealAmount = reader.float();
                    break;
                case /* optional uint32 source_id */ 13:
                    message.sourceId = reader.uint32();
                    break;
                case /* optional float heal_amount */ 4:
                    message.healAmount = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtBeingHealedNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 target_id = 1; */
        if (message.targetId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.targetId);
        /* optional float real_heal_amount = 5; */
        if (message.realHealAmount !== undefined)
            writer.tag(5, WireType.Bit32).float(message.realHealAmount);
        /* optional uint32 source_id = 13; */
        if (message.sourceId !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.sourceId);
        /* optional float heal_amount = 4; */
        if (message.healAmount !== undefined)
            writer.tag(4, WireType.Bit32).float(message.healAmount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtBeingHealedNotify
 */
export const EvtBeingHealedNotify = new EvtBeingHealedNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtLocalGadgetOwnerLeaveSceneNotify$Type extends MessageType<EvtLocalGadgetOwnerLeaveSceneNotify> {
    constructor() {
        super("com.midnights.game.EvtLocalGadgetOwnerLeaveSceneNotify", [
            { no: 10, name: "entity_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EvtLocalGadgetOwnerLeaveSceneNotify>): EvtLocalGadgetOwnerLeaveSceneNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtLocalGadgetOwnerLeaveSceneNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtLocalGadgetOwnerLeaveSceneNotify): EvtLocalGadgetOwnerLeaveSceneNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 entity_id */ 10:
                    message.entityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtLocalGadgetOwnerLeaveSceneNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 entity_id = 10; */
        if (message.entityId !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.midnights.game.EvtLocalGadgetOwnerLeaveSceneNotify
 */
export const EvtLocalGadgetOwnerLeaveSceneNotify = new EvtLocalGadgetOwnerLeaveSceneNotify$Type();
